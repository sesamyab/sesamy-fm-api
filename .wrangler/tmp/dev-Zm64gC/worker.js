var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except4, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except4)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __template = (cooked, raw2) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw2 || cooked.slice()) }));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count4, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/hono/dist/http-exception.js
var HTTPException;
var init_http_exception = __esm({
  "node_modules/hono/dist/http-exception.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    HTTPException = class extends Error {
      static {
        __name(this, "HTTPException");
      }
      res;
      status;
      constructor(status = 500, options) {
        super(options?.message, { cause: options?.cause });
        this.res = options?.res;
        this.status = status;
      }
      getResponse() {
        if (this.res) {
          const newResponse = new Response(this.res.body, {
            status: this.status,
            headers: this.res.headers
          });
          return newResponse;
        }
        return new Response(this.message, {
          status: this.status
        });
      }
    };
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    ZodError = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error3) => {
          for (const issue of error3.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error3 = new ZodError(issues);
      return error3;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ZodError();
    init_util();
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message2;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message2 = "Required";
          } else {
            message2 = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message2 = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message2 = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message2 = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message2 = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message2 = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message2 = `Invalid ${issue.validation}`;
          } else {
            message2 = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message2 = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message2 = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message2 = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message2 = "Number must be finite";
          break;
        default:
          message2 = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message: message2 };
    }, "errorMap");
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_en();
    overrideErrorMap = en_default;
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    init_en();
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(errorUtil2) {
      errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
      errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message2 ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message2 ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b2) {
  const aType = getParsedType(a);
  const bType = getParsedType(b2);
  if (a === b2) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p2 === "string" ? { message: p2 } : p2;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types = __esm({
  "node_modules/zod/v3/types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ZodError();
    init_errors();
    init_errorUtil();
    init_parseUtil();
    init_util();
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error3 = new ZodError(ctx.common.issues);
            this._error = error3;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message2) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message2 === "string" || typeof message2 === "undefined") {
            return { message: message2 };
          } else if (typeof message2 === "function") {
            return message2(val);
          } else {
            return message2;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    __name(isValidJWT, "isValidJWT");
    __name(isValidCidr, "isValidCidr");
    ZodString = class _ZodString extends ZodType {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message2) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message2)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message2) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
      }
      url(message2) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
      }
      emoji(message2) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
      }
      uuid(message2) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
      }
      nanoid(message2) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
      }
      cuid(message2) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
      }
      cuid2(message2) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
      }
      ulid(message2) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
      }
      base64(message2) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
      }
      base64url(message2) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message2)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message2) {
        return this._addCheck({ kind: "date", message: message2 });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message2) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
      }
      regex(regex, message2) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message2)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message2) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message2)
        });
      }
      endsWith(value, message2) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message2)
        });
      }
      min(minLength, message2) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message2)
        });
      }
      max(maxLength, message2) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message2)
        });
      }
      length(len, message2) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message2)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message2) {
        return this.min(1, errorUtil.errToObj(message2));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    ZodNumber = class _ZodNumber extends ZodType {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message2) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message2)
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message2)
        });
      }
      finite(message2) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message2)
        });
      }
      safe(message2) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message2)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message2) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message2)
        });
      }
      max(maxDate, message2) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message2)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message2) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message2) }
        });
      }
      max(maxLength, message2) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message2) }
        });
      }
      length(len, message2) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message2) }
        });
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    __name(deepPartialify, "deepPartialify");
    ZodObject = class _ZodObject extends ZodType {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message2) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message2 !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message2).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    __name(mergeValues, "mergeValues");
    ZodIntersection = class extends ZodType {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message2) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message2) }
        });
      }
      max(maxSize, message2) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message2) }
        });
      }
      size(size, message2) {
        return this.min(size, message2).max(size, message2);
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error3) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error3
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error3) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error3
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error3 = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error3.addIssue(makeArgsIssue(args, e));
              throw error3;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error3.addIssue(makeReturnsIssue(result, e));
              throw error3;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    __name(createZodEnum, "createZodEnum");
    ZodEnum = class _ZodEnum extends ZodType {
      static {
        __name(this, "ZodEnum");
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      static {
        __name(this, "ZodNativeEnum");
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b2) {
        return new _ZodPipeline({
          in: a,
          out: b2,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    __name(cleanParams, "cleanParams");
    __name(custom, "custom");
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
      number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }), "boolean"),
      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
      date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    init_parseUtil();
    init_typeAliases();
    init_util();
    init_types();
    init_ZodError();
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_external();
    init_external();
  }
});

// dist/common/errors.js
var errorHandler2, NotFoundError;
var init_errors2 = __esm({
  "dist/common/errors.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_http_exception();
    init_zod();
    errorHandler2 = /* @__PURE__ */ __name((err, c2) => {
      if (err instanceof ZodError) {
        const validationErrors = err.errors.map((error3) => `${error3.path.join(".")} ${error3.message}`).join(", ");
        const problem2 = {
          type: "validation_error",
          title: "Validation Error",
          status: 400,
          detail: validationErrors,
          instance: c2.req.path
        };
        return c2.json(problem2, 400);
      }
      if (err instanceof HTTPException) {
        let problem2;
        try {
          problem2 = JSON.parse(err.message);
        } catch {
          const status = err.status;
          let type = "internal_error";
          let title2 = "Internal Server Error";
          switch (status) {
            case 400:
              type = "validation_error";
              title2 = "Validation Error";
              break;
            case 401:
              type = "unauthorized";
              title2 = "Unauthorized";
              break;
            case 403:
              type = "forbidden";
              title2 = "Forbidden";
              break;
            case 404:
              type = "not_found";
              title2 = "Not Found";
              break;
            case 409:
              type = "conflict";
              title2 = "Conflict";
              break;
            default:
              type = "internal_error";
              title2 = "Internal Server Error";
          }
          problem2 = {
            type,
            title: title2,
            status,
            detail: err.message || title2,
            instance: c2.req.path
          };
        }
        return c2.json(problem2, err.status);
      }
      const problem = {
        type: "internal_error",
        title: "Internal Server Error",
        status: 500,
        detail: "An unexpected error occurred",
        instance: c2.req.path
      };
      return c2.json(problem, 500);
    }, "errorHandler");
    NotFoundError = class extends Error {
      static {
        __name(this, "NotFoundError");
      }
      constructor(message2) {
        super(message2);
        this.name = "NotFoundError";
      }
    };
  }
});

// node_modules/drizzle-orm/entity.js
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
var entityKind, hasOwnEntityKind;
var init_entity = __esm({
  "node_modules/drizzle-orm/entity.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    entityKind = Symbol.for("drizzle:entityKind");
    hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
    __name(is, "is");
  }
});

// node_modules/drizzle-orm/logger.js
var ConsoleLogWriter, DefaultLogger, NoopLogger;
var init_logger = __esm({
  "node_modules/drizzle-orm/logger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    ConsoleLogWriter = class {
      static {
        __name(this, "ConsoleLogWriter");
      }
      static [entityKind] = "ConsoleLogWriter";
      write(message2) {
        console.log(message2);
      }
    };
    DefaultLogger = class {
      static {
        __name(this, "DefaultLogger");
      }
      static [entityKind] = "DefaultLogger";
      writer;
      constructor(config2) {
        this.writer = config2?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p2) => {
          try {
            return JSON.stringify(p2);
          } catch {
            return String(p2);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    };
    NoopLogger = class {
      static {
        __name(this, "NoopLogger");
      }
      static [entityKind] = "NoopLogger";
      logQuery() {
      }
    };
  }
});

// node_modules/drizzle-orm/table.js
function getTableName(table3) {
  return table3[TableName];
}
function getTableUniqueName(table3) {
  return `${table3[Schema] ?? "public"}.${table3[TableName]}`;
}
var TableName, Schema, Columns, ExtraConfigColumns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, Table;
var init_table = __esm({
  "node_modules/drizzle-orm/table.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    TableName = Symbol.for("drizzle:Name");
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = class {
      static {
        __name(this, "Table");
      }
      static [entityKind] = "Table";
      /** @internal */
      static Symbol = {
        Name: TableName,
        Schema,
        OriginalName,
        Columns,
        ExtraConfigColumns,
        BaseName,
        IsAlias,
        ExtraConfigBuilder
      };
      /**
       * @internal
       * Can be changed if the table is aliased.
       */
      [TableName];
      /**
       * @internal
       * Used to store the original name of the table, before any aliasing.
       */
      [OriginalName];
      /** @internal */
      [Schema];
      /** @internal */
      [Columns];
      /** @internal */
      [ExtraConfigColumns];
      /**
       *  @internal
       * Used to store the table name before the transformation via the `tableCreator` functions.
       */
      [BaseName];
      /** @internal */
      [IsAlias] = false;
      /** @internal */
      [IsDrizzleTable] = true;
      /** @internal */
      [ExtraConfigBuilder] = void 0;
      constructor(name, schema, baseName) {
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema;
        this[BaseName] = baseName;
      }
    };
    __name(getTableName, "getTableName");
    __name(getTableUniqueName, "getTableUniqueName");
  }
});

// node_modules/drizzle-orm/column.js
var Column;
var init_column = __esm({
  "node_modules/drizzle-orm/column.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    Column = class {
      static {
        __name(this, "Column");
      }
      constructor(table3, config2) {
        this.table = table3;
        this.config = config2;
        this.name = config2.name;
        this.notNull = config2.notNull;
        this.default = config2.default;
        this.defaultFn = config2.defaultFn;
        this.onUpdateFn = config2.onUpdateFn;
        this.hasDefault = config2.hasDefault;
        this.primary = config2.primaryKey;
        this.isUnique = config2.isUnique;
        this.uniqueName = config2.uniqueName;
        this.uniqueType = config2.uniqueType;
        this.dataType = config2.dataType;
        this.columnType = config2.columnType;
        this.generated = config2.generated;
        this.generatedIdentity = config2.generatedIdentity;
      }
      static [entityKind] = "Column";
      name;
      primary;
      notNull;
      default;
      defaultFn;
      onUpdateFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      generated = void 0;
      generatedIdentity = void 0;
      config;
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
      // ** @internal */
      shouldDisableInsert() {
        return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/table.js
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const builtColumnsForExtraConfig = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.buildExtraConfigColumn(rawTable);
      return [name2, column];
    })
  );
  const table3 = Object.assign(rawTable, builtColumns);
  table3[Table.Symbol.Columns] = builtColumns;
  table3[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table3[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table3;
}
var InlineForeignKeys, PgTable, pgTable;
var init_table2 = __esm({
  "node_modules/drizzle-orm/pg-core/table.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table();
    InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
    PgTable = class extends Table {
      static {
        __name(this, "PgTable");
      }
      static [entityKind] = "PgTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys
      });
      /**@internal */
      [InlineForeignKeys] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __name(pgTableWithSchema, "pgTableWithSchema");
    pgTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
      return pgTableWithSchema(name, columns, extraConfig, void 0);
    }, "pgTable");
  }
});

// node_modules/drizzle-orm/pg-core/primary-keys.js
var PrimaryKeyBuilder, PrimaryKey;
var init_primary_keys = __esm({
  "node_modules/drizzle-orm/pg-core/primary-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table2();
    PrimaryKeyBuilder = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "PgPrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table3) {
        return new PrimaryKey(table3, this.columns, this.name);
      }
    };
    PrimaryKey = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table3, columns, name) {
        this.table = table3;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "PgPrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
  }
});

// node_modules/drizzle-orm/column-builder.js
var ColumnBuilder;
var init_column_builder = __esm({
  "node_modules/drizzle-orm/column-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    ColumnBuilder = class {
      static {
        __name(this, "ColumnBuilder");
      }
      static [entityKind] = "ColumnBuilder";
      config;
      constructor(name, dataType, columnType) {
        this.config = {
          name,
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType,
          generated: void 0
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $defaultFn}.
       */
      $default = this.$defaultFn;
      /**
       * Adds a dynamic update value to the column.
       * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
       * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $onUpdateFn(fn) {
        this.config.onUpdateFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $onUpdateFn}.
       */
      $onUpdate = this.$onUpdateFn;
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/foreign-keys.js
var ForeignKeyBuilder, ForeignKey;
var init_foreign_keys = __esm({
  "node_modules/drizzle-orm/pg-core/foreign-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table2();
    ForeignKeyBuilder = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "PgForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate = "no action";
      /** @internal */
      _onDelete = "no action";
      constructor(config2, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config2();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action === void 0 ? "no action" : action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action === void 0 ? "no action" : action;
        return this;
      }
      /** @internal */
      build(table3) {
        return new ForeignKey(table3, this);
      }
    };
    ForeignKey = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table3, builder) {
        this.table = table3;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "PgForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[PgTable.Symbol.Name],
          ...columnNames,
          foreignColumns[0].table[PgTable.Symbol.Name],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
  }
});

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}
var init_tracing_utils = __esm({
  "node_modules/drizzle-orm/tracing-utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(iife, "iife");
  }
});

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table3, columns) {
  return `${table3[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder, UniqueOnConstraintBuilder, UniqueConstraint;
var init_unique_constraint = __esm({
  "node_modules/drizzle-orm/pg-core/unique-constraint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table2();
    __name(uniqueKeyName, "uniqueKeyName");
    UniqueConstraintBuilder = class {
      static {
        __name(this, "UniqueConstraintBuilder");
      }
      constructor(columns, name) {
        this.name = name;
        this.columns = columns;
      }
      static [entityKind] = "PgUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      nullsNotDistinctConfig = false;
      nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
      }
      /** @internal */
      build(table3) {
        return new UniqueConstraint(table3, this.columns, this.nullsNotDistinctConfig, this.name);
      }
    };
    UniqueOnConstraintBuilder = class {
      static {
        __name(this, "UniqueOnConstraintBuilder");
      }
      static [entityKind] = "PgUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name) {
        this.name = name;
      }
      on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
      }
    };
    UniqueConstraint = class {
      static {
        __name(this, "UniqueConstraint");
      }
      constructor(table3, columns, nullsNotDistinct, name) {
        this.table = table3;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
      }
      static [entityKind] = "PgUniqueConstraint";
      columns;
      name;
      nullsNotDistinct = false;
      getName() {
        return this.name;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom; i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
var init_array = __esm({
  "node_modules/drizzle-orm/pg-core/utils/array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(parsePgArrayValue, "parsePgArrayValue");
    __name(parsePgNestedArray, "parsePgNestedArray");
    __name(parsePgArray, "parsePgArray");
    __name(makePgArray, "makePgArray");
  }
});

// node_modules/drizzle-orm/pg-core/columns/common.js
var PgColumnBuilder, PgColumn, ExtraConfigColumn, IndexedColumn, PgArrayBuilder, PgArray;
var init_common = __esm({
  "node_modules/drizzle-orm/pg-core/columns/common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys();
    init_tracing_utils();
    init_unique_constraint();
    init_array();
    PgColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "PgColumnBuilder");
      }
      foreignKeyConfigs = [];
      static [entityKind] = "PgColumnBuilder";
      array(size) {
        return new PgArrayBuilder(this.config.name, this, size);
      }
      references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
      }
      unique(name, config2) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        this.config.uniqueType = config2?.nulls;
        return this;
      }
      generatedAlwaysAs(as) {
        this.config.generated = {
          as,
          type: "always",
          mode: "stored"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table3) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
          return iife(
            (ref2, actions2) => {
              const builder = new ForeignKeyBuilder(() => {
                const foreignColumn = ref2();
                return { columns: [column], foreignColumns: [foreignColumn] };
              });
              if (actions2.onUpdate) {
                builder.onUpdate(actions2.onUpdate);
              }
              if (actions2.onDelete) {
                builder.onDelete(actions2.onDelete);
              }
              return builder.build(table3);
            },
            ref,
            actions
          );
        });
      }
      /** @internal */
      buildExtraConfigColumn(table3) {
        return new ExtraConfigColumn(table3, this.config);
      }
    };
    PgColumn = class extends Column {
      static {
        __name(this, "PgColumn");
      }
      constructor(table3, config2) {
        if (!config2.uniqueName) {
          config2.uniqueName = uniqueKeyName(table3, [config2.name]);
        }
        super(table3, config2);
        this.table = table3;
      }
      static [entityKind] = "PgColumn";
    };
    ExtraConfigColumn = class extends PgColumn {
      static {
        __name(this, "ExtraConfigColumn");
      }
      static [entityKind] = "ExtraConfigColumn";
      getSQLType() {
        return this.getSQLType();
      }
      indexConfig = {
        order: this.config.order ?? "asc",
        nulls: this.config.nulls ?? "last",
        opClass: this.config.opClass
      };
      defaultConfig = {
        order: "asc",
        nulls: "last",
        opClass: void 0
      };
      asc() {
        this.indexConfig.order = "asc";
        return this;
      }
      desc() {
        this.indexConfig.order = "desc";
        return this;
      }
      nullsFirst() {
        this.indexConfig.nulls = "first";
        return this;
      }
      nullsLast() {
        this.indexConfig.nulls = "last";
        return this;
      }
      /**
       * ### PostgreSQL documentation quote
       *
       * > An operator class with optional parameters can be specified for each column of an index.
       * The operator class identifies the operators to be used by the index for that column.
       * For example, a B-tree index on four-byte integers would use the int4_ops class;
       * this operator class includes comparison functions for four-byte integers.
       * In practice the default operator class for the column's data type is usually sufficient.
       * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
       * For example, we might want to sort a complex-number data type either by absolute value or by real part.
       * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
       * More information about operator classes check:
       *
       * ### Useful links
       * https://www.postgresql.org/docs/current/sql-createindex.html
       *
       * https://www.postgresql.org/docs/current/indexes-opclass.html
       *
       * https://www.postgresql.org/docs/current/xindex.html
       *
       * ### Additional types
       * If you have the `pg_vector` extension installed in your database, you can use the
       * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
       *
       * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
       *
       * @param opClass
       * @returns
       */
      op(opClass) {
        this.indexConfig.opClass = opClass;
        return this;
      }
    };
    IndexedColumn = class {
      static {
        __name(this, "IndexedColumn");
      }
      static [entityKind] = "IndexedColumn";
      constructor(name, type, indexConfig) {
        this.name = name;
        this.type = type;
        this.indexConfig = indexConfig;
      }
      name;
      type;
      indexConfig;
    };
    PgArrayBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgArrayBuilder");
      }
      static [entityKind] = "PgArrayBuilder";
      constructor(name, baseBuilder, size) {
        super(name, "array", "PgArray");
        this.config.baseBuilder = baseBuilder;
        this.config.size = size;
      }
      /** @internal */
      build(table3) {
        const baseColumn = this.config.baseBuilder.build(table3);
        return new PgArray(
          table3,
          this.config,
          baseColumn
        );
      }
    };
    PgArray = class _PgArray extends PgColumn {
      static {
        __name(this, "PgArray");
      }
      constructor(table3, config2, baseColumn, range) {
        super(table3, config2);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config2.size;
      }
      size;
      static [entityKind] = "PgArray";
      getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
      }
      mapToDriverValue(value, isNestedArray = false) {
        const a = value.map(
          (v) => v === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v)
        );
        if (isNestedArray)
          return a;
        return makePgArray(a);
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/enum.js
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
function pgEnumWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign(
    (name) => new PgEnumColumnBuilder(name, enumInstance),
    {
      enumName,
      enumValues: values,
      schema,
      [isPgEnumSym]: true
    }
  );
  return enumInstance;
}
var isPgEnumSym, PgEnumColumnBuilder, PgEnumColumn;
var init_enum = __esm({
  "node_modules/drizzle-orm/pg-core/columns/enum.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    isPgEnumSym = Symbol.for("drizzle:isPgEnum");
    __name(isPgEnum, "isPgEnum");
    PgEnumColumnBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgEnumColumnBuilder");
      }
      static [entityKind] = "PgEnumColumnBuilder";
      constructor(name, enumInstance) {
        super(name, "string", "PgEnumColumn");
        this.config.enum = enumInstance;
      }
      /** @internal */
      build(table3) {
        return new PgEnumColumn(
          table3,
          this.config
        );
      }
    };
    PgEnumColumn = class extends PgColumn {
      static {
        __name(this, "PgEnumColumn");
      }
      static [entityKind] = "PgEnumColumn";
      enum = this.config.enum;
      enumValues = this.config.enum.enumValues;
      constructor(table3, config2) {
        super(table3, config2);
        this.enum = config2.enum;
      }
      getSQLType() {
        return this.enum.enumName;
      }
    };
    __name(pgEnumWithSchema, "pgEnumWithSchema");
  }
});

// node_modules/drizzle-orm/subquery.js
var Subquery, WithSubquery;
var init_subquery = __esm({
  "node_modules/drizzle-orm/subquery.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    Subquery = class {
      static {
        __name(this, "Subquery");
      }
      static [entityKind] = "Subquery";
      constructor(sql2, selection, alias, isWith = false) {
        this._ = {
          brand: "Subquery",
          sql: sql2,
          selectedFields: selection,
          alias,
          isWith
        };
      }
      // getSQL(): SQL<unknown> {
      // 	return new SQL([this]);
      // }
    };
    WithSubquery = class extends Subquery {
      static {
        __name(this, "WithSubquery");
      }
      static [entityKind] = "WithSubquery";
    };
  }
});

// node_modules/drizzle-orm/version.js
var version2;
var init_version = __esm({
  "node_modules/drizzle-orm/version.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    version2 = "0.33.0";
  }
});

// node_modules/drizzle-orm/tracing.js
var otel, rawTracer, tracer;
var init_tracing = __esm({
  "node_modules/drizzle-orm/tracing.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tracing_utils();
    init_version();
    tracer = {
      startActiveSpan(name, fn) {
        if (!otel) {
          return fn();
        }
        if (!rawTracer) {
          rawTracer = otel.trace.getTracer("drizzle-orm", version2);
        }
        return iife(
          (otel2, rawTracer2) => rawTracer2.startActiveSpan(
            name,
            (span) => {
              try {
                return fn(span);
              } catch (e) {
                span.setStatus({
                  code: otel2.SpanStatusCode.ERROR,
                  message: e instanceof Error ? e.message : "Unknown error"
                  // eslint-disable-line no-instanceof/no-instanceof
                });
                throw e;
              } finally {
                span.end();
              }
            }
          ),
          otel,
          rawTracer
        );
      }
    };
  }
});

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig;
var init_view_common = __esm({
  "node_modules/drizzle-orm/view-common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
  }
});

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p2) => {
    if (is(p2, Placeholder)) {
      if (!(p2.name in values)) {
        throw new Error(`No value for placeholder "${p2.name}" was provided`);
      }
      return values[p2.name];
    }
    if (is(p2, Param) && is(p2.value, Placeholder)) {
      if (!(p2.value.name in values)) {
        throw new Error(`No value for placeholder "${p2.value.name}" was provided`);
      }
      return p2.encoder.mapToDriverValue(values[p2.value.name]);
    }
    return p2;
  });
}
var FakePrimitiveParam, StringChunk, SQL, Name, noopDecoder, noopEncoder, noopMapper, Param, Placeholder, View;
var init_sql = __esm({
  "node_modules/drizzle-orm/sql/sql.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_enum();
    init_subquery();
    init_tracing();
    init_view_common();
    init_column();
    init_table();
    FakePrimitiveParam = class {
      static {
        __name(this, "FakePrimitiveParam");
      }
      static [entityKind] = "FakePrimitiveParam";
    };
    __name(isSQLWrapper, "isSQLWrapper");
    __name(mergeQueries, "mergeQueries");
    StringChunk = class {
      static {
        __name(this, "StringChunk");
      }
      static [entityKind] = "StringChunk";
      value;
      constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    SQL = class _SQL {
      static {
        __name(this, "SQL");
      }
      constructor(queryChunks) {
        this.queryChunks = queryChunks;
      }
      static [entityKind] = "SQL";
      /** @internal */
      decoder = noopDecoder;
      shouldInlineParams = false;
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config2) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config2);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config2 = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const {
          escapeName,
          escapeParam,
          prepareTyping,
          inlineParams,
          paramStartIndex
        } = config2;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i, p2] of chunk.entries()) {
              result.push(p2);
              if (i < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config2);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config2,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            if (_config.invokeSource === "indexes") {
              return { sql: escapeName(chunk.name), params: [] };
            }
            return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            if (is(chunk.value, Placeholder)) {
              return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
            }
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config2);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config2), params: [] };
            }
            let typings = ["none"];
            if (prepareTyping) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk._.isWith) {
              return { sql: escapeName(chunk._.alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk._.sql,
              new StringChunk(") "),
              new Name(chunk._.alias)
            ], config2);
          }
          if (isPgEnum(chunk)) {
            if (chunk.schema) {
              return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
            }
            return { sql: escapeName(chunk.enumName), params: [] };
          }
          if (isSQLWrapper(chunk)) {
            if (chunk.shouldOmitSQLParens?.()) {
              return this.buildQueryFromSourceParams([chunk.getSQL()], config2);
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config2);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config2), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }));
      }
      mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString(JSON.stringify(chunk));
          }
          return escapeString(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder2) {
        this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
      /**
       * This method is used to conditionally include a part of the query.
       *
       * @param condition - Condition to check
       * @returns itself if the condition is `true`, otherwise `undefined`
       */
      if(condition) {
        return condition ? this : void 0;
      }
    };
    Name = class {
      static {
        __name(this, "Name");
      }
      constructor(value) {
        this.value = value;
      }
      static [entityKind] = "Name";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(isDriverValueEncoder, "isDriverValueEncoder");
    noopDecoder = {
      mapFromDriverValue: /* @__PURE__ */ __name((value) => value, "mapFromDriverValue")
    };
    noopEncoder = {
      mapToDriverValue: /* @__PURE__ */ __name((value) => value, "mapToDriverValue")
    };
    noopMapper = {
      ...noopDecoder,
      ...noopEncoder
    };
    Param = class {
      static {
        __name(this, "Param");
      }
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder3 = noopEncoder) {
        this.value = value;
        this.encoder = encoder3;
      }
      static [entityKind] = "Param";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(sql, "sql");
    ((sql2) => {
      function empty() {
        return new SQL([]);
      }
      __name(empty, "empty");
      sql2.empty = empty;
      function fromList(list) {
        return new SQL(list);
      }
      __name(fromList, "fromList");
      sql2.fromList = fromList;
      function raw2(str) {
        return new SQL([new StringChunk(str)]);
      }
      __name(raw2, "raw");
      sql2.raw = raw2;
      function join(chunks, separator) {
        const result = [];
        for (const [i, chunk] of chunks.entries()) {
          if (i > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      __name(join, "join");
      sql2.join = join;
      function identifier(value) {
        return new Name(value);
      }
      __name(identifier, "identifier");
      sql2.identifier = identifier;
      function placeholder2(name2) {
        return new Placeholder(name2);
      }
      __name(placeholder2, "placeholder2");
      sql2.placeholder = placeholder2;
      function param2(value, encoder3) {
        return new Param(value, encoder3);
      }
      __name(param2, "param2");
      sql2.param = param2;
    })(sql || (sql = {}));
    ((SQL2) => {
      class Aliased {
        static {
          __name(this, "Aliased");
        }
        constructor(sql2, fieldAlias) {
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        static [entityKind] = "SQL.Aliased";
        /** @internal */
        isSelectionField = false;
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new Aliased(this.sql, this.fieldAlias);
        }
      }
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = class {
      static {
        __name(this, "Placeholder");
      }
      constructor(name2) {
        this.name = name2;
      }
      static [entityKind] = "Placeholder";
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(fillPlaceholders, "fillPlaceholders");
    View = class {
      static {
        __name(this, "View");
      }
      static [entityKind] = "View";
      /** @internal */
      [ViewBaseConfig];
      constructor({ name: name2, schema, selectedFields, query }) {
        this[ViewBaseConfig] = {
          name: name2,
          originalName: name2,
          schema,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Table.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Subquery.prototype.getSQL = function() {
      return new SQL([this]);
    };
  }
});

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c2) => c2 !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
var eq, ne, gt, gte, lt, lte;
var init_conditions = __esm({
  "node_modules/drizzle-orm/sql/expressions/conditions.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column();
    init_entity();
    init_table();
    init_sql();
    __name(bindIfParam, "bindIfParam");
    eq = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    }, "eq");
    ne = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    }, "ne");
    __name(and, "and");
    __name(or, "or");
    __name(not, "not");
    gt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    }, "gt");
    gte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    }, "gte");
    lt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    }, "lt");
    lte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    }, "lte");
    __name(inArray, "inArray");
    __name(notInArray, "notInArray");
    __name(isNull, "isNull");
    __name(isNotNull, "isNotNull");
    __name(exists, "exists");
    __name(notExists, "notExists");
    __name(between, "between");
    __name(notBetween, "notBetween");
    __name(like, "like");
    __name(notLike, "notLike");
    __name(ilike, "ilike");
    __name(notIlike, "notIlike");
  }
});

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
var init_select = __esm({
  "node_modules/drizzle-orm/sql/expressions/select.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sql();
    __name(asc, "asc");
    __name(desc, "desc");
  }
});

// node_modules/drizzle-orm/sql/expressions/index.js
var init_expressions = __esm({
  "node_modules/drizzle-orm/sql/expressions/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_conditions();
    init_select();
  }
});

// node_modules/drizzle-orm/relations.js
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function relations(table3, relations2) {
  return new Relations(
    table3,
    (helpers) => Object.fromEntries(
      Object.entries(relations2(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key)
      ])
    )
  );
}
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table3, config2) {
    return new One(
      sourceTable,
      table3,
      config2,
      config2?.fields.reduce((res, f2) => res && f2.notNull, true) ?? false
    );
  }, "one");
}
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config2) {
    return new Many(sourceTable, referencedTable, config2);
  }, "many");
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder2.mapFromDriverValue(value);
    }
  }
  return result;
}
var Relation, Relations, One, Many;
var init_relations = __esm({
  "node_modules/drizzle-orm/relations.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_table();
    init_column();
    init_entity();
    init_primary_keys();
    init_expressions();
    init_sql();
    Relation = class {
      static {
        __name(this, "Relation");
      }
      constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
      static [entityKind] = "Relation";
      referencedTableName;
      fieldName;
    };
    Relations = class {
      static {
        __name(this, "Relations");
      }
      constructor(table3, config2) {
        this.table = table3;
        this.config = config2;
      }
      static [entityKind] = "Relations";
    };
    One = class _One extends Relation {
      static {
        __name(this, "One");
      }
      constructor(sourceTable, referencedTable, config2, isNullable) {
        super(sourceTable, referencedTable, config2?.relationName);
        this.config = config2;
        this.isNullable = isNullable;
      }
      static [entityKind] = "One";
      withFieldName(fieldName) {
        const relation = new _One(
          this.sourceTable,
          this.referencedTable,
          this.config,
          this.isNullable
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    Many = class _Many extends Relation {
      static {
        __name(this, "Many");
      }
      constructor(sourceTable, referencedTable, config2) {
        super(sourceTable, referencedTable, config2?.relationName);
        this.config = config2;
      }
      static [entityKind] = "Many";
      withFieldName(fieldName) {
        const relation = new _Many(
          this.sourceTable,
          this.referencedTable,
          this.config
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    __name(getOperators, "getOperators");
    __name(getOrderByOperators, "getOrderByOperators");
    __name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
    __name(relations, "relations");
    __name(createOne, "createOne");
    __name(createMany, "createMany");
    __name(normalizeRelation, "normalizeRelation");
    __name(createTableRelationsHelpers, "createTableRelationsHelpers");
    __name(mapRelationalRow, "mapRelationalRow");
  }
});

// node_modules/drizzle-orm/alias.js
function aliasedTable(table3, tableAlias) {
  return new Proxy(table3, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
}
var ColumnAliasProxyHandler, TableAliasProxyHandler, RelationTableAliasProxyHandler;
var init_alias = __esm({
  "node_modules/drizzle-orm/alias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column();
    init_entity();
    init_sql();
    init_table();
    init_view_common();
    ColumnAliasProxyHandler = class {
      static {
        __name(this, "ColumnAliasProxyHandler");
      }
      constructor(table3) {
        this.table = table3;
      }
      static [entityKind] = "ColumnAliasProxyHandler";
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    };
    TableAliasProxyHandler = class {
      static {
        __name(this, "TableAliasProxyHandler");
      }
      constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      static [entityKind] = "TableAliasProxyHandler";
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key) => {
            proxiedColumns[key] = new Proxy(
              columns[key],
              new ColumnAliasProxyHandler(new Proxy(target, this))
            );
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    };
    RelationTableAliasProxyHandler = class {
      static {
        __name(this, "RelationTableAliasProxyHandler");
      }
      constructor(alias) {
        this.alias = alias;
      }
      static [entityKind] = "RelationTableAliasProxyHandler";
      get(target, prop) {
        if (prop === "sourceTable") {
          return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
      }
    };
    __name(aliasedTable, "aliasedTable");
    __name(aliasedTableColumn, "aliasedTableColumn");
    __name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
    __name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");
  }
});

// node_modules/drizzle-orm/selection-proxy.js
var SelectionProxyHandler;
var init_selection_proxy = __esm({
  "node_modules/drizzle-orm/selection-proxy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_view_common();
    SelectionProxyHandler = class _SelectionProxyHandler {
      static {
        __name(this, "SelectionProxyHandler");
      }
      static [entityKind] = "SelectionProxyHandler";
      config;
      constructor(config2) {
        this.config = { ...config2 };
      }
      get(subquery, prop) {
        if (prop === "_") {
          return {
            ...subquery["_"],
            selectedFields: new Proxy(
              subquery._.selectedFields,
              this
            )
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(
              subquery[ViewBaseConfig].selectedFields,
              this
            )
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(
            `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
          );
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(
              value,
              new ColumnAliasProxyHandler(
                new Proxy(
                  value.table,
                  new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
                )
              )
            );
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    };
  }
});

// node_modules/drizzle-orm/query-promise.js
var QueryPromise;
var init_query_promise = __esm({
  "node_modules/drizzle-orm/query-promise.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    QueryPromise = class {
      static {
        __name(this, "QueryPromise");
      }
      static [entityKind] = "QueryPromise";
      [Symbol.toStringTag] = "QueryPromise";
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/table.js
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new SQLiteTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table3 = Object.assign(rawTable, builtColumns);
  table3[Table.Symbol.Columns] = builtColumns;
  table3[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table3[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table3;
}
var InlineForeignKeys2, SQLiteTable, sqliteTable;
var init_table3 = __esm({
  "node_modules/drizzle-orm/sqlite-core/table.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table();
    InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");
    SQLiteTable = class extends Table {
      static {
        __name(this, "SQLiteTable");
      }
      static [entityKind] = "SQLiteTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys2
      });
      /** @internal */
      [Table.Symbol.Columns];
      /** @internal */
      [InlineForeignKeys2] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __name(sqliteTableBase, "sqliteTableBase");
    sqliteTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
      return sqliteTableBase(name, columns, extraConfig);
    }, "sqliteTable");
  }
});

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table3, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table3[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table3) {
  return table3[Table.Symbol.Columns];
}
function getTableLikeName(table3) {
  return is(table3, Subquery) ? table3._.alias : is(table3, View) ? table3[ViewBaseConfig].name : is(table3, SQL) ? void 0 : table3[Table.Symbol.IsAlias] ? table3[Table.Symbol.Name] : table3[Table.Symbol.BaseName];
}
var init_utils2 = __esm({
  "node_modules/drizzle-orm/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column();
    init_entity();
    init_sql();
    init_subquery();
    init_table();
    init_view_common();
    __name(mapResultRow, "mapResultRow");
    __name(orderSelectedFields, "orderSelectedFields");
    __name(haveSameKeys, "haveSameKeys");
    __name(mapUpdateSet, "mapUpdateSet");
    __name(applyMixins, "applyMixins");
    __name(getTableColumns, "getTableColumns");
    __name(getTableLikeName, "getTableLikeName");
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
var SQLiteDeleteBase;
var init_delete = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/delete.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_table3();
    init_utils2();
    SQLiteDeleteBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteDeleteBase");
      }
      constructor(table3, session, dialect, withList) {
        super();
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table3, withList };
      }
      static [entityKind] = "SQLiteDelete";
      /** @internal */
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute(placeholderValues) {
        return this._prepare().execute(placeholderValues);
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
var SQLiteInsertBuilder, SQLiteInsertBase;
var init_insert = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/insert.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_sql();
    init_table3();
    init_table();
    init_utils2();
    SQLiteInsertBuilder = class {
      static {
        __name(this, "SQLiteInsertBuilder");
      }
      constructor(table3, session, dialect, withList) {
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteInsertBuilder";
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
      }
    };
    SQLiteInsertBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteInsertBase");
      }
      constructor(table3, values, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table3, values, withList };
      }
      static [entityKind] = "SQLiteInsert";
      /** @internal */
      config;
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config2 = {}) {
        if (config2.target === void 0) {
          this.config.onConflict = sql`do nothing`;
        } else {
          const targetSql = Array.isArray(config2.target) ? sql`${config2.target}` : sql`${[config2.target]}`;
          const whereSql = config2.where ? sql` where ${config2.where}` : sql``;
          this.config.onConflict = sql`${targetSql} do nothing${whereSql}`;
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config2) {
        if (config2.where && (config2.targetWhere || config2.setWhere)) {
          throw new Error(
            'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
          );
        }
        const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
        const targetWhereSql = config2.targetWhere ? sql` where ${config2.targetWhere}` : void 0;
        const setWhereSql = config2.setWhere ? sql` where ${config2.setWhere}` : void 0;
        const targetSql = Array.isArray(config2.target) ? sql`${config2.target}` : sql`${[config2.target]}`;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
        this.config.onConflict = sql`${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/errors.js
var DrizzleError, TransactionRollbackError;
var init_errors3 = __esm({
  "node_modules/drizzle-orm/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    DrizzleError = class extends Error {
      static {
        __name(this, "DrizzleError");
      }
      static [entityKind] = "DrizzleError";
      constructor({ message: message2, cause }) {
        super(message2);
        this.name = "DrizzleError";
        this.cause = cause;
      }
    };
    TransactionRollbackError = class extends DrizzleError {
      static {
        __name(this, "TransactionRollbackError");
      }
      static [entityKind] = "TransactionRollbackError";
      constructor() {
        super({ message: "Rollback" });
      }
    };
  }
});

// node_modules/drizzle-orm/sql/functions/aggregate.js
function count3(expression) {
  return sql`count(${expression || sql.raw("*")})`.mapWith(Number);
}
var init_aggregate = __esm({
  "node_modules/drizzle-orm/sql/functions/aggregate.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sql();
    __name(count3, "count");
  }
});

// node_modules/drizzle-orm/sql/functions/vector.js
var init_vector = __esm({
  "node_modules/drizzle-orm/sql/functions/vector.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/sql/functions/index.js
var init_functions = __esm({
  "node_modules/drizzle-orm/sql/functions/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_aggregate();
    init_vector();
  }
});

// node_modules/drizzle-orm/sql/index.js
var init_sql2 = __esm({
  "node_modules/drizzle-orm/sql/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_expressions();
    init_functions();
    init_sql();
  }
});

// node_modules/drizzle-orm/sqlite-core/foreign-keys.js
var ForeignKeyBuilder2, ForeignKey2;
var init_foreign_keys2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/foreign-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table3();
    ForeignKeyBuilder2 = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "SQLiteForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate;
      /** @internal */
      _onDelete;
      constructor(config2, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config2();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table3) {
        return new ForeignKey2(table3, this);
      }
    };
    ForeignKey2 = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table3, builder) {
        this.table = table3;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "SQLiteForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[SQLiteTable.Symbol.Name],
          ...columnNames,
          foreignColumns[0].table[SQLiteTable.Symbol.Name],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
function uniqueKeyName2(table3, columns) {
  return `${table3[SQLiteTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder2, UniqueOnConstraintBuilder2, UniqueConstraint2;
var init_unique_constraint2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/unique-constraint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table3();
    __name(uniqueKeyName2, "uniqueKeyName");
    UniqueConstraintBuilder2 = class {
      static {
        __name(this, "UniqueConstraintBuilder");
      }
      constructor(columns, name) {
        this.name = name;
        this.columns = columns;
      }
      static [entityKind] = "SQLiteUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      build(table3) {
        return new UniqueConstraint2(table3, this.columns, this.name);
      }
    };
    UniqueOnConstraintBuilder2 = class {
      static {
        __name(this, "UniqueOnConstraintBuilder");
      }
      static [entityKind] = "SQLiteUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name) {
        this.name = name;
      }
      on(...columns) {
        return new UniqueConstraintBuilder2(columns, this.name);
      }
    };
    UniqueConstraint2 = class {
      static {
        __name(this, "UniqueConstraint");
      }
      constructor(table3, columns, name) {
        this.table = table3;
        this.columns = columns;
        this.name = name ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
      }
      static [entityKind] = "SQLiteUniqueConstraint";
      columns;
      name;
      getName() {
        return this.name;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/common.js
var SQLiteColumnBuilder, SQLiteColumn;
var init_common2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys2();
    init_unique_constraint2();
    SQLiteColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "SQLiteColumnBuilder");
      }
      static [entityKind] = "SQLiteColumnBuilder";
      foreignKeyConfigs = [];
      references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
      }
      unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
      }
      generatedAlwaysAs(as, config2) {
        this.config.generated = {
          as,
          type: "always",
          mode: config2?.mode ?? "virtual"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table3) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
          return ((ref2, actions2) => {
            const builder = new ForeignKeyBuilder2(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions2.onUpdate) {
              builder.onUpdate(actions2.onUpdate);
            }
            if (actions2.onDelete) {
              builder.onDelete(actions2.onDelete);
            }
            return builder.build(table3);
          })(ref, actions);
        });
      }
    };
    SQLiteColumn = class extends Column {
      static {
        __name(this, "SQLiteColumn");
      }
      constructor(table3, config2) {
        if (!config2.uniqueName) {
          config2.uniqueName = uniqueKeyName2(table3, [config2.name]);
        }
        super(table3, config2);
        this.table = table3;
      }
      static [entityKind] = "SQLiteColumn";
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/blob.js
var SQLiteBigIntBuilder, SQLiteBigInt, SQLiteBlobJsonBuilder, SQLiteBlobJson, SQLiteBlobBufferBuilder, SQLiteBlobBuffer;
var init_blob = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/blob.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common2();
    SQLiteBigIntBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBigIntBuilder");
      }
      static [entityKind] = "SQLiteBigIntBuilder";
      constructor(name) {
        super(name, "bigint", "SQLiteBigInt");
      }
      /** @internal */
      build(table3) {
        return new SQLiteBigInt(table3, this.config);
      }
    };
    SQLiteBigInt = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBigInt");
      }
      static [entityKind] = "SQLiteBigInt";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        return BigInt(value.toString());
      }
      mapToDriverValue(value) {
        return Buffer.from(value.toString());
      }
    };
    SQLiteBlobJsonBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBlobJsonBuilder");
      }
      static [entityKind] = "SQLiteBlobJsonBuilder";
      constructor(name) {
        super(name, "json", "SQLiteBlobJson");
      }
      /** @internal */
      build(table3) {
        return new SQLiteBlobJson(
          table3,
          this.config
        );
      }
    };
    SQLiteBlobJson = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBlobJson");
      }
      static [entityKind] = "SQLiteBlobJson";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value.toString());
      }
      mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
      }
    };
    SQLiteBlobBufferBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBlobBufferBuilder");
      }
      static [entityKind] = "SQLiteBlobBufferBuilder";
      constructor(name) {
        super(name, "buffer", "SQLiteBlobBuffer");
      }
      /** @internal */
      build(table3) {
        return new SQLiteBlobBuffer(table3, this.config);
      }
    };
    SQLiteBlobBuffer = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBlobBuffer");
      }
      static [entityKind] = "SQLiteBlobBuffer";
      getSQLType() {
        return "blob";
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/custom.js
var SQLiteCustomColumnBuilder, SQLiteCustomColumn;
var init_custom = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/custom.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common2();
    SQLiteCustomColumnBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteCustomColumnBuilder");
      }
      static [entityKind] = "SQLiteCustomColumnBuilder";
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "SQLiteCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table3) {
        return new SQLiteCustomColumn(
          table3,
          this.config
        );
      }
    };
    SQLiteCustomColumn = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteCustomColumn");
      }
      static [entityKind] = "SQLiteCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table3, config2) {
        super(table3, config2);
        this.sqlName = config2.customTypeParams.dataType(config2.fieldConfig);
        this.mapTo = config2.customTypeParams.toDriver;
        this.mapFrom = config2.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/integer.js
function integer(name, config2) {
  if (config2?.mode === "timestamp" || config2?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config2.mode);
  }
  if (config2?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config2.mode);
  }
  return new SQLiteIntegerBuilder(name);
}
var SQLiteBaseIntegerBuilder, SQLiteBaseInteger, SQLiteIntegerBuilder, SQLiteInteger, SQLiteTimestampBuilder, SQLiteTimestamp, SQLiteBooleanBuilder, SQLiteBoolean;
var init_integer = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/integer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_common2();
    SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBaseIntegerBuilder");
      }
      static [entityKind] = "SQLiteBaseIntegerBuilder";
      constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
      }
      primaryKey(config2) {
        if (config2?.autoIncrement) {
          this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
      }
    };
    SQLiteBaseInteger = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBaseInteger");
      }
      static [entityKind] = "SQLiteBaseInteger";
      autoIncrement = this.config.autoIncrement;
      getSQLType() {
        return "integer";
      }
    };
    SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteIntegerBuilder");
      }
      static [entityKind] = "SQLiteIntegerBuilder";
      constructor(name) {
        super(name, "number", "SQLiteInteger");
      }
      build(table3) {
        return new SQLiteInteger(
          table3,
          this.config
        );
      }
    };
    SQLiteInteger = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteInteger");
      }
      static [entityKind] = "SQLiteInteger";
    };
    SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteTimestampBuilder");
      }
      static [entityKind] = "SQLiteTimestampBuilder";
      constructor(name, mode) {
        super(name, "date", "SQLiteTimestamp");
        this.config.mode = mode;
      }
      /**
       * @deprecated Use `default()` with your own expression instead.
       *
       * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
       */
      defaultNow() {
        return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
      }
      build(table3) {
        return new SQLiteTimestamp(
          table3,
          this.config
        );
      }
    };
    SQLiteTimestamp = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteTimestamp");
      }
      static [entityKind] = "SQLiteTimestamp";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        if (this.config.mode === "timestamp") {
          return new Date(value * 1e3);
        }
        return new Date(value);
      }
      mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === "timestamp") {
          return Math.floor(unix / 1e3);
        }
        return unix;
      }
    };
    SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteBooleanBuilder");
      }
      static [entityKind] = "SQLiteBooleanBuilder";
      constructor(name, mode) {
        super(name, "boolean", "SQLiteBoolean");
        this.config.mode = mode;
      }
      build(table3) {
        return new SQLiteBoolean(
          table3,
          this.config
        );
      }
    };
    SQLiteBoolean = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteBoolean");
      }
      static [entityKind] = "SQLiteBoolean";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        return Number(value) === 1;
      }
      mapToDriverValue(value) {
        return value ? 1 : 0;
      }
    };
    __name(integer, "integer");
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/numeric.js
var SQLiteNumericBuilder, SQLiteNumeric;
var init_numeric = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/numeric.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common2();
    SQLiteNumericBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteNumericBuilder");
      }
      static [entityKind] = "SQLiteNumericBuilder";
      constructor(name) {
        super(name, "string", "SQLiteNumeric");
      }
      /** @internal */
      build(table3) {
        return new SQLiteNumeric(
          table3,
          this.config
        );
      }
    };
    SQLiteNumeric = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteNumeric");
      }
      static [entityKind] = "SQLiteNumeric";
      getSQLType() {
        return "numeric";
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/real.js
var SQLiteRealBuilder, SQLiteReal;
var init_real = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/real.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common2();
    SQLiteRealBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteRealBuilder");
      }
      static [entityKind] = "SQLiteRealBuilder";
      constructor(name) {
        super(name, "number", "SQLiteReal");
      }
      /** @internal */
      build(table3) {
        return new SQLiteReal(table3, this.config);
      }
    };
    SQLiteReal = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteReal");
      }
      static [entityKind] = "SQLiteReal";
      getSQLType() {
        return "real";
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/text.js
function text(name, config2 = {}) {
  return config2.mode === "json" ? new SQLiteTextJsonBuilder(name) : new SQLiteTextBuilder(name, config2);
}
var SQLiteTextBuilder, SQLiteText, SQLiteTextJsonBuilder, SQLiteTextJson;
var init_text = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/text.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common2();
    SQLiteTextBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteTextBuilder");
      }
      static [entityKind] = "SQLiteTextBuilder";
      constructor(name, config2) {
        super(name, "string", "SQLiteText");
        this.config.enumValues = config2.enum;
        this.config.length = config2.length;
      }
      /** @internal */
      build(table3) {
        return new SQLiteText(table3, this.config);
      }
    };
    SQLiteText = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteText");
      }
      static [entityKind] = "SQLiteText";
      enumValues = this.config.enumValues;
      length = this.config.length;
      constructor(table3, config2) {
        super(table3, config2);
      }
      getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ""}`;
      }
    };
    SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteTextJsonBuilder");
      }
      static [entityKind] = "SQLiteTextJsonBuilder";
      constructor(name) {
        super(name, "json", "SQLiteTextJson");
      }
      /** @internal */
      build(table3) {
        return new SQLiteTextJson(
          table3,
          this.config
        );
      }
    };
    SQLiteTextJson = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteTextJson");
      }
      static [entityKind] = "SQLiteTextJson";
      getSQLType() {
        return "text";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value);
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    };
    __name(text, "text");
  }
});

// node_modules/drizzle-orm/sqlite-core/columns/index.js
var init_columns = __esm({
  "node_modules/drizzle-orm/sqlite-core/columns/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_blob();
    init_common2();
    init_custom();
    init_integer();
    init_numeric();
    init_real();
    init_text();
  }
});

// node_modules/drizzle-orm/sqlite-core/view-base.js
var SQLiteViewBase;
var init_view_base = __esm({
  "node_modules/drizzle-orm/sqlite-core/view-base.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    SQLiteViewBase = class extends View {
      static {
        __name(this, "SQLiteViewBase");
      }
      static [entityKind] = "SQLiteViewBase";
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/dialect.js
var SQLiteDialect, SQLiteSyncDialect, SQLiteAsyncDialect;
var init_dialect = __esm({
  "node_modules/drizzle-orm/sqlite-core/dialect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column();
    init_entity();
    init_errors3();
    init_relations();
    init_sql2();
    init_sql();
    init_columns();
    init_table3();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
    init_view_base();
    SQLiteDialect = class {
      static {
        __name(this, "SQLiteDialect");
      }
      static [entityKind] = "SQLiteDialect";
      escapeName(name) {
        return `"${name}"`;
      }
      escapeParam(_num) {
        return "?";
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table: table3, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}delete from ${table3}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table3, set) {
        const tableColumns = table3[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i) => {
          const col = tableColumns[colName];
          const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
          const res = sql`${sql.identifier(col.name)} = ${value}`;
          if (i < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table: table3, set, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table3, set);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}update ${table3} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c2) => {
                    if (is(c2, Column)) {
                      return sql.identifier(c2.name);
                    }
                    return c2;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            const tableName = field.table[Table.Symbol.Name];
            const columnName = field.name;
            if (isSingleTable) {
              chunk.push(sql.identifier(columnName));
            } else {
              chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(columnName)}`);
            }
          }
          if (i < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table: table3,
        joins,
        orderBy,
        groupBy,
        limit,
        offset,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f2 of fieldsList) {
          if (is(f2.field, Column) && getTableName(f2.field.table) !== (is(table3, Subquery) ? table3._.alias : is(table3, SQLiteViewBase) ? table3[ViewBaseConfig].name : is(table3, SQL) ? void 0 : getTableName(table3)) && !((table22) => joins?.some(
            ({ alias }) => alias === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
          ))(f2.field.table)) {
            const tableName = getTableName(f2.field.table);
            throw new Error(
              `Your "${f2.path.join("->")}" field references a column "${tableName}"."${f2.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table3, Table) && table3[Table.Symbol.OriginalName] !== table3[Table.Symbol.Name]) {
            return sql`${sql.identifier(table3[Table.Symbol.OriginalName])} ${sql.identifier(table3[Table.Symbol.Name])}`;
          }
          return table3;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index, joinMeta] of joins.entries()) {
            if (index === 0) {
              joinsArray.push(sql` `);
            }
            const table22 = joinMeta.table;
            if (is(table22, SQLiteTable)) {
              const tableName = table22[SQLiteTable.Symbol.Name];
              const tableSchema = table22[SQLiteTable.Symbol.Schema];
              const origTableName = table22[SQLiteTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${table22} on ${joinMeta.on}`
              );
            }
            if (index < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        const orderByList = [];
        if (orderBy) {
          for (const [index, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index < orderBy.length - 1) {
              orderByList.push(sql`, `);
            }
          }
        }
        const groupByList = [];
        if (groupBy) {
          for (const [index, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index < groupBy.length - 1) {
              groupByList.push(sql`, `);
            }
          }
        }
        const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
        const orderBySql = orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
      }) {
        const leftChunk = sql`${leftSelect.getSQL()} `;
        const rightChunk = sql`${rightSelect.getSQL()}`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, SQLiteColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {
                const chunk = singleOrderBy.queryChunks[i];
                if (is(chunk, SQLiteColumn)) {
                  singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table: table3, values, onConflict, returning, withList }) {
        const valuesSqlList = [];
        const columns = table3[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(
          ([_, col]) => !col.shouldDisableInsert()
        );
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              let defaultValue;
              if (col.default !== null && col.default !== void 0) {
                defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
              } else if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              } else if (!col.default && col.onUpdateFn !== void 0) {
                const onUpdateFnResult = col.onUpdateFn();
                defaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              } else {
                defaultValue = sql`null`;
              }
              valueList.push(defaultValue);
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
        return sql`${withSql}insert into ${table3} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          invokeSource
        });
      }
      buildRelationalQuery({
        fullSchema,
        schema,
        tableNamesMap,
        table: table3,
        tableConfig,
        queryConfig: config2,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config2 === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config2.where) {
            const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config2.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config2.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config2.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config2.with) {
            selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config2.extras) {
            extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config2.limit;
          offset = config2.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i) => eq(
                  aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({
            message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
          });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_group_array(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table3, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                }
              ],
              where,
              limit,
              offset,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table3, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table3, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
    SQLiteSyncDialect = class extends SQLiteDialect {
      static {
        __name(this, "SQLiteSyncDialect");
      }
      static [entityKind] = "SQLiteSyncDialect";
      migrate(migrations, session, config2) {
        const migrationsTable = config2 === void 0 ? "__drizzle_migrations" : typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        session.run(sql`BEGIN`);
        try {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                session.run(sql.raw(stmt));
              }
              session.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
          session.run(sql`COMMIT`);
        } catch (e) {
          session.run(sql`ROLLBACK`);
          throw e;
        }
      }
    };
    SQLiteAsyncDialect = class extends SQLiteDialect {
      static {
        __name(this, "SQLiteAsyncDialect");
      }
      static [entityKind] = "SQLiteAsyncDialect";
      async migrate(migrations, session, config2) {
        const migrationsTable = config2 === void 0 ? "__drizzle_migrations" : typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        await session.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.run(sql.raw(stmt));
              }
              await tx.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
    };
  }
});

// node_modules/drizzle-orm/query-builders/query-builder.js
var TypedQueryBuilder;
var init_query_builder = __esm({
  "node_modules/drizzle-orm/query-builders/query-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    TypedQueryBuilder = class {
      static {
        __name(this, "TypedQueryBuilder");
      }
      static [entityKind] = "TypedQueryBuilder";
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var SQLiteSelectBuilder, SQLiteSelectQueryBuilderBase, SQLiteSelectBase, getSQLiteSetOperators, union, unionAll, intersect, except;
var init_select2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/select.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_builder();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
    init_view_base();
    SQLiteSelectBuilder = class {
      static {
        __name(this, "SQLiteSelectBuilder");
      }
      static [entityKind] = "SQLiteSelectBuilder";
      fields;
      session;
      dialect;
      withList;
      distinct;
      constructor(config2) {
        this.fields = config2.fields;
        this.session = config2.session;
        this.dialect = config2.dialect;
        this.withList = config2.withList;
        this.distinct = config2.distinct;
      }
      from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source._.selectedFields).map((key) => [key, source[key]])
          );
        } else if (is(source, SQLiteViewBase)) {
          fields = source[ViewBaseConfig].selectedFields;
        } else if (is(source, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source);
        }
        return new SQLiteSelectBase({
          table: source,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    SQLiteSelectQueryBuilderBase = class extends TypedQueryBuilder {
      static {
        __name(this, "SQLiteSelectQueryBuilderBase");
      }
      static [entityKind] = "SQLiteSelectQueryBuilder";
      _;
      /** @internal */
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      constructor({ table: table3, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table: table3,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table3);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table3, on2) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table3);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table3, SQL)) {
              const selection = is(table3, Subquery) ? table3._.selectedFields : is(table3, View) ? table3[ViewBaseConfig].selectedFields : table3[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on2 === "function") {
            on2 = on2(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on: on2, table: table3, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/sqlite-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/sqlite-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/sqlite-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/sqlite-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset;
        } else {
          this.config.offset = offset;
        }
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    SQLiteSelectBase = class extends SQLiteSelectQueryBuilderBase {
      static {
        __name(this, "SQLiteSelectBase");
      }
      static [entityKind] = "SQLiteSelect";
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          fieldsList,
          "all",
          true
        );
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.all();
      }
    };
    applyMixins(SQLiteSelectBase, [QueryPromise]);
    __name(createSetOperator, "createSetOperator");
    getSQLiteSetOperators = /* @__PURE__ */ __name(() => ({
      union,
      unionAll,
      intersect,
      except
    }), "getSQLiteSetOperators");
    union = createSetOperator("union", false);
    unionAll = createSetOperator("union", true);
    intersect = createSetOperator("intersect", false);
    except = createSetOperator("except", false);
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
var QueryBuilder;
var init_query_builder2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_dialect();
    init_subquery();
    init_select2();
    QueryBuilder = class {
      static {
        __name(this, "QueryBuilder");
      }
      static [entityKind] = "SQLiteQueryBuilder";
      dialect;
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(queryBuilder);
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        return { select, selectDistinct };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new SQLiteSyncDialect();
        }
        return this.dialect;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/select.types.js
var init_select_types = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/select.types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/update.js
var SQLiteUpdateBuilder, SQLiteUpdateBase;
var init_update = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/update.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_table3();
    init_utils2();
    SQLiteUpdateBuilder = class {
      static {
        __name(this, "SQLiteUpdateBuilder");
      }
      constructor(table3, session, dialect, withList) {
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteUpdateBuilder";
      set(values) {
        return new SQLiteUpdateBase(
          this.table,
          mapUpdateSet(this.table, values),
          this.session,
          this.dialect,
          this.withList
        );
      }
    };
    SQLiteUpdateBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteUpdateBase");
      }
      constructor(table3, set, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table: table3, withList };
      }
      static [entityKind] = "SQLiteUpdate";
      /** @internal */
      config;
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/index.js
var init_query_builders = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_delete();
    init_insert();
    init_query_builder2();
    init_select2();
    init_select_types();
    init_update();
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/query.js
var RelationalQueryBuilder, SQLiteRelationalQuery, SQLiteSyncRelationalQuery;
var init_query = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/query.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_relations();
    RelationalQueryBuilder = class {
      static {
        __name(this, "RelationalQueryBuilder");
      }
      constructor(mode, fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table3;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
      findMany(config2) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? config2 : {},
          "many"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? config2 : {},
          "many"
        );
      }
      findFirst(config2) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? { ...config2, limit: 1 } : { limit: 1 },
          "first"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? { ...config2, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    };
    SQLiteRelationalQuery = class extends QueryPromise {
      static {
        __name(this, "SQLiteRelationalQuery");
      }
      constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session, config2, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table3;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config2;
        this.mode = mode;
      }
      static [entityKind] = "SQLiteAsyncRelationalQuery";
      /** @internal */
      mode;
      /** @internal */
      getSQL() {
        return this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }).sql;
      }
      /** @internal */
      _prepare(isOneTimeQuery = false) {
        const { query, builtQuery } = this._toSQL();
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          builtQuery,
          void 0,
          this.mode === "first" ? "get" : "all",
          true,
          (rawRows, mapColumnValue) => {
            const rows = rawRows.map(
              (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
            );
            if (this.mode === "first") {
              return rows[0];
            }
            return rows;
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      _toSQL() {
        const query = this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      /** @internal */
      executeRaw() {
        if (this.mode === "first") {
          return this._prepare(false).get();
        }
        return this._prepare(false).all();
      }
      async execute() {
        return this.executeRaw();
      }
    };
    SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
      static {
        __name(this, "SQLiteSyncRelationalQuery");
      }
      static [entityKind] = "SQLiteSyncRelationalQuery";
      sync() {
        return this.executeRaw();
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/query-builders/raw.js
var SQLiteRaw;
var init_raw = __esm({
  "node_modules/drizzle-orm/sqlite-core/query-builders/raw.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    SQLiteRaw = class extends QueryPromise {
      static {
        __name(this, "SQLiteRaw");
      }
      constructor(execute, getSQL, action, dialect, mapBatchResult) {
        super();
        this.execute = execute;
        this.getSQL = getSQL;
        this.dialect = dialect;
        this.mapBatchResult = mapBatchResult;
        this.config = { action };
      }
      static [entityKind] = "SQLiteRaw";
      /** @internal */
      config;
      getQuery() {
        return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
      /** @internal */
      isResponseInArrayMode() {
        return false;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/db.js
var BaseSQLiteDatabase;
var init_db = __esm({
  "node_modules/drizzle-orm/sqlite-core/db.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_query_builders();
    init_subquery();
    init_query();
    init_raw();
    BaseSQLiteDatabase = class {
      static {
        __name(this, "BaseSQLiteDatabase");
      }
      constructor(resultKind, dialect, session, schema) {
        this.resultKind = resultKind;
        this.dialect = dialect;
        this.session = session;
        this._ = schema ? {
          schema: schema.schema,
          fullSchema: schema.fullSchema,
          tableNamesMap: schema.tableNamesMap
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {}
        };
        this.query = {};
        const query = this.query;
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            query[tableName] = new RelationalQueryBuilder(
              resultKind,
              schema.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
      }
      static [entityKind] = "BaseSQLiteDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with(alias) {
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(new QueryBuilder());
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function update(table3) {
          return new SQLiteUpdateBuilder(table3, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function insert(into) {
          return new SQLiteInsertBuilder(into, self.session, self.dialect, queries);
        }
        __name(insert, "insert");
        function delete_(from) {
          return new SQLiteDeleteBase(from, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select, selectDistinct, update, insert, delete: delete_ };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table3) {
        return new SQLiteUpdateBuilder(table3, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(from) {
        return new SQLiteDeleteBase(from, this.session, this.dialect);
      }
      run(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.run(sql2),
            () => sql2,
            "run",
            this.dialect,
            this.session.extractRawRunValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.run(sql2);
      }
      all(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.all(sql2),
            () => sql2,
            "all",
            this.dialect,
            this.session.extractRawAllValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.all(sql2);
      }
      get(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.get(sql2),
            () => sql2,
            "get",
            this.dialect,
            this.session.extractRawGetValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.get(sql2);
      }
      values(query) {
        const sql2 = query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.values(sql2),
            () => sql2,
            "values",
            this.dialect,
            this.session.extractRawValuesValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.values(sql2);
      }
      transaction(transaction, config2) {
        return this.session.transaction(transaction, config2);
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/alias.js
var init_alias2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/alias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/sqlite-core/checks.js
var CheckBuilder, Check;
var init_checks = __esm({
  "node_modules/drizzle-orm/sqlite-core/checks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    CheckBuilder = class {
      static {
        __name(this, "CheckBuilder");
      }
      constructor(name, value) {
        this.name = name;
        this.value = value;
      }
      static [entityKind] = "SQLiteCheckBuilder";
      brand;
      build(table3) {
        return new Check(table3, this);
      }
    };
    Check = class {
      static {
        __name(this, "Check");
      }
      constructor(table3, builder) {
        this.table = table3;
        this.name = builder.name;
        this.value = builder.value;
      }
      static [entityKind] = "SQLiteCheck";
      name;
      value;
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/indexes.js
var IndexBuilderOn, IndexBuilder, Index;
var init_indexes = __esm({
  "node_modules/drizzle-orm/sqlite-core/indexes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    IndexBuilderOn = class {
      static {
        __name(this, "IndexBuilderOn");
      }
      constructor(name, unique) {
        this.name = name;
        this.unique = unique;
      }
      static [entityKind] = "SQLiteIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
      }
    };
    IndexBuilder = class {
      static {
        __name(this, "IndexBuilder");
      }
      static [entityKind] = "SQLiteIndexBuilder";
      /** @internal */
      config;
      constructor(name, columns, unique) {
        this.config = {
          name,
          columns,
          unique,
          where: void 0
        };
      }
      /**
       * Condition for partial index.
       */
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table3) {
        return new Index(this.config, table3);
      }
    };
    Index = class {
      static {
        __name(this, "Index");
      }
      static [entityKind] = "SQLiteIndex";
      config;
      constructor(config2, table3) {
        this.config = { ...config2, table: table3 };
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/primary-keys.js
var PrimaryKeyBuilder2, PrimaryKey2;
var init_primary_keys2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/primary-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table3();
    PrimaryKeyBuilder2 = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "SQLitePrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table3) {
        return new PrimaryKey2(table3, this.columns, this.name);
      }
    };
    PrimaryKey2 = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table3, columns, name) {
        this.table = table3;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "SQLitePrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/session.js
var ExecuteResultSync, SQLitePreparedQuery, SQLiteSession, SQLiteTransaction;
var init_session = __esm({
  "node_modules/drizzle-orm/sqlite-core/session.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_errors3();
    init_query_promise();
    init_db();
    ExecuteResultSync = class extends QueryPromise {
      static {
        __name(this, "ExecuteResultSync");
      }
      constructor(resultCb) {
        super();
        this.resultCb = resultCb;
      }
      static [entityKind] = "ExecuteResultSync";
      async execute() {
        return this.resultCb();
      }
      sync() {
        return this.resultCb();
      }
    };
    SQLitePreparedQuery = class {
      static {
        __name(this, "SQLitePreparedQuery");
      }
      constructor(mode, executeMethod, query) {
        this.mode = mode;
        this.executeMethod = executeMethod;
        this.query = query;
      }
      static [entityKind] = "PreparedQuery";
      /** @internal */
      joinsNotNullableMap;
      getQuery() {
        return this.query;
      }
      mapRunResult(result, _isFromBatch) {
        return result;
      }
      mapAllResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      mapGetResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      execute(placeholderValues) {
        if (this.mode === "async") {
          return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
      }
      mapResult(response, isFromBatch) {
        switch (this.executeMethod) {
          case "run": {
            return this.mapRunResult(response, isFromBatch);
          }
          case "all": {
            return this.mapAllResult(response, isFromBatch);
          }
          case "get": {
            return this.mapGetResult(response, isFromBatch);
          }
        }
      }
    };
    SQLiteSession = class {
      static {
        __name(this, "SQLiteSession");
      }
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "SQLiteSession";
      prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode) {
        return this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode);
      }
      run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
          return this.prepareOneTimeQuery(staticQuery, void 0, "run", false).run();
        } catch (err) {
          throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
        }
      }
      /** @internal */
      extractRawRunValueFromBatchResult(result) {
        return result;
      }
      all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).all();
      }
      /** @internal */
      extractRawAllValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).get();
      }
      /** @internal */
      extractRawGetValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).values();
      }
      /** @internal */
      extractRawValuesValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
    };
    SQLiteTransaction = class extends BaseSQLiteDatabase {
      static {
        __name(this, "SQLiteTransaction");
      }
      constructor(resultType, dialect, session, schema, nestedIndex = 0) {
        super(resultType, dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "SQLiteTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/subquery.js
var init_subquery2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/subquery.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/sqlite-core/view-common.js
var SQLiteViewConfig;
var init_view_common2 = __esm({
  "node_modules/drizzle-orm/sqlite-core/view-common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SQLiteViewConfig = Symbol.for("drizzle:SQLiteViewConfig");
  }
});

// node_modules/drizzle-orm/sqlite-core/utils.js
var init_utils3 = __esm({
  "node_modules/drizzle-orm/sqlite-core/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/sqlite-core/view.js
var ViewBuilderCore, ViewBuilder, ManualViewBuilder, SQLiteView;
var init_view = __esm({
  "node_modules/drizzle-orm/sqlite-core/view.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_utils2();
    init_query_builder2();
    init_table3();
    init_view_base();
    init_view_common2();
    ViewBuilderCore = class {
      static {
        __name(this, "ViewBuilderCore");
      }
      constructor(name) {
        this.name = name;
      }
      static [entityKind] = "SQLiteViewBuilderCore";
      config = {};
    };
    ViewBuilder = class extends ViewBuilderCore {
      static {
        __name(this, "ViewBuilder");
      }
      static [entityKind] = "SQLiteViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelectedFields = qb.getSelectedFields();
        return new Proxy(
          new SQLiteView({
            sqliteConfig: this.config,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: aliasedSelectedFields,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualViewBuilder = class extends ViewBuilderCore {
      static {
        __name(this, "ManualViewBuilder");
      }
      static [entityKind] = "SQLiteManualViewBuilder";
      columns;
      constructor(name, columns) {
        super(name);
        this.columns = getTableColumns(sqliteTable(name, columns));
      }
      existing() {
        return new Proxy(
          new SQLiteView({
            sqliteConfig: void 0,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new SQLiteView({
            sqliteConfig: this.config,
            config: {
              name: this.name,
              schema: void 0,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    SQLiteView = class extends SQLiteViewBase {
      static {
        __name(this, "SQLiteView");
      }
      static [entityKind] = "SQLiteView";
      /** @internal */
      [SQLiteViewConfig];
      constructor({ sqliteConfig, config: config2 }) {
        super(config2);
        this[SQLiteViewConfig] = sqliteConfig;
      }
    };
  }
});

// node_modules/drizzle-orm/sqlite-core/index.js
var init_sqlite_core = __esm({
  "node_modules/drizzle-orm/sqlite-core/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias2();
    init_checks();
    init_columns();
    init_db();
    init_dialect();
    init_foreign_keys2();
    init_indexes();
    init_primary_keys2();
    init_query_builders();
    init_session();
    init_subquery2();
    init_table3();
    init_unique_constraint2();
    init_utils3();
    init_view();
  }
});

// node_modules/drizzle-orm/d1/session.js
function d1ToRawMapping(results) {
  const rows = [];
  for (const row of results) {
    const entry = Object.keys(row).map((k) => row[k]);
    rows.push(entry);
  }
  return rows;
}
var SQLiteD1Session, D1Transaction, D1PreparedQuery;
var init_session2 = __esm({
  "node_modules/drizzle-orm/d1/session.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_logger();
    init_sql();
    init_sqlite_core();
    init_session();
    init_utils2();
    SQLiteD1Session = class extends SQLiteSession {
      static {
        __name(this, "SQLiteD1Session");
      }
      constructor(client, dialect, schema, options = {}) {
        super(dialect);
        this.client = client;
        this.schema = schema;
        this.options = options;
        this.logger = options.logger ?? new NoopLogger();
      }
      static [entityKind] = "SQLiteD1Session";
      logger;
      prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper) {
        const stmt = this.client.prepare(query.sql);
        return new D1PreparedQuery(
          stmt,
          query,
          this.logger,
          fields,
          executeMethod,
          isResponseInArrayMode,
          customResultMapper
        );
      }
      async batch(queries) {
        const preparedQueries = [];
        const builtQueries = [];
        for (const query of queries) {
          const preparedQuery = query._prepare();
          const builtQuery = preparedQuery.getQuery();
          preparedQueries.push(preparedQuery);
          if (builtQuery.params.length > 0) {
            builtQueries.push(preparedQuery.stmt.bind(...builtQuery.params));
          } else {
            const builtQuery2 = preparedQuery.getQuery();
            builtQueries.push(
              this.client.prepare(builtQuery2.sql).bind(...builtQuery2.params)
            );
          }
        }
        const batchResults = await this.client.batch(builtQueries);
        return batchResults.map((result, i) => preparedQueries[i].mapResult(result, true));
      }
      extractRawAllValueFromBatchResult(result) {
        return result.results;
      }
      extractRawGetValueFromBatchResult(result) {
        return result.results[0];
      }
      extractRawValuesValueFromBatchResult(result) {
        return d1ToRawMapping(result.results);
      }
      async transaction(transaction, config2) {
        const tx = new D1Transaction("async", this.dialect, this, this.schema);
        await this.run(sql.raw(`begin${config2?.behavior ? " " + config2.behavior : ""}`));
        try {
          const result = await transaction(tx);
          await this.run(sql`commit`);
          return result;
        } catch (err) {
          await this.run(sql`rollback`);
          throw err;
        }
      }
    };
    D1Transaction = class _D1Transaction extends SQLiteTransaction {
      static {
        __name(this, "D1Transaction");
      }
      static [entityKind] = "D1Transaction";
      async transaction(transaction) {
        const savepointName = `sp${this.nestedIndex}`;
        const tx = new _D1Transaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
        await this.session.run(sql.raw(`savepoint ${savepointName}`));
        try {
          const result = await transaction(tx);
          await this.session.run(sql.raw(`release savepoint ${savepointName}`));
          return result;
        } catch (err) {
          await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
          throw err;
        }
      }
    };
    __name(d1ToRawMapping, "d1ToRawMapping");
    D1PreparedQuery = class extends SQLitePreparedQuery {
      static {
        __name(this, "D1PreparedQuery");
      }
      constructor(stmt, query, logger2, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
        super("async", executeMethod, query);
        this.logger = logger2;
        this._isResponseInArrayMode = _isResponseInArrayMode;
        this.customResultMapper = customResultMapper;
        this.fields = fields;
        this.stmt = stmt;
      }
      static [entityKind] = "D1PreparedQuery";
      /** @internal */
      customResultMapper;
      /** @internal */
      fields;
      /** @internal */
      stmt;
      run(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.stmt.bind(...params).run();
      }
      async all(placeholderValues) {
        const { fields, query, logger: logger2, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger2.logQuery(query.sql, params);
          return stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results));
        }
        const rows = await this.values(placeholderValues);
        return this.mapAllResult(rows);
      }
      mapAllResult(rows, isFromBatch) {
        if (isFromBatch) {
          rows = d1ToRawMapping(rows.results);
        }
        if (!this.fields && !this.customResultMapper) {
          return rows;
        }
        if (this.customResultMapper) {
          return this.customResultMapper(rows);
        }
        return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
      }
      async get(placeholderValues) {
        const { fields, joinsNotNullableMap, query, logger: logger2, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger2.logQuery(query.sql, params);
          return stmt.bind(...params).all().then(({ results }) => results[0]);
        }
        const rows = await this.values(placeholderValues);
        if (!rows[0]) {
          return void 0;
        }
        if (customResultMapper) {
          return customResultMapper(rows);
        }
        return mapResultRow(fields, rows[0], joinsNotNullableMap);
      }
      mapGetResult(result, isFromBatch) {
        if (isFromBatch) {
          result = d1ToRawMapping(result.results)[0];
        }
        if (!this.fields && !this.customResultMapper) {
          return result;
        }
        if (this.customResultMapper) {
          return this.customResultMapper([result]);
        }
        return mapResultRow(this.fields, result, this.joinsNotNullableMap);
      }
      values(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return this.stmt.bind(...params).raw();
      }
      /** @internal */
      isResponseInArrayMode() {
        return this._isResponseInArrayMode;
      }
    };
  }
});

// node_modules/drizzle-orm/d1/driver.js
function drizzle(client, config2 = {}) {
  const dialect = new SQLiteAsyncDialect();
  let logger2;
  if (config2.logger === true) {
    logger2 = new DefaultLogger();
  } else if (config2.logger !== false) {
    logger2 = config2.logger;
  }
  let schema;
  if (config2.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config2.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config2.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteD1Session(client, dialect, schema, { logger: logger2 });
  return new DrizzleD1Database("async", dialect, session, schema);
}
var DrizzleD1Database;
var init_driver = __esm({
  "node_modules/drizzle-orm/d1/driver.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_logger();
    init_relations();
    init_db();
    init_dialect();
    init_session2();
    DrizzleD1Database = class extends BaseSQLiteDatabase {
      static {
        __name(this, "DrizzleD1Database");
      }
      static [entityKind] = "D1Database";
      async batch(batch) {
        return this.session.batch(batch);
      }
    };
    __name(drizzle, "drizzle");
  }
});

// node_modules/drizzle-orm/d1/index.js
var init_d1 = __esm({
  "node_modules/drizzle-orm/d1/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_driver();
    init_session2();
  }
});

// node_modules/drizzle-orm/expressions.js
var init_expressions2 = __esm({
  "node_modules/drizzle-orm/expressions.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_expressions();
  }
});

// node_modules/drizzle-orm/operations.js
var init_operations = __esm({
  "node_modules/drizzle-orm/operations.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/index.js
var init_drizzle_orm = __esm({
  "node_modules/drizzle-orm/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column_builder();
    init_column();
    init_entity();
    init_errors3();
    init_expressions2();
    init_logger();
    init_operations();
    init_query_promise();
    init_relations();
    init_sql2();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
  }
});

// node_modules/drizzle-orm/mysql-core/alias.js
var init_alias3 = __esm({
  "node_modules/drizzle-orm/mysql-core/alias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/mysql-core/checks.js
var CheckBuilder2, Check2;
var init_checks2 = __esm({
  "node_modules/drizzle-orm/mysql-core/checks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    CheckBuilder2 = class {
      static {
        __name(this, "CheckBuilder");
      }
      constructor(name, value) {
        this.name = name;
        this.value = value;
      }
      static [entityKind] = "MySqlCheckBuilder";
      brand;
      /** @internal */
      build(table3) {
        return new Check2(table3, this);
      }
    };
    Check2 = class {
      static {
        __name(this, "Check");
      }
      constructor(table3, builder) {
        this.table = table3;
        this.name = builder.name;
        this.value = builder.value;
      }
      static [entityKind] = "MySqlCheck";
      name;
      value;
    };
  }
});

// node_modules/drizzle-orm/mysql-core/table.js
function mysqlTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new MySqlTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(
    Object.entries(columns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys3].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table3 = Object.assign(rawTable, builtColumns);
  table3[Table.Symbol.Columns] = builtColumns;
  table3[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table3[MySqlTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table3;
}
var InlineForeignKeys3, MySqlTable, mysqlTable;
var init_table4 = __esm({
  "node_modules/drizzle-orm/mysql-core/table.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table();
    InlineForeignKeys3 = Symbol.for("drizzle:MySqlInlineForeignKeys");
    MySqlTable = class extends Table {
      static {
        __name(this, "MySqlTable");
      }
      static [entityKind] = "MySqlTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys3
      });
      /** @internal */
      [Table.Symbol.Columns];
      /** @internal */
      [InlineForeignKeys3] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __name(mysqlTableWithSchema, "mysqlTableWithSchema");
    mysqlTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
      return mysqlTableWithSchema(name, columns, extraConfig, void 0, name);
    }, "mysqlTable");
  }
});

// node_modules/drizzle-orm/mysql-core/foreign-keys.js
var ForeignKeyBuilder3, ForeignKey3;
var init_foreign_keys3 = __esm({
  "node_modules/drizzle-orm/mysql-core/foreign-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table4();
    ForeignKeyBuilder3 = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "MySqlForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate;
      /** @internal */
      _onDelete;
      constructor(config2, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config2();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table3) {
        return new ForeignKey3(table3, this);
      }
    };
    ForeignKey3 = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table3, builder) {
        this.table = table3;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "MySqlForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[MySqlTable.Symbol.Name],
          ...columnNames,
          foreignColumns[0].table[MySqlTable.Symbol.Name],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/unique-constraint.js
function uniqueKeyName3(table3, columns) {
  return `${table3[MySqlTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
var UniqueConstraintBuilder3, UniqueOnConstraintBuilder3, UniqueConstraint3;
var init_unique_constraint3 = __esm({
  "node_modules/drizzle-orm/mysql-core/unique-constraint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table4();
    __name(uniqueKeyName3, "uniqueKeyName");
    UniqueConstraintBuilder3 = class {
      static {
        __name(this, "UniqueConstraintBuilder");
      }
      constructor(columns, name) {
        this.name = name;
        this.columns = columns;
      }
      static [entityKind] = "MySqlUniqueConstraintBuilder";
      /** @internal */
      columns;
      /** @internal */
      build(table3) {
        return new UniqueConstraint3(table3, this.columns, this.name);
      }
    };
    UniqueOnConstraintBuilder3 = class {
      static {
        __name(this, "UniqueOnConstraintBuilder");
      }
      static [entityKind] = "MySqlUniqueOnConstraintBuilder";
      /** @internal */
      name;
      constructor(name) {
        this.name = name;
      }
      on(...columns) {
        return new UniqueConstraintBuilder3(columns, this.name);
      }
    };
    UniqueConstraint3 = class {
      static {
        __name(this, "UniqueConstraint");
      }
      constructor(table3, columns, name) {
        this.table = table3;
        this.columns = columns;
        this.name = name ?? uniqueKeyName3(this.table, this.columns.map((column) => column.name));
      }
      static [entityKind] = "MySqlUniqueConstraint";
      columns;
      name;
      nullsNotDistinct = false;
      getName() {
        return this.name;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/common.js
var MySqlColumnBuilder, MySqlColumn, MySqlColumnBuilderWithAutoIncrement, MySqlColumnWithAutoIncrement;
var init_common3 = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_column_builder();
    init_column();
    init_entity();
    init_foreign_keys3();
    init_unique_constraint3();
    MySqlColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "MySqlColumnBuilder");
      }
      static [entityKind] = "MySqlColumnBuilder";
      foreignKeyConfigs = [];
      references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
      }
      unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
      }
      generatedAlwaysAs(as, config2) {
        this.config.generated = {
          as,
          type: "always",
          mode: config2?.mode ?? "virtual"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table3) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
          return ((ref2, actions2) => {
            const builder = new ForeignKeyBuilder3(() => {
              const foreignColumn = ref2();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions2.onUpdate) {
              builder.onUpdate(actions2.onUpdate);
            }
            if (actions2.onDelete) {
              builder.onDelete(actions2.onDelete);
            }
            return builder.build(table3);
          })(ref, actions);
        });
      }
    };
    MySqlColumn = class extends Column {
      static {
        __name(this, "MySqlColumn");
      }
      constructor(table3, config2) {
        if (!config2.uniqueName) {
          config2.uniqueName = uniqueKeyName3(table3, [config2.name]);
        }
        super(table3, config2);
        this.table = table3;
      }
      static [entityKind] = "MySqlColumn";
    };
    MySqlColumnBuilderWithAutoIncrement = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlColumnBuilderWithAutoIncrement");
      }
      static [entityKind] = "MySqlColumnBuilderWithAutoIncrement";
      constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
      }
      autoincrement() {
        this.config.autoIncrement = true;
        this.config.hasDefault = true;
        return this;
      }
    };
    MySqlColumnWithAutoIncrement = class extends MySqlColumn {
      static {
        __name(this, "MySqlColumnWithAutoIncrement");
      }
      static [entityKind] = "MySqlColumnWithAutoIncrement";
      autoIncrement = this.config.autoIncrement;
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/bigint.js
var MySqlBigInt53Builder, MySqlBigInt53, MySqlBigInt64Builder, MySqlBigInt64;
var init_bigint = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/bigint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlBigInt53Builder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlBigInt53Builder");
      }
      static [entityKind] = "MySqlBigInt53Builder";
      constructor(name, unsigned = false) {
        super(name, "number", "MySqlBigInt53");
        this.config.unsigned = unsigned;
      }
      /** @internal */
      build(table3) {
        return new MySqlBigInt53(
          table3,
          this.config
        );
      }
    };
    MySqlBigInt53 = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlBigInt53");
      }
      static [entityKind] = "MySqlBigInt53";
      getSQLType() {
        return `bigint${this.config.unsigned ? " unsigned" : ""}`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
    };
    MySqlBigInt64Builder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlBigInt64Builder");
      }
      static [entityKind] = "MySqlBigInt64Builder";
      constructor(name, unsigned = false) {
        super(name, "bigint", "MySqlBigInt64");
        this.config.unsigned = unsigned;
      }
      /** @internal */
      build(table3) {
        return new MySqlBigInt64(
          table3,
          this.config
        );
      }
    };
    MySqlBigInt64 = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlBigInt64");
      }
      static [entityKind] = "MySqlBigInt64";
      getSQLType() {
        return `bigint${this.config.unsigned ? " unsigned" : ""}`;
      }
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      mapFromDriverValue(value) {
        return BigInt(value);
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/binary.js
var MySqlBinaryBuilder, MySqlBinary;
var init_binary = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/binary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlBinaryBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlBinaryBuilder");
      }
      static [entityKind] = "MySqlBinaryBuilder";
      constructor(name, length) {
        super(name, "string", "MySqlBinary");
        this.config.length = length;
      }
      /** @internal */
      build(table3) {
        return new MySqlBinary(table3, this.config);
      }
    };
    MySqlBinary = class extends MySqlColumn {
      static {
        __name(this, "MySqlBinary");
      }
      static [entityKind] = "MySqlBinary";
      length = this.config.length;
      getSQLType() {
        return this.length === void 0 ? `binary` : `binary(${this.length})`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/boolean.js
var MySqlBooleanBuilder, MySqlBoolean;
var init_boolean = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/boolean.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlBooleanBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlBooleanBuilder");
      }
      static [entityKind] = "MySqlBooleanBuilder";
      constructor(name) {
        super(name, "boolean", "MySqlBoolean");
      }
      /** @internal */
      build(table3) {
        return new MySqlBoolean(
          table3,
          this.config
        );
      }
    };
    MySqlBoolean = class extends MySqlColumn {
      static {
        __name(this, "MySqlBoolean");
      }
      static [entityKind] = "MySqlBoolean";
      getSQLType() {
        return "boolean";
      }
      mapFromDriverValue(value) {
        if (typeof value === "boolean") {
          return value;
        }
        return value === 1;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/char.js
var MySqlCharBuilder, MySqlChar;
var init_char = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/char.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlCharBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlCharBuilder");
      }
      static [entityKind] = "MySqlCharBuilder";
      constructor(name, config2) {
        super(name, "string", "MySqlChar");
        this.config.length = config2.length;
        this.config.enum = config2.enum;
      }
      /** @internal */
      build(table3) {
        return new MySqlChar(
          table3,
          this.config
        );
      }
    };
    MySqlChar = class extends MySqlColumn {
      static {
        __name(this, "MySqlChar");
      }
      static [entityKind] = "MySqlChar";
      length = this.config.length;
      enumValues = this.config.enum;
      getSQLType() {
        return this.length === void 0 ? `char` : `char(${this.length})`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/custom.js
var MySqlCustomColumnBuilder, MySqlCustomColumn;
var init_custom2 = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/custom.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlCustomColumnBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlCustomColumnBuilder");
      }
      static [entityKind] = "MySqlCustomColumnBuilder";
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "MySqlCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table3) {
        return new MySqlCustomColumn(
          table3,
          this.config
        );
      }
    };
    MySqlCustomColumn = class extends MySqlColumn {
      static {
        __name(this, "MySqlCustomColumn");
      }
      static [entityKind] = "MySqlCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table3, config2) {
        super(table3, config2);
        this.sqlName = config2.customTypeParams.dataType(config2.fieldConfig);
        this.mapTo = config2.customTypeParams.toDriver;
        this.mapFrom = config2.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/date.js
var MySqlDateBuilder, MySqlDate, MySqlDateStringBuilder, MySqlDateString;
var init_date = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/date.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlDateBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlDateBuilder");
      }
      static [entityKind] = "MySqlDateBuilder";
      constructor(name) {
        super(name, "date", "MySqlDate");
      }
      /** @internal */
      build(table3) {
        return new MySqlDate(table3, this.config);
      }
    };
    MySqlDate = class extends MySqlColumn {
      static {
        __name(this, "MySqlDate");
      }
      static [entityKind] = "MySqlDate";
      constructor(table3, config2) {
        super(table3, config2);
      }
      getSQLType() {
        return `date`;
      }
      mapFromDriverValue(value) {
        return new Date(value);
      }
    };
    MySqlDateStringBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlDateStringBuilder");
      }
      static [entityKind] = "MySqlDateStringBuilder";
      constructor(name) {
        super(name, "string", "MySqlDateString");
      }
      /** @internal */
      build(table3) {
        return new MySqlDateString(
          table3,
          this.config
        );
      }
    };
    MySqlDateString = class extends MySqlColumn {
      static {
        __name(this, "MySqlDateString");
      }
      static [entityKind] = "MySqlDateString";
      constructor(table3, config2) {
        super(table3, config2);
      }
      getSQLType() {
        return `date`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/datetime.js
var MySqlDateTimeBuilder, MySqlDateTime, MySqlDateTimeStringBuilder, MySqlDateTimeString;
var init_datetime = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/datetime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlDateTimeBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlDateTimeBuilder");
      }
      static [entityKind] = "MySqlDateTimeBuilder";
      constructor(name, config2) {
        super(name, "date", "MySqlDateTime");
        this.config.fsp = config2?.fsp;
      }
      /** @internal */
      build(table3) {
        return new MySqlDateTime(
          table3,
          this.config
        );
      }
    };
    MySqlDateTime = class extends MySqlColumn {
      static {
        __name(this, "MySqlDateTime");
      }
      static [entityKind] = "MySqlDateTime";
      fsp;
      constructor(table3, config2) {
        super(table3, config2);
        this.fsp = config2.fsp;
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `datetime${precision}`;
      }
      mapToDriverValue(value) {
        return value.toISOString().replace("T", " ").replace("Z", "");
      }
      mapFromDriverValue(value) {
        return /* @__PURE__ */ new Date(value.replace(" ", "T") + "Z");
      }
    };
    MySqlDateTimeStringBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlDateTimeStringBuilder");
      }
      static [entityKind] = "MySqlDateTimeStringBuilder";
      constructor(name, config2) {
        super(name, "string", "MySqlDateTimeString");
        this.config.fsp = config2?.fsp;
      }
      /** @internal */
      build(table3) {
        return new MySqlDateTimeString(
          table3,
          this.config
        );
      }
    };
    MySqlDateTimeString = class extends MySqlColumn {
      static {
        __name(this, "MySqlDateTimeString");
      }
      static [entityKind] = "MySqlDateTimeString";
      fsp;
      constructor(table3, config2) {
        super(table3, config2);
        this.fsp = config2.fsp;
      }
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `datetime${precision}`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/decimal.js
var MySqlDecimalBuilder, MySqlDecimal;
var init_decimal = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/decimal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlDecimalBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlDecimalBuilder");
      }
      static [entityKind] = "MySqlDecimalBuilder";
      constructor(name, precision, scale) {
        super(name, "string", "MySqlDecimal");
        this.config.precision = precision;
        this.config.scale = scale;
      }
      /** @internal */
      build(table3) {
        return new MySqlDecimal(
          table3,
          this.config
        );
      }
    };
    MySqlDecimal = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlDecimal");
      }
      static [entityKind] = "MySqlDecimal";
      precision = this.config.precision;
      scale = this.config.scale;
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `decimal(${this.precision},${this.scale})`;
        } else if (this.precision === void 0) {
          return "decimal";
        } else {
          return `decimal(${this.precision})`;
        }
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/double.js
var MySqlDoubleBuilder, MySqlDouble;
var init_double = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/double.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlDoubleBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlDoubleBuilder");
      }
      static [entityKind] = "MySqlDoubleBuilder";
      constructor(name, config2) {
        super(name, "number", "MySqlDouble");
        this.config.precision = config2?.precision;
        this.config.scale = config2?.scale;
      }
      /** @internal */
      build(table3) {
        return new MySqlDouble(table3, this.config);
      }
    };
    MySqlDouble = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlDouble");
      }
      static [entityKind] = "MySqlDouble";
      precision = this.config.precision;
      scale = this.config.scale;
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `double(${this.precision},${this.scale})`;
        } else if (this.precision === void 0) {
          return "double";
        } else {
          return `double(${this.precision})`;
        }
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/enum.js
var MySqlEnumColumnBuilder, MySqlEnumColumn;
var init_enum2 = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/enum.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlEnumColumnBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlEnumColumnBuilder");
      }
      static [entityKind] = "MySqlEnumColumnBuilder";
      constructor(name, values) {
        super(name, "string", "MySqlEnumColumn");
        this.config.enumValues = values;
      }
      /** @internal */
      build(table3) {
        return new MySqlEnumColumn(
          table3,
          this.config
        );
      }
    };
    MySqlEnumColumn = class extends MySqlColumn {
      static {
        __name(this, "MySqlEnumColumn");
      }
      static [entityKind] = "MySqlEnumColumn";
      enumValues = this.config.enumValues;
      getSQLType() {
        return `enum(${this.enumValues.map((value) => `'${value}'`).join(",")})`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/float.js
var MySqlFloatBuilder, MySqlFloat;
var init_float = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/float.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlFloatBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlFloatBuilder");
      }
      static [entityKind] = "MySqlFloatBuilder";
      constructor(name) {
        super(name, "number", "MySqlFloat");
      }
      /** @internal */
      build(table3) {
        return new MySqlFloat(table3, this.config);
      }
    };
    MySqlFloat = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlFloat");
      }
      static [entityKind] = "MySqlFloat";
      getSQLType() {
        return "float";
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/int.js
var MySqlIntBuilder, MySqlInt;
var init_int = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/int.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlIntBuilder");
      }
      static [entityKind] = "MySqlIntBuilder";
      constructor(name, config2) {
        super(name, "number", "MySqlInt");
        this.config.unsigned = config2 ? config2.unsigned : false;
      }
      /** @internal */
      build(table3) {
        return new MySqlInt(table3, this.config);
      }
    };
    MySqlInt = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlInt");
      }
      static [entityKind] = "MySqlInt";
      getSQLType() {
        return `int${this.config.unsigned ? " unsigned" : ""}`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/json.js
var MySqlJsonBuilder, MySqlJson;
var init_json = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/json.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlJsonBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlJsonBuilder");
      }
      static [entityKind] = "MySqlJsonBuilder";
      constructor(name) {
        super(name, "json", "MySqlJson");
      }
      /** @internal */
      build(table3) {
        return new MySqlJson(table3, this.config);
      }
    };
    MySqlJson = class extends MySqlColumn {
      static {
        __name(this, "MySqlJson");
      }
      static [entityKind] = "MySqlJson";
      getSQLType() {
        return "json";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/mediumint.js
var MySqlMediumIntBuilder, MySqlMediumInt;
var init_mediumint = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/mediumint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlMediumIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlMediumIntBuilder");
      }
      static [entityKind] = "MySqlMediumIntBuilder";
      constructor(name, config2) {
        super(name, "number", "MySqlMediumInt");
        this.config.unsigned = config2 ? config2.unsigned : false;
      }
      /** @internal */
      build(table3) {
        return new MySqlMediumInt(
          table3,
          this.config
        );
      }
    };
    MySqlMediumInt = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlMediumInt");
      }
      static [entityKind] = "MySqlMediumInt";
      getSQLType() {
        return `mediumint${this.config.unsigned ? " unsigned" : ""}`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/real.js
var MySqlRealBuilder, MySqlReal;
var init_real2 = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/real.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlRealBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlRealBuilder");
      }
      static [entityKind] = "MySqlRealBuilder";
      constructor(name, config2) {
        super(name, "number", "MySqlReal");
        this.config.precision = config2?.precision;
        this.config.scale = config2?.scale;
      }
      /** @internal */
      build(table3) {
        return new MySqlReal(table3, this.config);
      }
    };
    MySqlReal = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlReal");
      }
      static [entityKind] = "MySqlReal";
      precision = this.config.precision;
      scale = this.config.scale;
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `real(${this.precision}, ${this.scale})`;
        } else if (this.precision === void 0) {
          return "real";
        } else {
          return `real(${this.precision})`;
        }
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/serial.js
var MySqlSerialBuilder, MySqlSerial;
var init_serial = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/serial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlSerialBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlSerialBuilder");
      }
      static [entityKind] = "MySqlSerialBuilder";
      constructor(name) {
        super(name, "number", "MySqlSerial");
        this.config.hasDefault = true;
        this.config.autoIncrement = true;
      }
      /** @internal */
      build(table3) {
        return new MySqlSerial(table3, this.config);
      }
    };
    MySqlSerial = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlSerial");
      }
      static [entityKind] = "MySqlSerial";
      getSQLType() {
        return "serial";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/smallint.js
var MySqlSmallIntBuilder, MySqlSmallInt;
var init_smallint = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/smallint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlSmallIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlSmallIntBuilder");
      }
      static [entityKind] = "MySqlSmallIntBuilder";
      constructor(name, config2) {
        super(name, "number", "MySqlSmallInt");
        this.config.unsigned = config2 ? config2.unsigned : false;
      }
      /** @internal */
      build(table3) {
        return new MySqlSmallInt(
          table3,
          this.config
        );
      }
    };
    MySqlSmallInt = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlSmallInt");
      }
      static [entityKind] = "MySqlSmallInt";
      getSQLType() {
        return `smallint${this.config.unsigned ? " unsigned" : ""}`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/text.js
var MySqlTextBuilder, MySqlText;
var init_text2 = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/text.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlTextBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlTextBuilder");
      }
      static [entityKind] = "MySqlTextBuilder";
      constructor(name, textType, config2) {
        super(name, "string", "MySqlText");
        this.config.textType = textType;
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table3) {
        return new MySqlText(table3, this.config);
      }
    };
    MySqlText = class extends MySqlColumn {
      static {
        __name(this, "MySqlText");
      }
      static [entityKind] = "MySqlText";
      textType = this.config.textType;
      enumValues = this.config.enumValues;
      getSQLType() {
        return this.textType;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/time.js
var MySqlTimeBuilder, MySqlTime;
var init_time = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/time.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlTimeBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlTimeBuilder");
      }
      static [entityKind] = "MySqlTimeBuilder";
      constructor(name, config2) {
        super(name, "string", "MySqlTime");
        this.config.fsp = config2?.fsp;
      }
      /** @internal */
      build(table3) {
        return new MySqlTime(table3, this.config);
      }
    };
    MySqlTime = class extends MySqlColumn {
      static {
        __name(this, "MySqlTime");
      }
      static [entityKind] = "MySqlTime";
      fsp = this.config.fsp;
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `time${precision}`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/date.common.js
var MySqlDateColumnBaseBuilder, MySqlDateBaseColumn;
var init_date_common = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/date.common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_common3();
    MySqlDateColumnBaseBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlDateColumnBaseBuilder");
      }
      static [entityKind] = "MySqlDateColumnBuilder";
      defaultNow() {
        return this.default(sql`(now())`);
      }
      // "on update now" also adds an implicit default value to the column - https://dev.mysql.com/doc/refman/8.0/en/timestamp-initialization.html
      onUpdateNow() {
        this.config.hasOnUpdateNow = true;
        this.config.hasDefault = true;
        return this;
      }
    };
    MySqlDateBaseColumn = class extends MySqlColumn {
      static {
        __name(this, "MySqlDateBaseColumn");
      }
      static [entityKind] = "MySqlDateColumn";
      hasOnUpdateNow = this.config.hasOnUpdateNow;
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/timestamp.js
var MySqlTimestampBuilder, MySqlTimestamp, MySqlTimestampStringBuilder, MySqlTimestampString;
var init_timestamp = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/timestamp.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_date_common();
    MySqlTimestampBuilder = class extends MySqlDateColumnBaseBuilder {
      static {
        __name(this, "MySqlTimestampBuilder");
      }
      static [entityKind] = "MySqlTimestampBuilder";
      constructor(name, config2) {
        super(name, "date", "MySqlTimestamp");
        this.config.fsp = config2?.fsp;
      }
      /** @internal */
      build(table3) {
        return new MySqlTimestamp(
          table3,
          this.config
        );
      }
    };
    MySqlTimestamp = class extends MySqlDateBaseColumn {
      static {
        __name(this, "MySqlTimestamp");
      }
      static [entityKind] = "MySqlTimestamp";
      fsp = this.config.fsp;
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `timestamp${precision}`;
      }
      mapFromDriverValue(value) {
        return /* @__PURE__ */ new Date(value + "+0000");
      }
      mapToDriverValue(value) {
        return value.toISOString().slice(0, -1).replace("T", " ");
      }
    };
    MySqlTimestampStringBuilder = class extends MySqlDateColumnBaseBuilder {
      static {
        __name(this, "MySqlTimestampStringBuilder");
      }
      static [entityKind] = "MySqlTimestampStringBuilder";
      constructor(name, config2) {
        super(name, "string", "MySqlTimestampString");
        this.config.fsp = config2?.fsp;
      }
      /** @internal */
      build(table3) {
        return new MySqlTimestampString(
          table3,
          this.config
        );
      }
    };
    MySqlTimestampString = class extends MySqlDateBaseColumn {
      static {
        __name(this, "MySqlTimestampString");
      }
      static [entityKind] = "MySqlTimestampString";
      fsp = this.config.fsp;
      getSQLType() {
        const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
        return `timestamp${precision}`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/tinyint.js
var MySqlTinyIntBuilder, MySqlTinyInt;
var init_tinyint = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/tinyint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlTinyIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
      static {
        __name(this, "MySqlTinyIntBuilder");
      }
      static [entityKind] = "MySqlTinyIntBuilder";
      constructor(name, config2) {
        super(name, "number", "MySqlTinyInt");
        this.config.unsigned = config2 ? config2.unsigned : false;
      }
      /** @internal */
      build(table3) {
        return new MySqlTinyInt(
          table3,
          this.config
        );
      }
    };
    MySqlTinyInt = class extends MySqlColumnWithAutoIncrement {
      static {
        __name(this, "MySqlTinyInt");
      }
      static [entityKind] = "MySqlTinyInt";
      getSQLType() {
        return `tinyint${this.config.unsigned ? " unsigned" : ""}`;
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/varbinary.js
var MySqlVarBinaryBuilder, MySqlVarBinary;
var init_varbinary = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/varbinary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlVarBinaryBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlVarBinaryBuilder");
      }
      static [entityKind] = "MySqlVarBinaryBuilder";
      /** @internal */
      constructor(name, config2) {
        super(name, "string", "MySqlVarBinary");
        this.config.length = config2?.length;
      }
      /** @internal */
      build(table3) {
        return new MySqlVarBinary(
          table3,
          this.config
        );
      }
    };
    MySqlVarBinary = class extends MySqlColumn {
      static {
        __name(this, "MySqlVarBinary");
      }
      static [entityKind] = "MySqlVarBinary";
      length = this.config.length;
      getSQLType() {
        return this.length === void 0 ? `varbinary` : `varbinary(${this.length})`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/varchar.js
var MySqlVarCharBuilder, MySqlVarChar;
var init_varchar = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/varchar.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlVarCharBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlVarCharBuilder");
      }
      static [entityKind] = "MySqlVarCharBuilder";
      /** @internal */
      constructor(name, config2) {
        super(name, "string", "MySqlVarChar");
        this.config.length = config2.length;
        this.config.enum = config2.enum;
      }
      /** @internal */
      build(table3) {
        return new MySqlVarChar(
          table3,
          this.config
        );
      }
    };
    MySqlVarChar = class extends MySqlColumn {
      static {
        __name(this, "MySqlVarChar");
      }
      static [entityKind] = "MySqlVarChar";
      length = this.config.length;
      enumValues = this.config.enum;
      getSQLType() {
        return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/year.js
var MySqlYearBuilder, MySqlYear;
var init_year = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/year.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common3();
    MySqlYearBuilder = class extends MySqlColumnBuilder {
      static {
        __name(this, "MySqlYearBuilder");
      }
      static [entityKind] = "MySqlYearBuilder";
      constructor(name) {
        super(name, "number", "MySqlYear");
      }
      /** @internal */
      build(table3) {
        return new MySqlYear(table3, this.config);
      }
    };
    MySqlYear = class extends MySqlColumn {
      static {
        __name(this, "MySqlYear");
      }
      static [entityKind] = "MySqlYear";
      getSQLType() {
        return `year`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/columns/index.js
var init_columns2 = __esm({
  "node_modules/drizzle-orm/mysql-core/columns/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_bigint();
    init_binary();
    init_boolean();
    init_char();
    init_common3();
    init_custom2();
    init_date();
    init_datetime();
    init_decimal();
    init_double();
    init_enum2();
    init_float();
    init_int();
    init_json();
    init_mediumint();
    init_real2();
    init_serial();
    init_smallint();
    init_text2();
    init_time();
    init_timestamp();
    init_tinyint();
    init_varbinary();
    init_varchar();
    init_year();
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/delete.js
var MySqlDeleteBase;
var init_delete2 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/delete.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    MySqlDeleteBase = class extends QueryPromise {
      static {
        __name(this, "MySqlDeleteBase");
      }
      constructor(table3, session, dialect, withList) {
        super();
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table3, withList };
      }
      static [entityKind] = "MySqlDelete";
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      prepare() {
        return this.session.prepareQuery(
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning
        );
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return this.prepare().execute(placeholderValues);
      }, "execute");
      createIterator = /* @__PURE__ */ __name(() => {
        const self = this;
        return async function* (placeholderValues) {
          yield* self.prepare().iterator(placeholderValues);
        };
      }, "createIterator");
      iterator = this.createIterator();
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/insert.js
var MySqlInsertBuilder, MySqlInsertBase;
var init_insert2 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/insert.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_sql();
    init_table();
    init_utils2();
    MySqlInsertBuilder = class {
      static {
        __name(this, "MySqlInsertBuilder");
      }
      constructor(table3, session, dialect) {
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
      }
      static [entityKind] = "MySqlInsertBuilder";
      shouldIgnore = false;
      ignore() {
        this.shouldIgnore = true;
        return this;
      }
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new MySqlInsertBase(this.table, mappedValues, this.shouldIgnore, this.session, this.dialect);
      }
    };
    MySqlInsertBase = class extends QueryPromise {
      static {
        __name(this, "MySqlInsertBase");
      }
      constructor(table3, values, ignore, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table3, values, ignore };
      }
      static [entityKind] = "MySqlInsert";
      config;
      /**
       * Adds an `on duplicate key update` clause to the query.
       *
       * Calling this method will update update the row if any unique index conflicts. MySQL will automatically determine the conflict target based on the primary key and unique indexes.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-duplicate-key-update}
       *
       * @param config The `set` clause
       *
       * @example
       * ```ts
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW'})
       *   .onDuplicateKeyUpdate({ set: { brand: 'Porsche' }});
       * ```
       *
       * While MySQL does not directly support doing nothing on conflict, you can perform a no-op by setting any column's value to itself and achieve the same effect:
       *
       * ```ts
       * import { sql } from 'drizzle-orm';
       *
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onDuplicateKeyUpdate({ set: { id: sql`id` } });
       * ```
       */
      onDuplicateKeyUpdate(config2) {
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
        this.config.onConflict = sql`update ${setSql}`;
        return this;
      }
      $returningId() {
        const returning = [];
        for (const [key, value] of Object.entries(this.config.table[Table.Symbol.Columns])) {
          if (value.primary) {
            returning.push({ field: value, path: [key] });
          }
        }
        this.config.returning = orderSelectedFields(this.config.table[Table.Symbol.Columns]);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config).sql;
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      prepare() {
        const { sql: sql2, generatedIds } = this.dialect.buildInsertQuery(this.config);
        return this.session.prepareQuery(
          this.dialect.sqlToQuery(sql2),
          void 0,
          void 0,
          generatedIds,
          this.config.returning
        );
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return this.prepare().execute(placeholderValues);
      }, "execute");
      createIterator = /* @__PURE__ */ __name(() => {
        const self = this;
        return async function* (placeholderValues) {
          yield* self.prepare().iterator(placeholderValues);
        };
      }, "createIterator");
      iterator = this.createIterator();
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/view-base.js
var MySqlViewBase;
var init_view_base2 = __esm({
  "node_modules/drizzle-orm/mysql-core/view-base.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    MySqlViewBase = class extends View {
      static {
        __name(this, "MySqlViewBase");
      }
      static [entityKind] = "MySqlViewBase";
    };
  }
});

// node_modules/drizzle-orm/mysql-core/dialect.js
var MySqlDialect;
var init_dialect2 = __esm({
  "node_modules/drizzle-orm/mysql-core/dialect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column();
    init_entity();
    init_errors3();
    init_expressions2();
    init_relations();
    init_sql();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
    init_common3();
    init_table4();
    init_view_base2();
    MySqlDialect = class {
      static {
        __name(this, "MySqlDialect");
      }
      static [entityKind] = "MySqlDialect";
      async migrate(migrations, session, config2) {
        const migrationsTable = config2.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			create table if not exists ${sql.identifier(migrationsTable)} (
				id serial primary key,
				hash text not null,
				created_at bigint
			)
		`;
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(
          sql`select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`
        );
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.execute(sql.raw(stmt));
              }
              await tx.execute(
                sql`insert into ${sql.identifier(migrationsTable)} (\`hash\`, \`created_at\`) values(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
      escapeName(name) {
        return `\`${name}\``;
      }
      escapeParam(_num) {
        return `?`;
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table: table3, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}delete from ${table3}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table3, set) {
        const tableColumns = table3[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i) => {
          const col = tableColumns[colName];
          const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
          const res = sql`${sql.identifier(col.name)} = ${value}`;
          if (i < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table: table3, set, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table3, set);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}update ${table3} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c2) => {
                    if (is(c2, MySqlColumn)) {
                      return sql.identifier(c2.name);
                    }
                    return c2;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            if (isSingleTable) {
              chunk.push(sql.identifier(field.name));
            } else {
              chunk.push(field);
            }
          }
          if (i < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table: table3,
        joins,
        orderBy,
        groupBy,
        limit,
        offset,
        lockingClause,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f2 of fieldsList) {
          if (is(f2.field, Column) && getTableName(f2.field.table) !== (is(table3, Subquery) ? table3._.alias : is(table3, MySqlViewBase) ? table3[ViewBaseConfig].name : is(table3, SQL) ? void 0 : getTableName(table3)) && !((table22) => joins?.some(
            ({ alias }) => alias === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
          ))(f2.field.table)) {
            const tableName = getTableName(f2.field.table);
            throw new Error(
              `Your "${f2.path.join("->")}" field references a column "${tableName}"."${f2.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table3, Table) && table3[Table.Symbol.OriginalName] !== table3[Table.Symbol.Name]) {
            return sql`${sql.identifier(table3[Table.Symbol.OriginalName])} ${sql.identifier(table3[Table.Symbol.Name])}`;
          }
          return table3;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index, joinMeta] of joins.entries()) {
            if (index === 0) {
              joinsArray.push(sql` `);
            }
            const table22 = joinMeta.table;
            const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
            if (is(table22, MySqlTable)) {
              const tableName = table22[MySqlTable.Symbol.Name];
              const tableSchema = table22[MySqlTable.Symbol.Schema];
              const origTableName = table22[MySqlTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else if (is(table22, View)) {
              const viewName = table22[ViewBaseConfig].name;
              const viewSchema = table22[ViewBaseConfig].schema;
              const origViewName = table22[ViewBaseConfig].originalName;
              const alias = viewName === origViewName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table22} on ${joinMeta.on}`
              );
            }
            if (index < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
          groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        let lockingClausesSql;
        if (lockingClause) {
          const { config: config2, strength } = lockingClause;
          lockingClausesSql = sql` for ${sql.raw(strength)}`;
          if (config2.noWait) {
            lockingClausesSql.append(sql` no wait`);
          } else if (config2.skipLocked) {
            lockingClausesSql.append(sql` skip locked`);
          }
        }
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
      }) {
        const leftChunk = sql`(${leftSelect.getSQL()}) `;
        const rightChunk = sql`(${rightSelect.getSQL()})`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const orderByUnit of orderBy) {
            if (is(orderByUnit, MySqlColumn)) {
              orderByValues.push(sql.identifier(orderByUnit.name));
            } else if (is(orderByUnit, SQL)) {
              for (let i = 0; i < orderByUnit.queryChunks.length; i++) {
                const chunk = orderByUnit.queryChunks[i];
                if (is(chunk, MySqlColumn)) {
                  orderByUnit.queryChunks[i] = sql.identifier(chunk.name);
                }
              }
              orderByValues.push(sql`${orderByUnit}`);
            } else {
              orderByValues.push(sql`${orderByUnit}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table: table3, values, ignore, onConflict }) {
        const valuesSqlList = [];
        const columns = table3[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(
          ([_, col]) => !col.shouldDisableInsert()
        );
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        const generatedIdsResponse = [];
        for (const [valueIndex, value] of values.entries()) {
          const generatedIds = {};
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                generatedIds[fieldName] = defaultFnResult;
                const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                valueList.push(defaultValue);
              } else if (!col.default && col.onUpdateFn !== void 0) {
                const onUpdateFnResult = col.onUpdateFn();
                const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
                valueList.push(newValue);
              } else {
                valueList.push(sql`default`);
              }
            } else {
              if (col.defaultFn && is(colValue, Param)) {
                generatedIds[fieldName] = colValue.value;
              }
              valueList.push(colValue);
            }
          }
          generatedIdsResponse.push(generatedIds);
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const valuesSql = sql.join(valuesSqlList);
        const ignoreSql = ignore ? sql` ignore` : void 0;
        const onConflictSql = onConflict ? sql` on duplicate key ${onConflict}` : void 0;
        return {
          sql: sql`insert${ignoreSql} into ${table3} ${insertOrder} values ${valuesSql}${onConflictSql}`,
          generatedIds: generatedIdsResponse
        };
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          invokeSource
        });
      }
      buildRelationalQuery({
        fullSchema,
        schema,
        tableNamesMap,
        table: table3,
        tableConfig,
        queryConfig: config2,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy, where;
        const joins = [];
        if (config2 === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config2.where) {
            const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config2.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config2.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config2.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config2.with) {
            selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config2.extras) {
            extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config2.limit;
          offset = config2.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i) => eq(
                  aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
            joins.push({
              on: sql`true`,
              table: new Subquery(builtRelation.sql, {}, relationTableAlias),
              alias: relationTableAlias,
              joinType: "left",
              lateral: true
            });
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_arrayagg(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || (orderBy?.length ?? 0) > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table3, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                },
                ...(orderBy?.length ?? 0) > 0 ? [{
                  path: [],
                  field: sql`row_number() over (order by ${sql.join(orderBy, sql`, `)})`
                }] : []
              ],
              where,
              limit,
              offset,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table3, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table3, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
      buildRelationalQueryWithoutLateralSubqueries({
        fullSchema,
        schema,
        tableNamesMap,
        table: table3,
        tableConfig,
        queryConfig: config2,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        if (config2 === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config2.where) {
            const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config2.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config2.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config2.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config2.with) {
            selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config2.extras) {
            extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config2.limit;
          offset = config2.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i) => eq(
                  aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQueryWithoutLateralSubqueries({
              fullSchema,
              schema,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            let fieldSql = sql`(${builtRelation.sql})`;
            if (is(relation, Many)) {
              fieldSql = sql`coalesce(${fieldSql}, json_array())`;
            }
            const field = fieldSql.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({
            message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
          });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2 }) => is(field2, MySqlColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`json_arrayagg(${field})`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field,
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table3, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                },
                ...orderBy.length > 0 ? [{
                  path: [],
                  field: sql`row_number() over (order by ${sql.join(orderBy, sql`, `)})`
                }] : []
              ],
              where,
              limit,
              offset,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table3, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table3, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/select.js
function createSetOperator2(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var MySqlSelectBuilder, MySqlSelectQueryBuilderBase, MySqlSelectBase, getMySqlSetOperators, union2, unionAll2, intersect2, intersectAll, except2, exceptAll;
var init_select3 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/select.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_builder();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_utils2();
    init_utils2();
    init_view_common();
    init_view_base2();
    MySqlSelectBuilder = class {
      static {
        __name(this, "MySqlSelectBuilder");
      }
      static [entityKind] = "MySqlSelectBuilder";
      fields;
      session;
      dialect;
      withList = [];
      distinct;
      constructor(config2) {
        this.fields = config2.fields;
        this.session = config2.session;
        this.dialect = config2.dialect;
        if (config2.withList) {
          this.withList = config2.withList;
        }
        this.distinct = config2.distinct;
      }
      from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source._.selectedFields).map((key) => [key, source[key]])
          );
        } else if (is(source, MySqlViewBase)) {
          fields = source[ViewBaseConfig].selectedFields;
        } else if (is(source, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source);
        }
        return new MySqlSelectBase(
          {
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct
          }
        );
      }
    };
    MySqlSelectQueryBuilderBase = class extends TypedQueryBuilder {
      static {
        __name(this, "MySqlSelectQueryBuilderBase");
      }
      static [entityKind] = "MySqlSelectQueryBuilder";
      _;
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      /** @internal */
      session;
      dialect;
      constructor({ table: table3, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table: table3,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table3);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table3, on2) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table3);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table3, SQL)) {
              const selection = is(table3, Subquery) ? table3._.selectedFields : is(table3, View) ? table3[ViewBaseConfig].selectedFields : table3[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on2 === "function") {
            on2 = on2(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on: on2, table: table3, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getMySqlSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/mysql-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/mysql-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/mysql-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `intersect all` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets including all duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
       *
       * @example
       *
       * ```ts
       * // Select all products and quantities that are ordered by both regular and VIP customers
       * await db.select({
       *   productId: regularCustomerOrders.productId,
       *   quantityOrdered: regularCustomerOrders.quantityOrdered
       * })
       * .from(regularCustomerOrders)
       * .intersectAll(
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * // or
       * import { intersectAll } from 'drizzle-orm/mysql-core'
       *
       * await intersectAll(
       *   db.select({
       *     productId: regularCustomerOrders.productId,
       *     quantityOrdered: regularCustomerOrders.quantityOrdered
       *   })
       *   .from(regularCustomerOrders),
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * ```
       */
      intersectAll = this.createSetOperator("intersect", true);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/mysql-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /**
       * Adds `except all` set operator to the query.
       *
       * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
       *
       * @example
       *
       * ```ts
       * // Select all products that are ordered by regular customers but not by VIP customers
       * await db.select({
       *   productId: regularCustomerOrders.productId,
       *   quantityOrdered: regularCustomerOrders.quantityOrdered,
       * })
       * .from(regularCustomerOrders)
       * .exceptAll(
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered,
       *   })
       *   .from(vipCustomerOrders)
       * );
       * // or
       * import { exceptAll } from 'drizzle-orm/mysql-core'
       *
       * await exceptAll(
       *   db.select({
       *     productId: regularCustomerOrders.productId,
       *     quantityOrdered: regularCustomerOrders.quantityOrdered
       *   })
       *   .from(regularCustomerOrders),
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * ```
       */
      exceptAll = this.createSetOperator("except", true);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset;
        } else {
          this.config.offset = offset;
        }
        return this;
      }
      /**
       * Adds a `for` clause to the query.
       *
       * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
       *
       * See docs: {@link https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html}
       *
       * @param strength the lock strength.
       * @param config the lock configuration.
       */
      for(strength, config2 = {}) {
        this.config.lockingClause = { strength, config: config2 };
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    MySqlSelectBase = class extends MySqlSelectQueryBuilderBase {
      static {
        __name(this, "MySqlSelectBase");
      }
      static [entityKind] = "MySqlSelect";
      prepare() {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), fieldsList);
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return this.prepare().execute(placeholderValues);
      }, "execute");
      createIterator = /* @__PURE__ */ __name(() => {
        const self = this;
        return async function* (placeholderValues) {
          yield* self.prepare().iterator(placeholderValues);
        };
      }, "createIterator");
      iterator = this.createIterator();
    };
    applyMixins(MySqlSelectBase, [QueryPromise]);
    __name(createSetOperator2, "createSetOperator");
    getMySqlSetOperators = /* @__PURE__ */ __name(() => ({
      union: union2,
      unionAll: unionAll2,
      intersect: intersect2,
      intersectAll,
      except: except2,
      exceptAll
    }), "getMySqlSetOperators");
    union2 = createSetOperator2("union", false);
    unionAll2 = createSetOperator2("union", true);
    intersect2 = createSetOperator2("intersect", false);
    intersectAll = createSetOperator2("intersect", true);
    except2 = createSetOperator2("except", false);
    exceptAll = createSetOperator2("except", true);
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/query-builder.js
var QueryBuilder2;
var init_query_builder3 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/query-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_dialect2();
    init_selection_proxy();
    init_subquery();
    init_select3();
    QueryBuilder2 = class {
      static {
        __name(this, "QueryBuilder");
      }
      static [entityKind] = "MySqlQueryBuilder";
      dialect;
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(queryBuilder);
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        return { select, selectDistinct };
      }
      select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new MySqlSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new MySqlDialect();
        }
        return this.dialect;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/select.types.js
var init_select_types2 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/select.types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/update.js
var MySqlUpdateBuilder, MySqlUpdateBase;
var init_update2 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/update.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_utils2();
    MySqlUpdateBuilder = class {
      static {
        __name(this, "MySqlUpdateBuilder");
      }
      constructor(table3, session, dialect, withList) {
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "MySqlUpdateBuilder";
      set(values) {
        return new MySqlUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList);
      }
    };
    MySqlUpdateBase = class extends QueryPromise {
      static {
        __name(this, "MySqlUpdateBase");
      }
      constructor(table3, set, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table: table3, withList };
      }
      static [entityKind] = "MySqlUpdate";
      config;
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      prepare() {
        return this.session.prepareQuery(
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning
        );
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return this.prepare().execute(placeholderValues);
      }, "execute");
      createIterator = /* @__PURE__ */ __name(() => {
        const self = this;
        return async function* (placeholderValues) {
          yield* self.prepare().iterator(placeholderValues);
        };
      }, "createIterator");
      iterator = this.createIterator();
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/index.js
var init_query_builders2 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_delete2();
    init_insert2();
    init_query_builder3();
    init_select3();
    init_select_types2();
    init_update2();
  }
});

// node_modules/drizzle-orm/mysql-core/query-builders/query.js
var RelationalQueryBuilder2, MySqlRelationalQuery;
var init_query2 = __esm({
  "node_modules/drizzle-orm/mysql-core/query-builders/query.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_relations();
    RelationalQueryBuilder2 = class {
      static {
        __name(this, "RelationalQueryBuilder");
      }
      constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session, mode) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table3;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.mode = mode;
      }
      static [entityKind] = "MySqlRelationalQueryBuilder";
      findMany(config2) {
        return new MySqlRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? config2 : {},
          "many",
          this.mode
        );
      }
      findFirst(config2) {
        return new MySqlRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? { ...config2, limit: 1 } : { limit: 1 },
          "first",
          this.mode
        );
      }
    };
    MySqlRelationalQuery = class extends QueryPromise {
      static {
        __name(this, "MySqlRelationalQuery");
      }
      constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session, config2, queryMode, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table3;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config2;
        this.queryMode = queryMode;
        this.mode = mode;
      }
      static [entityKind] = "MySqlRelationalQuery";
      prepare() {
        const { query, builtQuery } = this._toSQL();
        return this.session.prepareQuery(
          builtQuery,
          void 0,
          (rawRows) => {
            const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection));
            if (this.queryMode === "first") {
              return rows[0];
            }
            return rows;
          }
        );
      }
      _getQuery() {
        const query = this.mode === "planetscale" ? this.dialect.buildRelationalQueryWithoutLateralSubqueries({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }) : this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        return query;
      }
      _toSQL() {
        const query = this._getQuery();
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { builtQuery, query };
      }
      /** @internal */
      getSQL() {
        return this._getQuery().sql;
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      execute() {
        return this.prepare().execute();
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/db.js
var MySqlDatabase;
var init_db2 = __esm({
  "node_modules/drizzle-orm/mysql-core/db.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_subquery();
    init_query_builders2();
    init_query2();
    MySqlDatabase = class {
      static {
        __name(this, "MySqlDatabase");
      }
      constructor(dialect, session, schema, mode) {
        this.dialect = dialect;
        this.session = session;
        this.mode = mode;
        this._ = schema ? {
          schema: schema.schema,
          fullSchema: schema.fullSchema,
          tableNamesMap: schema.tableNamesMap
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {}
        };
        this.query = {};
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            this.query[tableName] = new RelationalQueryBuilder2(
              schema.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema.fullSchema[tableName],
              columns,
              dialect,
              session,
              this.mode
            );
          }
        }
      }
      static [entityKind] = "MySqlDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with(alias) {
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(new QueryBuilder2());
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new MySqlSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function update(table3) {
          return new MySqlUpdateBuilder(table3, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function delete_(table3) {
          return new MySqlDeleteBase(table3, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select, selectDistinct, update, delete: delete_ };
      }
      select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new MySqlSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       * ```
       */
      update(table3) {
        return new MySqlUpdateBuilder(table3, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       * ```
       */
      insert(table3) {
        return new MySqlInsertBuilder(table3, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       * ```
       */
      delete(table3) {
        return new MySqlDeleteBase(table3, this.session, this.dialect);
      }
      execute(query) {
        return this.session.execute(query.getSQL());
      }
      transaction(transaction, config2) {
        return this.session.transaction(transaction, config2);
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/indexes.js
var IndexBuilderOn2, IndexBuilder2, Index2;
var init_indexes2 = __esm({
  "node_modules/drizzle-orm/mysql-core/indexes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    IndexBuilderOn2 = class {
      static {
        __name(this, "IndexBuilderOn");
      }
      constructor(name, unique) {
        this.name = name;
        this.unique = unique;
      }
      static [entityKind] = "MySqlIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder2(this.name, columns, this.unique);
      }
    };
    IndexBuilder2 = class {
      static {
        __name(this, "IndexBuilder");
      }
      static [entityKind] = "MySqlIndexBuilder";
      /** @internal */
      config;
      constructor(name, columns, unique) {
        this.config = {
          name,
          columns,
          unique
        };
      }
      using(using) {
        this.config.using = using;
        return this;
      }
      algorythm(algorythm) {
        this.config.algorythm = algorythm;
        return this;
      }
      lock(lock) {
        this.config.lock = lock;
        return this;
      }
      /** @internal */
      build(table3) {
        return new Index2(this.config, table3);
      }
    };
    Index2 = class {
      static {
        __name(this, "Index");
      }
      static [entityKind] = "MySqlIndex";
      config;
      constructor(config2, table3) {
        this.config = { ...config2, table: table3 };
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/primary-keys.js
var PrimaryKeyBuilder3, PrimaryKey3;
var init_primary_keys3 = __esm({
  "node_modules/drizzle-orm/mysql-core/primary-keys.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table4();
    PrimaryKeyBuilder3 = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "MySqlPrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table3) {
        return new PrimaryKey3(table3, this.columns, this.name);
      }
    };
    PrimaryKey3 = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table3, columns, name) {
        this.table = table3;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "MySqlPrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[MySqlTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/view-common.js
var MySqlViewConfig;
var init_view_common3 = __esm({
  "node_modules/drizzle-orm/mysql-core/view-common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    MySqlViewConfig = Symbol.for("drizzle:MySqlViewConfig");
  }
});

// node_modules/drizzle-orm/mysql-core/view.js
function mysqlViewWithSchema(name, selection, schema) {
  if (selection) {
    return new ManualViewBuilder2(name, selection, schema);
  }
  return new ViewBuilder2(name, schema);
}
var ViewBuilderCore2, ViewBuilder2, ManualViewBuilder2, MySqlView;
var init_view2 = __esm({
  "node_modules/drizzle-orm/mysql-core/view.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_utils2();
    init_query_builder3();
    init_table4();
    init_view_base2();
    init_view_common3();
    ViewBuilderCore2 = class {
      static {
        __name(this, "ViewBuilderCore");
      }
      constructor(name, schema) {
        this.name = name;
        this.schema = schema;
      }
      static [entityKind] = "MySqlViewBuilder";
      config = {};
      algorithm(algorithm) {
        this.config.algorithm = algorithm;
        return this;
      }
      definer(definer) {
        this.config.definer = definer;
        return this;
      }
      sqlSecurity(sqlSecurity) {
        this.config.sqlSecurity = sqlSecurity;
        return this;
      }
      withCheckOption(withCheckOption) {
        this.config.withCheckOption = withCheckOption ?? "cascaded";
        return this;
      }
    };
    ViewBuilder2 = class extends ViewBuilderCore2 {
      static {
        __name(this, "ViewBuilder");
      }
      static [entityKind] = "MySqlViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder2());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(
          new MySqlView({
            mysqlConfig: this.config,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: aliasedSelection,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualViewBuilder2 = class extends ViewBuilderCore2 {
      static {
        __name(this, "ManualViewBuilder");
      }
      static [entityKind] = "MySqlManualViewBuilder";
      columns;
      constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(mysqlTable(name, columns));
      }
      existing() {
        return new Proxy(
          new MySqlView({
            mysqlConfig: void 0,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new MySqlView({
            mysqlConfig: this.config,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    MySqlView = class extends MySqlViewBase {
      static {
        __name(this, "MySqlView");
      }
      static [entityKind] = "MySqlView";
      [MySqlViewConfig];
      constructor({ mysqlConfig, config: config2 }) {
        super(config2);
        this[MySqlViewConfig] = mysqlConfig;
      }
    };
    __name(mysqlViewWithSchema, "mysqlViewWithSchema");
  }
});

// node_modules/drizzle-orm/mysql-core/schema.js
var MySqlSchema;
var init_schema = __esm({
  "node_modules/drizzle-orm/mysql-core/schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_table4();
    init_view2();
    MySqlSchema = class {
      static {
        __name(this, "MySqlSchema");
      }
      constructor(schemaName) {
        this.schemaName = schemaName;
      }
      static [entityKind] = "MySqlSchema";
      table = /* @__PURE__ */ __name((name, columns, extraConfig) => {
        return mysqlTableWithSchema(name, columns, extraConfig, this.schemaName);
      }, "table");
      view = /* @__PURE__ */ __name((name, columns) => {
        return mysqlViewWithSchema(name, columns, this.schemaName);
      }, "view");
    };
  }
});

// node_modules/drizzle-orm/mysql-core/session.js
var MySqlPreparedQuery, MySqlSession, MySqlTransaction;
var init_session3 = __esm({
  "node_modules/drizzle-orm/mysql-core/session.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_errors3();
    init_sql();
    init_db2();
    MySqlPreparedQuery = class {
      static {
        __name(this, "MySqlPreparedQuery");
      }
      static [entityKind] = "MySqlPreparedQuery";
      /** @internal */
      joinsNotNullableMap;
    };
    MySqlSession = class {
      static {
        __name(this, "MySqlSession");
      }
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "MySqlSession";
      execute(query) {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0
        ).execute();
      }
      getSetTransactionSQL(config2) {
        const parts = [];
        if (config2.isolationLevel) {
          parts.push(`isolation level ${config2.isolationLevel}`);
        }
        return parts.length ? sql`set transaction ${sql.raw(parts.join(" "))}` : void 0;
      }
      getStartTransactionSQL(config2) {
        const parts = [];
        if (config2.withConsistentSnapshot) {
          parts.push("with consistent snapshot");
        }
        if (config2.accessMode) {
          parts.push(config2.accessMode);
        }
        return parts.length ? sql`start transaction ${sql.raw(parts.join(" "))}` : void 0;
      }
    };
    MySqlTransaction = class extends MySqlDatabase {
      static {
        __name(this, "MySqlTransaction");
      }
      constructor(dialect, session, schema, nestedIndex, mode) {
        super(dialect, session, schema, mode);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "MySqlTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
    };
  }
});

// node_modules/drizzle-orm/mysql-core/subquery.js
var init_subquery3 = __esm({
  "node_modules/drizzle-orm/mysql-core/subquery.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/mysql-core/utils.js
var init_utils4 = __esm({
  "node_modules/drizzle-orm/mysql-core/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/mysql-core/index.js
var init_mysql_core = __esm({
  "node_modules/drizzle-orm/mysql-core/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias3();
    init_checks2();
    init_columns2();
    init_db2();
    init_dialect2();
    init_foreign_keys3();
    init_indexes2();
    init_primary_keys3();
    init_query_builders2();
    init_schema();
    init_session3();
    init_subquery3();
    init_table4();
    init_unique_constraint3();
    init_utils4();
    init_view_common3();
    init_view2();
  }
});

// node_modules/drizzle-orm/pg-core/alias.js
var init_alias4 = __esm({
  "node_modules/drizzle-orm/pg-core/alias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/pg-core/checks.js
var CheckBuilder3, Check3;
var init_checks3 = __esm({
  "node_modules/drizzle-orm/pg-core/checks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    CheckBuilder3 = class {
      static {
        __name(this, "CheckBuilder");
      }
      constructor(name, value) {
        this.name = name;
        this.value = value;
      }
      static [entityKind] = "PgCheckBuilder";
      brand;
      /** @internal */
      build(table3) {
        return new Check3(table3, this);
      }
    };
    Check3 = class {
      static {
        __name(this, "Check");
      }
      constructor(table3, builder) {
        this.table = table3;
        this.name = builder.name;
        this.value = builder.value;
      }
      static [entityKind] = "PgCheck";
      name;
      value;
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/int.common.js
var PgIntColumnBaseBuilder;
var init_int_common = __esm({
  "node_modules/drizzle-orm/pg-core/columns/int.common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgIntColumnBaseBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgIntColumnBaseBuilder");
      }
      static [entityKind] = "PgIntColumnBaseBuilder";
      generatedAlwaysAsIdentity(sequence) {
        if (sequence) {
          const { name, ...options } = sequence;
          this.config.generatedIdentity = {
            type: "always",
            sequenceName: name,
            sequenceOptions: options
          };
        } else {
          this.config.generatedIdentity = {
            type: "always"
          };
        }
        this.config.hasDefault = true;
        this.config.notNull = true;
        return this;
      }
      generatedByDefaultAsIdentity(sequence) {
        if (sequence) {
          const { name, ...options } = sequence;
          this.config.generatedIdentity = {
            type: "byDefault",
            sequenceName: name,
            sequenceOptions: options
          };
        } else {
          this.config.generatedIdentity = {
            type: "byDefault"
          };
        }
        this.config.hasDefault = true;
        this.config.notNull = true;
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/bigint.js
var PgBigInt53Builder, PgBigInt53, PgBigInt64Builder, PgBigInt64;
var init_bigint2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/bigint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_int_common();
    PgBigInt53Builder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgBigInt53Builder");
      }
      static [entityKind] = "PgBigInt53Builder";
      constructor(name) {
        super(name, "number", "PgBigInt53");
      }
      /** @internal */
      build(table3) {
        return new PgBigInt53(table3, this.config);
      }
    };
    PgBigInt53 = class extends PgColumn {
      static {
        __name(this, "PgBigInt53");
      }
      static [entityKind] = "PgBigInt53";
      getSQLType() {
        return "bigint";
      }
      mapFromDriverValue(value) {
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
    };
    PgBigInt64Builder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgBigInt64Builder");
      }
      static [entityKind] = "PgBigInt64Builder";
      constructor(name) {
        super(name, "bigint", "PgBigInt64");
      }
      /** @internal */
      build(table3) {
        return new PgBigInt64(
          table3,
          this.config
        );
      }
    };
    PgBigInt64 = class extends PgColumn {
      static {
        __name(this, "PgBigInt64");
      }
      static [entityKind] = "PgBigInt64";
      getSQLType() {
        return "bigint";
      }
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      mapFromDriverValue(value) {
        return BigInt(value);
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/bigserial.js
var PgBigSerial53Builder, PgBigSerial53, PgBigSerial64Builder, PgBigSerial64;
var init_bigserial = __esm({
  "node_modules/drizzle-orm/pg-core/columns/bigserial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgBigSerial53Builder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBigSerial53Builder");
      }
      static [entityKind] = "PgBigSerial53Builder";
      constructor(name) {
        super(name, "number", "PgBigSerial53");
        this.config.hasDefault = true;
        this.config.notNull = true;
      }
      /** @internal */
      build(table3) {
        return new PgBigSerial53(
          table3,
          this.config
        );
      }
    };
    PgBigSerial53 = class extends PgColumn {
      static {
        __name(this, "PgBigSerial53");
      }
      static [entityKind] = "PgBigSerial53";
      getSQLType() {
        return "bigserial";
      }
      mapFromDriverValue(value) {
        if (typeof value === "number") {
          return value;
        }
        return Number(value);
      }
    };
    PgBigSerial64Builder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBigSerial64Builder");
      }
      static [entityKind] = "PgBigSerial64Builder";
      constructor(name) {
        super(name, "bigint", "PgBigSerial64");
        this.config.hasDefault = true;
      }
      /** @internal */
      build(table3) {
        return new PgBigSerial64(
          table3,
          this.config
        );
      }
    };
    PgBigSerial64 = class extends PgColumn {
      static {
        __name(this, "PgBigSerial64");
      }
      static [entityKind] = "PgBigSerial64";
      getSQLType() {
        return "bigserial";
      }
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      mapFromDriverValue(value) {
        return BigInt(value);
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/boolean.js
var PgBooleanBuilder, PgBoolean;
var init_boolean2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/boolean.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgBooleanBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBooleanBuilder");
      }
      static [entityKind] = "PgBooleanBuilder";
      constructor(name) {
        super(name, "boolean", "PgBoolean");
      }
      /** @internal */
      build(table3) {
        return new PgBoolean(table3, this.config);
      }
    };
    PgBoolean = class extends PgColumn {
      static {
        __name(this, "PgBoolean");
      }
      static [entityKind] = "PgBoolean";
      getSQLType() {
        return "boolean";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/char.js
var PgCharBuilder, PgChar;
var init_char2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/char.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgCharBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgCharBuilder");
      }
      static [entityKind] = "PgCharBuilder";
      constructor(name, config2) {
        super(name, "string", "PgChar");
        this.config.length = config2.length;
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table3) {
        return new PgChar(table3, this.config);
      }
    };
    PgChar = class extends PgColumn {
      static {
        __name(this, "PgChar");
      }
      static [entityKind] = "PgChar";
      length = this.config.length;
      enumValues = this.config.enumValues;
      getSQLType() {
        return this.length === void 0 ? `char` : `char(${this.length})`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/cidr.js
var PgCidrBuilder, PgCidr;
var init_cidr = __esm({
  "node_modules/drizzle-orm/pg-core/columns/cidr.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgCidrBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgCidrBuilder");
      }
      static [entityKind] = "PgCidrBuilder";
      constructor(name) {
        super(name, "string", "PgCidr");
      }
      /** @internal */
      build(table3) {
        return new PgCidr(table3, this.config);
      }
    };
    PgCidr = class extends PgColumn {
      static {
        __name(this, "PgCidr");
      }
      static [entityKind] = "PgCidr";
      getSQLType() {
        return "cidr";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/custom.js
var PgCustomColumnBuilder, PgCustomColumn;
var init_custom3 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/custom.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgCustomColumnBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgCustomColumnBuilder");
      }
      static [entityKind] = "PgCustomColumnBuilder";
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "PgCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table3) {
        return new PgCustomColumn(
          table3,
          this.config
        );
      }
    };
    PgCustomColumn = class extends PgColumn {
      static {
        __name(this, "PgCustomColumn");
      }
      static [entityKind] = "PgCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table3, config2) {
        super(table3, config2);
        this.sqlName = config2.customTypeParams.dataType(config2.fieldConfig);
        this.mapTo = config2.customTypeParams.toDriver;
        this.mapFrom = config2.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/date.common.js
var PgDateColumnBaseBuilder;
var init_date_common2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/date.common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_common();
    PgDateColumnBaseBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgDateColumnBaseBuilder");
      }
      static [entityKind] = "PgDateColumnBaseBuilder";
      defaultNow() {
        return this.default(sql`now()`);
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/date.js
var PgDateBuilder, PgDate, PgDateStringBuilder, PgDateString;
var init_date2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/date.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_date_common2();
    PgDateBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgDateBuilder");
      }
      static [entityKind] = "PgDateBuilder";
      constructor(name) {
        super(name, "date", "PgDate");
      }
      /** @internal */
      build(table3) {
        return new PgDate(table3, this.config);
      }
    };
    PgDate = class extends PgColumn {
      static {
        __name(this, "PgDate");
      }
      static [entityKind] = "PgDate";
      getSQLType() {
        return "date";
      }
      mapFromDriverValue(value) {
        return new Date(value);
      }
      mapToDriverValue(value) {
        return value.toISOString();
      }
    };
    PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgDateStringBuilder");
      }
      static [entityKind] = "PgDateStringBuilder";
      constructor(name) {
        super(name, "string", "PgDateString");
      }
      /** @internal */
      build(table3) {
        return new PgDateString(
          table3,
          this.config
        );
      }
    };
    PgDateString = class extends PgColumn {
      static {
        __name(this, "PgDateString");
      }
      static [entityKind] = "PgDateString";
      getSQLType() {
        return "date";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/double-precision.js
var PgDoublePrecisionBuilder, PgDoublePrecision;
var init_double_precision = __esm({
  "node_modules/drizzle-orm/pg-core/columns/double-precision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgDoublePrecisionBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgDoublePrecisionBuilder");
      }
      static [entityKind] = "PgDoublePrecisionBuilder";
      constructor(name) {
        super(name, "number", "PgDoublePrecision");
      }
      /** @internal */
      build(table3) {
        return new PgDoublePrecision(
          table3,
          this.config
        );
      }
    };
    PgDoublePrecision = class extends PgColumn {
      static {
        __name(this, "PgDoublePrecision");
      }
      static [entityKind] = "PgDoublePrecision";
      getSQLType() {
        return "double precision";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number.parseFloat(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/inet.js
var PgInetBuilder, PgInet;
var init_inet = __esm({
  "node_modules/drizzle-orm/pg-core/columns/inet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgInetBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgInetBuilder");
      }
      static [entityKind] = "PgInetBuilder";
      constructor(name) {
        super(name, "string", "PgInet");
      }
      /** @internal */
      build(table3) {
        return new PgInet(table3, this.config);
      }
    };
    PgInet = class extends PgColumn {
      static {
        __name(this, "PgInet");
      }
      static [entityKind] = "PgInet";
      getSQLType() {
        return "inet";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/integer.js
var PgIntegerBuilder, PgInteger;
var init_integer2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/integer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_int_common();
    PgIntegerBuilder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgIntegerBuilder");
      }
      static [entityKind] = "PgIntegerBuilder";
      constructor(name) {
        super(name, "number", "PgInteger");
      }
      /** @internal */
      build(table3) {
        return new PgInteger(table3, this.config);
      }
    };
    PgInteger = class extends PgColumn {
      static {
        __name(this, "PgInteger");
      }
      static [entityKind] = "PgInteger";
      getSQLType() {
        return "integer";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          return Number.parseInt(value);
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/interval.js
var PgIntervalBuilder, PgInterval;
var init_interval = __esm({
  "node_modules/drizzle-orm/pg-core/columns/interval.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgIntervalBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgIntervalBuilder");
      }
      static [entityKind] = "PgIntervalBuilder";
      constructor(name, intervalConfig) {
        super(name, "string", "PgInterval");
        this.config.intervalConfig = intervalConfig;
      }
      /** @internal */
      build(table3) {
        return new PgInterval(table3, this.config);
      }
    };
    PgInterval = class extends PgColumn {
      static {
        __name(this, "PgInterval");
      }
      static [entityKind] = "PgInterval";
      fields = this.config.intervalConfig.fields;
      precision = this.config.intervalConfig.precision;
      getSQLType() {
        const fields = this.fields ? ` ${this.fields}` : "";
        const precision = this.precision ? `(${this.precision})` : "";
        return `interval${fields}${precision}`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/json.js
var PgJsonBuilder, PgJson;
var init_json2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/json.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgJsonBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgJsonBuilder");
      }
      static [entityKind] = "PgJsonBuilder";
      constructor(name) {
        super(name, "json", "PgJson");
      }
      /** @internal */
      build(table3) {
        return new PgJson(table3, this.config);
      }
    };
    PgJson = class extends PgColumn {
      static {
        __name(this, "PgJson");
      }
      static [entityKind] = "PgJson";
      constructor(table3, config2) {
        super(table3, config2);
      }
      getSQLType() {
        return "json";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch {
            return value;
          }
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
var PgJsonbBuilder, PgJsonb;
var init_jsonb = __esm({
  "node_modules/drizzle-orm/pg-core/columns/jsonb.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgJsonbBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgJsonbBuilder");
      }
      static [entityKind] = "PgJsonbBuilder";
      constructor(name) {
        super(name, "json", "PgJsonb");
      }
      /** @internal */
      build(table3) {
        return new PgJsonb(table3, this.config);
      }
    };
    PgJsonb = class extends PgColumn {
      static {
        __name(this, "PgJsonb");
      }
      static [entityKind] = "PgJsonb";
      constructor(table3, config2) {
        super(table3, config2);
      }
      getSQLType() {
        return "jsonb";
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch {
            return value;
          }
        }
        return value;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/line.js
var PgLineBuilder, PgLineTuple, PgLineABCBuilder, PgLineABC;
var init_line = __esm({
  "node_modules/drizzle-orm/pg-core/columns/line.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgLineBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgLineBuilder");
      }
      static [entityKind] = "PgLineBuilder";
      constructor(name) {
        super(name, "array", "PgLine");
      }
      /** @internal */
      build(table3) {
        return new PgLineTuple(
          table3,
          this.config
        );
      }
    };
    PgLineTuple = class extends PgColumn {
      static {
        __name(this, "PgLineTuple");
      }
      static [entityKind] = "PgLine";
      getSQLType() {
        return "line";
      }
      mapFromDriverValue(value) {
        const [a, b2, c2] = value.slice(1, -1).split(",");
        return [Number.parseFloat(a), Number.parseFloat(b2), Number.parseFloat(c2)];
      }
      mapToDriverValue(value) {
        return `{${value[0]},${value[1]},${value[2]}}`;
      }
    };
    PgLineABCBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgLineABCBuilder");
      }
      static [entityKind] = "PgLineABCBuilder";
      constructor(name) {
        super(name, "json", "PgLineABC");
      }
      /** @internal */
      build(table3) {
        return new PgLineABC(
          table3,
          this.config
        );
      }
    };
    PgLineABC = class extends PgColumn {
      static {
        __name(this, "PgLineABC");
      }
      static [entityKind] = "PgLineABC";
      getSQLType() {
        return "line";
      }
      mapFromDriverValue(value) {
        const [a, b2, c2] = value.slice(1, -1).split(",");
        return { a: Number.parseFloat(a), b: Number.parseFloat(b2), c: Number.parseFloat(c2) };
      }
      mapToDriverValue(value) {
        return `{${value.a},${value.b},${value.c}}`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/macaddr.js
var PgMacaddrBuilder, PgMacaddr;
var init_macaddr = __esm({
  "node_modules/drizzle-orm/pg-core/columns/macaddr.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgMacaddrBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgMacaddrBuilder");
      }
      static [entityKind] = "PgMacaddrBuilder";
      constructor(name) {
        super(name, "string", "PgMacaddr");
      }
      /** @internal */
      build(table3) {
        return new PgMacaddr(table3, this.config);
      }
    };
    PgMacaddr = class extends PgColumn {
      static {
        __name(this, "PgMacaddr");
      }
      static [entityKind] = "PgMacaddr";
      getSQLType() {
        return "macaddr";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/macaddr8.js
var PgMacaddr8Builder, PgMacaddr8;
var init_macaddr8 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/macaddr8.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgMacaddr8Builder = class extends PgColumnBuilder {
      static {
        __name(this, "PgMacaddr8Builder");
      }
      static [entityKind] = "PgMacaddr8Builder";
      constructor(name) {
        super(name, "string", "PgMacaddr8");
      }
      /** @internal */
      build(table3) {
        return new PgMacaddr8(table3, this.config);
      }
    };
    PgMacaddr8 = class extends PgColumn {
      static {
        __name(this, "PgMacaddr8");
      }
      static [entityKind] = "PgMacaddr8";
      getSQLType() {
        return "macaddr8";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/numeric.js
var PgNumericBuilder, PgNumeric;
var init_numeric2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/numeric.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgNumericBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgNumericBuilder");
      }
      static [entityKind] = "PgNumericBuilder";
      constructor(name, precision, scale) {
        super(name, "string", "PgNumeric");
        this.config.precision = precision;
        this.config.scale = scale;
      }
      /** @internal */
      build(table3) {
        return new PgNumeric(table3, this.config);
      }
    };
    PgNumeric = class extends PgColumn {
      static {
        __name(this, "PgNumeric");
      }
      static [entityKind] = "PgNumeric";
      precision;
      scale;
      constructor(table3, config2) {
        super(table3, config2);
        this.precision = config2.precision;
        this.scale = config2.scale;
      }
      getSQLType() {
        if (this.precision !== void 0 && this.scale !== void 0) {
          return `numeric(${this.precision}, ${this.scale})`;
        } else if (this.precision === void 0) {
          return "numeric";
        } else {
          return `numeric(${this.precision})`;
        }
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/point.js
var PgPointTupleBuilder, PgPointTuple, PgPointObjectBuilder, PgPointObject;
var init_point = __esm({
  "node_modules/drizzle-orm/pg-core/columns/point.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgPointTupleBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgPointTupleBuilder");
      }
      static [entityKind] = "PgPointTupleBuilder";
      constructor(name) {
        super(name, "array", "PgPointTuple");
      }
      /** @internal */
      build(table3) {
        return new PgPointTuple(
          table3,
          this.config
        );
      }
    };
    PgPointTuple = class extends PgColumn {
      static {
        __name(this, "PgPointTuple");
      }
      static [entityKind] = "PgPointTuple";
      getSQLType() {
        return "point";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          const [x, y] = value.slice(1, -1).split(",");
          return [Number.parseFloat(x), Number.parseFloat(y)];
        }
        return [value.x, value.y];
      }
      mapToDriverValue(value) {
        return `(${value[0]},${value[1]})`;
      }
    };
    PgPointObjectBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgPointObjectBuilder");
      }
      static [entityKind] = "PgPointObjectBuilder";
      constructor(name) {
        super(name, "json", "PgPointObject");
      }
      /** @internal */
      build(table3) {
        return new PgPointObject(
          table3,
          this.config
        );
      }
    };
    PgPointObject = class extends PgColumn {
      static {
        __name(this, "PgPointObject");
      }
      static [entityKind] = "PgPointObject";
      getSQLType() {
        return "point";
      }
      mapFromDriverValue(value) {
        if (typeof value === "string") {
          const [x, y] = value.slice(1, -1).split(",");
          return { x: Number.parseFloat(x), y: Number.parseFloat(y) };
        }
        return value;
      }
      mapToDriverValue(value) {
        return `(${value.x},${value.y})`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c2 = 0; c2 < hex.length; c2 += 2) {
    bytes.push(Number.parseInt(hex.slice(c2, c2 + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0; i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x, y];
  }
  throw new Error("Unsupported geometry type");
}
var init_utils5 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(hexToBytes, "hexToBytes");
    __name(bytesToFloat64, "bytesToFloat64");
    __name(parseEWKB, "parseEWKB");
  }
});

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
var PgGeometryBuilder, PgGeometry, PgGeometryObjectBuilder, PgGeometryObject;
var init_geometry = __esm({
  "node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_utils5();
    PgGeometryBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgGeometryBuilder");
      }
      static [entityKind] = "PgGeometryBuilder";
      constructor(name) {
        super(name, "array", "PgGeometry");
      }
      /** @internal */
      build(table3) {
        return new PgGeometry(
          table3,
          this.config
        );
      }
    };
    PgGeometry = class extends PgColumn {
      static {
        __name(this, "PgGeometry");
      }
      static [entityKind] = "PgGeometry";
      getSQLType() {
        return "geometry(point)";
      }
      mapFromDriverValue(value) {
        return parseEWKB(value);
      }
      mapToDriverValue(value) {
        return `point(${value[0]} ${value[1]})`;
      }
    };
    PgGeometryObjectBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgGeometryObjectBuilder");
      }
      static [entityKind] = "PgGeometryObjectBuilder";
      constructor(name) {
        super(name, "json", "PgGeometryObject");
      }
      /** @internal */
      build(table3) {
        return new PgGeometryObject(
          table3,
          this.config
        );
      }
    };
    PgGeometryObject = class extends PgColumn {
      static {
        __name(this, "PgGeometryObject");
      }
      static [entityKind] = "PgGeometryObject";
      getSQLType() {
        return "geometry(point)";
      }
      mapFromDriverValue(value) {
        const parsed = parseEWKB(value);
        return { x: parsed[0], y: parsed[1] };
      }
      mapToDriverValue(value) {
        return `point(${value.x} ${value.y})`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/real.js
var PgRealBuilder, PgReal;
var init_real3 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/real.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgRealBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgRealBuilder");
      }
      static [entityKind] = "PgRealBuilder";
      constructor(name, length) {
        super(name, "number", "PgReal");
        this.config.length = length;
      }
      /** @internal */
      build(table3) {
        return new PgReal(table3, this.config);
      }
    };
    PgReal = class extends PgColumn {
      static {
        __name(this, "PgReal");
      }
      static [entityKind] = "PgReal";
      constructor(table3, config2) {
        super(table3, config2);
      }
      getSQLType() {
        return "real";
      }
      mapFromDriverValue = /* @__PURE__ */ __name((value) => {
        if (typeof value === "string") {
          return Number.parseFloat(value);
        }
        return value;
      }, "mapFromDriverValue");
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/serial.js
var PgSerialBuilder, PgSerial;
var init_serial2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/serial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgSerialBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgSerialBuilder");
      }
      static [entityKind] = "PgSerialBuilder";
      constructor(name) {
        super(name, "number", "PgSerial");
        this.config.hasDefault = true;
        this.config.notNull = true;
      }
      /** @internal */
      build(table3) {
        return new PgSerial(table3, this.config);
      }
    };
    PgSerial = class extends PgColumn {
      static {
        __name(this, "PgSerial");
      }
      static [entityKind] = "PgSerial";
      getSQLType() {
        return "serial";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/smallint.js
var PgSmallIntBuilder, PgSmallInt;
var init_smallint2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/smallint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_int_common();
    PgSmallIntBuilder = class extends PgIntColumnBaseBuilder {
      static {
        __name(this, "PgSmallIntBuilder");
      }
      static [entityKind] = "PgSmallIntBuilder";
      constructor(name) {
        super(name, "number", "PgSmallInt");
      }
      /** @internal */
      build(table3) {
        return new PgSmallInt(table3, this.config);
      }
    };
    PgSmallInt = class extends PgColumn {
      static {
        __name(this, "PgSmallInt");
      }
      static [entityKind] = "PgSmallInt";
      getSQLType() {
        return "smallint";
      }
      mapFromDriverValue = /* @__PURE__ */ __name((value) => {
        if (typeof value === "string") {
          return Number(value);
        }
        return value;
      }, "mapFromDriverValue");
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/smallserial.js
var PgSmallSerialBuilder, PgSmallSerial;
var init_smallserial = __esm({
  "node_modules/drizzle-orm/pg-core/columns/smallserial.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgSmallSerialBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgSmallSerialBuilder");
      }
      static [entityKind] = "PgSmallSerialBuilder";
      constructor(name) {
        super(name, "number", "PgSmallSerial");
        this.config.hasDefault = true;
        this.config.notNull = true;
      }
      /** @internal */
      build(table3) {
        return new PgSmallSerial(
          table3,
          this.config
        );
      }
    };
    PgSmallSerial = class extends PgColumn {
      static {
        __name(this, "PgSmallSerial");
      }
      static [entityKind] = "PgSmallSerial";
      getSQLType() {
        return "smallserial";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/text.js
var PgTextBuilder, PgText;
var init_text3 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/text.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgTextBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgTextBuilder");
      }
      static [entityKind] = "PgTextBuilder";
      constructor(name, config2) {
        super(name, "string", "PgText");
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table3) {
        return new PgText(table3, this.config);
      }
    };
    PgText = class extends PgColumn {
      static {
        __name(this, "PgText");
      }
      static [entityKind] = "PgText";
      enumValues = this.config.enumValues;
      getSQLType() {
        return "text";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/time.js
var PgTimeBuilder, PgTime;
var init_time2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/time.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_date_common2();
    PgTimeBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgTimeBuilder");
      }
      constructor(name, withTimezone, precision) {
        super(name, "string", "PgTime");
        this.withTimezone = withTimezone;
        this.precision = precision;
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      static [entityKind] = "PgTimeBuilder";
      /** @internal */
      build(table3) {
        return new PgTime(table3, this.config);
      }
    };
    PgTime = class extends PgColumn {
      static {
        __name(this, "PgTime");
      }
      static [entityKind] = "PgTime";
      withTimezone;
      precision;
      constructor(table3, config2) {
        super(table3, config2);
        this.withTimezone = config2.withTimezone;
        this.precision = config2.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : `(${this.precision})`;
        return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
var PgTimestampBuilder, PgTimestamp, PgTimestampStringBuilder, PgTimestampString;
var init_timestamp2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/timestamp.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    init_date_common2();
    PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgTimestampBuilder");
      }
      static [entityKind] = "PgTimestampBuilder";
      constructor(name, withTimezone, precision) {
        super(name, "date", "PgTimestamp");
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table3) {
        return new PgTimestamp(table3, this.config);
      }
    };
    PgTimestamp = class extends PgColumn {
      static {
        __name(this, "PgTimestamp");
      }
      static [entityKind] = "PgTimestamp";
      withTimezone;
      precision;
      constructor(table3, config2) {
        super(table3, config2);
        this.withTimezone = config2.withTimezone;
        this.precision = config2.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
      mapFromDriverValue = /* @__PURE__ */ __name((value) => {
        return new Date(this.withTimezone ? value : value + "+0000");
      }, "mapFromDriverValue");
      mapToDriverValue = /* @__PURE__ */ __name((value) => {
        return value.toISOString();
      }, "mapToDriverValue");
    };
    PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
      static {
        __name(this, "PgTimestampStringBuilder");
      }
      static [entityKind] = "PgTimestampStringBuilder";
      constructor(name, withTimezone, precision) {
        super(name, "string", "PgTimestampString");
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
      }
      /** @internal */
      build(table3) {
        return new PgTimestampString(
          table3,
          this.config
        );
      }
    };
    PgTimestampString = class extends PgColumn {
      static {
        __name(this, "PgTimestampString");
      }
      static [entityKind] = "PgTimestampString";
      withTimezone;
      precision;
      constructor(table3, config2) {
        super(table3, config2);
        this.withTimezone = config2.withTimezone;
        this.precision = config2.precision;
      }
      getSQLType() {
        const precision = this.precision === void 0 ? "" : `(${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/uuid.js
var PgUUIDBuilder, PgUUID;
var init_uuid = __esm({
  "node_modules/drizzle-orm/pg-core/columns/uuid.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_common();
    PgUUIDBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgUUIDBuilder");
      }
      static [entityKind] = "PgUUIDBuilder";
      constructor(name) {
        super(name, "string", "PgUUID");
      }
      /**
       * Adds `default gen_random_uuid()` to the column definition.
       */
      defaultRandom() {
        return this.default(sql`gen_random_uuid()`);
      }
      /** @internal */
      build(table3) {
        return new PgUUID(table3, this.config);
      }
    };
    PgUUID = class extends PgColumn {
      static {
        __name(this, "PgUUID");
      }
      static [entityKind] = "PgUUID";
      getSQLType() {
        return "uuid";
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/varchar.js
var PgVarcharBuilder, PgVarchar;
var init_varchar2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/varchar.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgVarcharBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgVarcharBuilder");
      }
      static [entityKind] = "PgVarcharBuilder";
      constructor(name, config2) {
        super(name, "string", "PgVarchar");
        this.config.length = config2.length;
        this.config.enumValues = config2.enum;
      }
      /** @internal */
      build(table3) {
        return new PgVarchar(table3, this.config);
      }
    };
    PgVarchar = class extends PgColumn {
      static {
        __name(this, "PgVarchar");
      }
      static [entityKind] = "PgVarchar";
      length = this.config.length;
      enumValues = this.config.enumValues;
      getSQLType() {
        return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
var PgBinaryVectorBuilder, PgBinaryVector;
var init_bit = __esm({
  "node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgBinaryVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgBinaryVectorBuilder");
      }
      static [entityKind] = "PgBinaryVectorBuilder";
      constructor(name, config2) {
        super(name, "string", "PgBinaryVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table3) {
        return new PgBinaryVector(
          table3,
          this.config
        );
      }
    };
    PgBinaryVector = class extends PgColumn {
      static {
        __name(this, "PgBinaryVector");
      }
      static [entityKind] = "PgBinaryVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `bit(${this.dimensions})`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
var PgHalfVectorBuilder, PgHalfVector;
var init_halfvec = __esm({
  "node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgHalfVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgHalfVectorBuilder");
      }
      static [entityKind] = "PgHalfVectorBuilder";
      constructor(name, config2) {
        super(name, "array", "PgHalfVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table3) {
        return new PgHalfVector(
          table3,
          this.config
        );
      }
    };
    PgHalfVector = class extends PgColumn {
      static {
        __name(this, "PgHalfVector");
      }
      static [entityKind] = "PgHalfVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `halfvec(${this.dimensions})`;
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
var PgSparseVectorBuilder, PgSparseVector;
var init_sparsevec = __esm({
  "node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgSparseVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgSparseVectorBuilder");
      }
      static [entityKind] = "PgSparseVectorBuilder";
      constructor(name, config2) {
        super(name, "string", "PgSparseVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table3) {
        return new PgSparseVector(
          table3,
          this.config
        );
      }
    };
    PgSparseVector = class extends PgColumn {
      static {
        __name(this, "PgSparseVector");
      }
      static [entityKind] = "PgSparseVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `sparsevec(${this.dimensions})`;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
var PgVectorBuilder, PgVector;
var init_vector2 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_common();
    PgVectorBuilder = class extends PgColumnBuilder {
      static {
        __name(this, "PgVectorBuilder");
      }
      static [entityKind] = "PgVectorBuilder";
      constructor(name, config2) {
        super(name, "array", "PgVector");
        this.config.dimensions = config2.dimensions;
      }
      /** @internal */
      build(table3) {
        return new PgVector(table3, this.config);
      }
    };
    PgVector = class extends PgColumn {
      static {
        __name(this, "PgVector");
      }
      static [entityKind] = "PgVector";
      dimensions = this.config.dimensions;
      getSQLType() {
        return `vector(${this.dimensions})`;
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
      mapFromDriverValue(value) {
        return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/columns/index.js
var init_columns3 = __esm({
  "node_modules/drizzle-orm/pg-core/columns/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_bigint2();
    init_bigserial();
    init_boolean2();
    init_char2();
    init_cidr();
    init_common();
    init_custom3();
    init_date2();
    init_double_precision();
    init_enum();
    init_inet();
    init_integer2();
    init_interval();
    init_json2();
    init_jsonb();
    init_line();
    init_macaddr();
    init_macaddr8();
    init_numeric2();
    init_point();
    init_geometry();
    init_real3();
    init_serial2();
    init_smallint2();
    init_smallserial();
    init_text3();
    init_time2();
    init_timestamp2();
    init_uuid();
    init_varchar2();
    init_bit();
    init_halfvec();
    init_sparsevec();
    init_vector2();
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
var PgDeleteBase;
var init_delete3 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/delete.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_table();
    init_tracing();
    init_utils2();
    PgDeleteBase = class extends QueryPromise {
      static {
        __name(this, "PgDeleteBase");
      }
      constructor(table3, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table3, withList };
      }
      static [entityKind] = "PgDelete";
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * await db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues);
        });
      }, "execute");
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
var PgInsertBuilder, PgInsertBase;
var init_insert3 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/insert.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_sql();
    init_table();
    init_tracing();
    init_utils2();
    PgInsertBuilder = class {
      static {
        __name(this, "PgInsertBuilder");
      }
      constructor(table3, session, dialect, withList) {
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "PgInsertBuilder";
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
      }
    };
    PgInsertBase = class extends QueryPromise {
      static {
        __name(this, "PgInsertBase");
      }
      constructor(table3, values, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table3, values, withList };
      }
      static [entityKind] = "PgInsert";
      config;
      returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config2 = {}) {
        if (config2.target === void 0) {
          this.config.onConflict = sql`do nothing`;
        } else {
          let targetColumn = "";
          targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config2.target.name);
          const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
          this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     targetWhere: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config2) {
        if (config2.where && (config2.targetWhere || config2.setWhere)) {
          throw new Error(
            'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
          );
        }
        const whereSql = config2.where ? sql` where ${config2.where}` : void 0;
        const targetWhereSql = config2.targetWhere ? sql` where ${config2.targetWhere}` : void 0;
        const setWhereSql = config2.setWhere ? sql` where ${config2.setWhere}` : void 0;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config2.set));
        let targetColumn = "";
        targetColumn = Array.isArray(config2.target) ? config2.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config2.target.name);
        this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues);
        });
      }, "execute");
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/view-base.js
var PgViewBase;
var init_view_base3 = __esm({
  "node_modules/drizzle-orm/pg-core/view-base.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    PgViewBase = class extends View {
      static {
        __name(this, "PgViewBase");
      }
      static [entityKind] = "PgViewBase";
    };
  }
});

// node_modules/drizzle-orm/pg-core/dialect.js
var PgDialect;
var init_dialect3 = __esm({
  "node_modules/drizzle-orm/pg-core/dialect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias();
    init_column();
    init_entity();
    init_errors3();
    init_columns3();
    init_table2();
    init_relations();
    init_sql2();
    init_sql();
    init_subquery();
    init_table();
    init_utils2();
    init_view_common();
    init_view_base3();
    PgDialect = class {
      static {
        __name(this, "PgDialect");
      }
      static [entityKind] = "PgDialect";
      async migrate(migrations, session, config2) {
        const migrationsTable = typeof config2 === "string" ? "__drizzle_migrations" : config2.migrationsTable ?? "__drizzle_migrations";
        const migrationsSchema = typeof config2 === "string" ? "drizzle" : config2.migrationsSchema ?? "drizzle";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
        await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(
          sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`
        );
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
          for await (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.execute(sql.raw(stmt));
              }
              await tx.execute(
                sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
      escapeName(name) {
        return `"${name}"`;
      }
      escapeParam(num) {
        return `$${num + 1}`;
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length)
          return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table: table3, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}delete from ${table3}${whereSql}${returningSql}`;
      }
      buildUpdateSet(table3, set) {
        const tableColumns = table3[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i) => {
          const col = tableColumns[colName];
          const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
          const res = sql`${sql.identifier(col.name)} = ${value}`;
          if (i < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table: table3, set, where, returning, withList }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table3, set);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        return sql`${withSql}update ${table3} set ${setSql}${whereSql}${returningSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c2) => {
                    if (is(c2, PgColumn)) {
                      return sql.identifier(c2.name);
                    }
                    return c2;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            if (isSingleTable) {
              chunk.push(sql.identifier(field.name));
            } else {
              chunk.push(field);
            }
          }
          if (i < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table: table3,
        joins,
        orderBy,
        groupBy,
        limit,
        offset,
        lockingClause,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f2 of fieldsList) {
          if (is(f2.field, Column) && getTableName(f2.field.table) !== (is(table3, Subquery) ? table3._.alias : is(table3, PgViewBase) ? table3[ViewBaseConfig].name : is(table3, SQL) ? void 0 : getTableName(table3)) && !((table22) => joins?.some(
            ({ alias }) => alias === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
          ))(f2.field.table)) {
            const tableName = getTableName(f2.field.table);
            throw new Error(
              `Your "${f2.path.join("->")}" field references a column "${tableName}"."${f2.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        let distinctSql;
        if (distinct) {
          distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
        }
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
          if (is(table3, Table) && table3[Table.Symbol.OriginalName] !== table3[Table.Symbol.Name]) {
            let fullName = sql`${sql.identifier(table3[Table.Symbol.OriginalName])}`;
            if (table3[Table.Symbol.Schema]) {
              fullName = sql`${sql.identifier(table3[Table.Symbol.Schema])}.${fullName}`;
            }
            return sql`${fullName} ${sql.identifier(table3[Table.Symbol.Name])}`;
          }
          return table3;
        })();
        const joinsArray = [];
        if (joins) {
          for (const [index, joinMeta] of joins.entries()) {
            if (index === 0) {
              joinsArray.push(sql` `);
            }
            const table22 = joinMeta.table;
            const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
            if (is(table22, PgTable)) {
              const tableName = table22[PgTable.Symbol.Name];
              const tableSchema = table22[PgTable.Symbol.Schema];
              const origTableName = table22[PgTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else if (is(table22, View)) {
              const viewName = table22[ViewBaseConfig].name;
              const viewSchema = table22[ViewBaseConfig].schema;
              const origViewName = table22[ViewBaseConfig].originalName;
              const alias = viewName === origViewName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table22} on ${joinMeta.on}`
              );
            }
            if (index < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
          groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        const lockingClauseSql = sql.empty();
        if (lockingClause) {
          const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
          if (lockingClause.config.of) {
            clauseSql.append(
              sql` of ${sql.join(
                Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],
                sql`, `
              )}`
            );
          }
          if (lockingClause.config.noWait) {
            clauseSql.append(sql` no wait`);
          } else if (lockingClause.config.skipLocked) {
            clauseSql.append(sql` skip locked`);
          }
          lockingClauseSql.append(clauseSql);
        }
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
      }) {
        const leftChunk = sql`(${leftSelect.getSQL()}) `;
        const rightChunk = sql`(${rightSelect.getSQL()})`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, PgColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {
                const chunk = singleOrderBy.queryChunks[i];
                if (is(chunk, PgColumn)) {
                  singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table: table3, values, onConflict, returning, withList }) {
        const valuesSqlList = [];
        const columns = table3[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
          const valueList = [];
          for (const [fieldName, col] of colEntries) {
            const colValue = value[fieldName];
            if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
              if (col.defaultFn !== void 0) {
                const defaultFnResult = col.defaultFn();
                const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                valueList.push(defaultValue);
              } else if (!col.default && col.onUpdateFn !== void 0) {
                const onUpdateFnResult = col.onUpdateFn();
                const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
                valueList.push(newValue);
              } else {
                valueList.push(sql`default`);
              }
            } else {
              valueList.push(colValue);
            }
          }
          valuesSqlList.push(valueList);
          if (valueIndex < values.length - 1) {
            valuesSqlList.push(sql`, `);
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
        return sql`${withSql}insert into ${table3} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
      }
      buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
        const concurrentlySql = concurrently ? sql` concurrently` : void 0;
        const withNoDataSql = withNoData ? sql` with no data` : void 0;
        return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
      }
      prepareTyping(encoder3) {
        if (is(encoder3, PgJsonb) || is(encoder3, PgJson)) {
          return "json";
        } else if (is(encoder3, PgNumeric)) {
          return "decimal";
        } else if (is(encoder3, PgTime)) {
          return "time";
        } else if (is(encoder3, PgTimestamp) || is(encoder3, PgTimestampString)) {
          return "timestamp";
        } else if (is(encoder3, PgDate) || is(encoder3, PgDateString)) {
          return "date";
        } else if (is(encoder3, PgUUID)) {
          return "uuid";
        } else {
          return "none";
        }
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          prepareTyping: this.prepareTyping,
          invokeSource
        });
      }
      // buildRelationalQueryWithPK({
      // 	fullSchema,
      // 	schema,
      // 	tableNamesMap,
      // 	table,
      // 	tableConfig,
      // 	queryConfig: config,
      // 	tableAlias,
      // 	isRoot = false,
      // 	joinOn,
      // }: {
      // 	fullSchema: Record<string, unknown>;
      // 	schema: TablesRelationalConfig;
      // 	tableNamesMap: Record<string, string>;
      // 	table: PgTable;
      // 	tableConfig: TableRelationalConfig;
      // 	queryConfig: true | DBQueryConfig<'many', true>;
      // 	tableAlias: string;
      // 	isRoot?: boolean;
      // 	joinOn?: SQL;
      // }): BuildRelationalQueryResult<PgTable, PgColumn> {
      // 	// For { "<relation>": true }, return a table with selection of all columns
      // 	if (config === true) {
      // 		const selectionEntries = Object.entries(tableConfig.columns);
      // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
      // 			[key, value],
      // 		) => ({
      // 			dbKey: value.name,
      // 			tsKey: key,
      // 			field: value as PgColumn,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 		return {
      // 			tableTsKey: tableConfig.tsName,
      // 			sql: table,
      // 			selection,
      // 		};
      // 	}
      // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
      // 	// let selectionForBuild = selection;
      // 	const aliasedColumns = Object.fromEntries(
      // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
      // 	);
      // 	const aliasedRelations = Object.fromEntries(
      // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
      // 	);
      // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
      // 	let where, hasUserDefinedWhere;
      // 	if (config.where) {
      // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
      // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      // 		hasUserDefinedWhere = !!where;
      // 	}
      // 	where = and(joinOn, where);
      // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
      // 	let joins: Join[] = [];
      // 	let selectedColumns: string[] = [];
      // 	// Figure out which columns to select
      // 	if (config.columns) {
      // 		let isIncludeMode = false;
      // 		for (const [field, value] of Object.entries(config.columns)) {
      // 			if (value === undefined) {
      // 				continue;
      // 			}
      // 			if (field in tableConfig.columns) {
      // 				if (!isIncludeMode && value === true) {
      // 					isIncludeMode = true;
      // 				}
      // 				selectedColumns.push(field);
      // 			}
      // 		}
      // 		if (selectedColumns.length > 0) {
      // 			selectedColumns = isIncludeMode
      // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
      // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
      // 		}
      // 	} else {
      // 		// Select all columns if selection is not specified
      // 		selectedColumns = Object.keys(tableConfig.columns);
      // 	}
      // 	// for (const field of selectedColumns) {
      // 	// 	const column = tableConfig.columns[field]! as PgColumn;
      // 	// 	fieldsSelection.push({ tsKey: field, value: column });
      // 	// }
      // 	let initiallySelectedRelations: {
      // 		tsKey: string;
      // 		queryConfig: true | DBQueryConfig<'many', false>;
      // 		relation: Relation;
      // 	}[] = [];
      // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
      // 	// Figure out which relations to select
      // 	if (config.with) {
      // 		initiallySelectedRelations = Object.entries(config.with)
      // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
      // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
      // 	}
      // 	const manyRelations = initiallySelectedRelations.filter((r) =>
      // 		is(r.relation, Many)
      // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
      // 	);
      // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
      // 	const isInnermostQuery = manyRelations.length < 2;
      // 	const selectedExtras: {
      // 		tsKey: string;
      // 		value: SQL.Aliased;
      // 	}[] = [];
      // 	// Figure out which extras to select
      // 	if (isInnermostQuery && config.extras) {
      // 		const extras = typeof config.extras === 'function'
      // 			? config.extras(aliasedFields, { sql })
      // 			: config.extras;
      // 		for (const [tsKey, value] of Object.entries(extras)) {
      // 			selectedExtras.push({
      // 				tsKey,
      // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
      // 			});
      // 		}
      // 	}
      // 	// Transform `fieldsSelection` into `selection`
      // 	// `fieldsSelection` shouldn't be used after this point
      // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
      // 	// 	selection.push({
      // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
      // 	// 		tsKey,
      // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
      // 	// 		relationTableTsKey: undefined,
      // 	// 		isJson: false,
      // 	// 		isExtra,
      // 	// 		selection: [],
      // 	// 	});
      // 	// }
      // 	let orderByOrig = typeof config.orderBy === 'function'
      // 		? config.orderBy(aliasedFields, orderByOperators)
      // 		: config.orderBy ?? [];
      // 	if (!Array.isArray(orderByOrig)) {
      // 		orderByOrig = [orderByOrig];
      // 	}
      // 	const orderBy = orderByOrig.map((orderByValue) => {
      // 		if (is(orderByValue, Column)) {
      // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
      // 		}
      // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      // 	});
      // 	const limit = isInnermostQuery ? config.limit : undefined;
      // 	const offset = isInnermostQuery ? config.offset : undefined;
      // 	// For non-root queries without additional config except columns, return a table with selection
      // 	if (
      // 		!isRoot
      // 		&& initiallySelectedRelations.length === 0
      // 		&& selectedExtras.length === 0
      // 		&& !where
      // 		&& orderBy.length === 0
      // 		&& limit === undefined
      // 		&& offset === undefined
      // 	) {
      // 		return {
      // 			tableTsKey: tableConfig.tsName,
      // 			sql: table,
      // 			selection: selectedColumns.map((key) => ({
      // 				dbKey: tableConfig.columns[key]!.name,
      // 				tsKey: key,
      // 				field: tableConfig.columns[key] as PgColumn,
      // 				relationTableTsKey: undefined,
      // 				isJson: false,
      // 				selection: [],
      // 			})),
      // 		};
      // 	}
      // 	const selectedRelationsWithoutPK:
      // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
      // 	for (
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationConfigValue,
      // 			relation,
      // 		} of initiallySelectedRelations
      // 	) {
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTable = schema[relationTableTsName]!;
      // 		if (relationTable.primaryKey.length > 0) {
      // 			continue;
      // 		}
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelation = this.buildRelationalQueryWithoutPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationConfigValue,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 			nestedQueryRelation: relation,
      // 		});
      // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
      // 		joins.push({
      // 			on: sql`true`,
      // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: true,
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelation.selection,
      // 		});
      // 	}
      // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
      // 		is(r.relation, One)
      // 	);
      // 	// Process all One relations with PKs, because they can all be joined on the same level
      // 	for (
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationConfigValue,
      // 			relation,
      // 		} of oneRelations
      // 	) {
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const relationTable = schema[relationTableTsName]!;
      // 		if (relationTable.primaryKey.length === 0) {
      // 			continue;
      // 		}
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelation = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationConfigValue,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 		});
      // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
      // 			sql.join(
      // 				builtRelation.selection.map(({ field }) =>
      // 					is(field, SQL.Aliased)
      // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
      // 						: is(field, Column)
      // 						? aliasedTableColumn(field, relationTableAlias)
      // 						: field
      // 				),
      // 				sql`, `,
      // 			)
      // 		}) end`.as(selectedRelationTsKey);
      // 		const isLateralJoin = is(builtRelation.sql, SQL);
      // 		joins.push({
      // 			on: isLateralJoin ? sql`true` : joinOn,
      // 			table: is(builtRelation.sql, SQL)
      // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
      // 				: aliasedTable(builtRelation.sql, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: is(builtRelation.sql, SQL),
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelation.selection,
      // 		});
      // 	}
      // 	let distinct: PgSelectConfig['distinct'];
      // 	let tableFrom: PgTable | Subquery = table;
      // 	// Process first Many relation - each one requires a nested subquery
      // 	const manyRelation = manyRelations[0];
      // 	if (manyRelation) {
      // 		const {
      // 			tsKey: selectedRelationTsKey,
      // 			queryConfig: selectedRelationQueryConfig,
      // 			relation,
      // 		} = manyRelation;
      // 		distinct = {
      // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
      // 		};
      // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
      // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
      // 		const relationTableTsName = tableNamesMap[relationTableName]!;
      // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
      // 		const joinOn = and(
      // 			...normalizedRelation.fields.map((field, i) =>
      // 				eq(
      // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
      // 					aliasedTableColumn(field, tableAlias),
      // 				)
      // 			),
      // 		);
      // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table: fullSchema[relationTableTsName] as PgTable,
      // 			tableConfig: schema[relationTableTsName]!,
      // 			queryConfig: selectedRelationQueryConfig,
      // 			tableAlias: relationTableAlias,
      // 			joinOn,
      // 		});
      // 		const builtRelationSelectionField = sql`case when ${
      // 			sql.identifier(relationTableAlias)
      // 		} is null then '[]' else json_agg(json_build_array(${
      // 			sql.join(
      // 				builtRelationJoin.selection.map(({ field }) =>
      // 					is(field, SQL.Aliased)
      // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
      // 						: is(field, Column)
      // 						? aliasedTableColumn(field, relationTableAlias)
      // 						: field
      // 				),
      // 				sql`, `,
      // 			)
      // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
      // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
      // 		joins.push({
      // 			on: isLateralJoin ? sql`true` : joinOn,
      // 			table: isLateralJoin
      // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
      // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
      // 			alias: relationTableAlias,
      // 			joinType: 'left',
      // 			lateral: isLateralJoin,
      // 		});
      // 		// Build the "from" subquery with the remaining Many relations
      // 		const builtTableFrom = this.buildRelationalQueryWithPK({
      // 			fullSchema,
      // 			schema,
      // 			tableNamesMap,
      // 			table,
      // 			tableConfig,
      // 			queryConfig: {
      // 				...config,
      // 				where: undefined,
      // 				orderBy: undefined,
      // 				limit: undefined,
      // 				offset: undefined,
      // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
      // 					(result, { tsKey, queryConfig: configValue }) => {
      // 						result[tsKey] = configValue;
      // 						return result;
      // 					},
      // 					{},
      // 				),
      // 			},
      // 			tableAlias,
      // 		});
      // 		selectedRelations.push({
      // 			dbKey: selectedRelationTsKey,
      // 			tsKey: selectedRelationTsKey,
      // 			field: builtRelationSelectionField,
      // 			relationTableTsKey: relationTableTsName,
      // 			isJson: true,
      // 			selection: builtRelationJoin.selection,
      // 		});
      // 		// selection = builtTableFrom.selection.map((item) =>
      // 		// 	is(item.field, SQL.Aliased)
      // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
      // 		// 		: item
      // 		// );
      // 		// selectionForBuild = [{
      // 		// 	dbKey: '*',
      // 		// 	tsKey: '*',
      // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
      // 		// 	selection: [],
      // 		// 	isJson: false,
      // 		// 	relationTableTsKey: undefined,
      // 		// }];
      // 		// const newSelectionItem: (typeof selection)[number] = {
      // 		// 	dbKey: selectedRelationTsKey,
      // 		// 	tsKey: selectedRelationTsKey,
      // 		// 	field,
      // 		// 	relationTableTsKey: relationTableTsName,
      // 		// 	isJson: true,
      // 		// 	selection: builtRelationJoin.selection,
      // 		// };
      // 		// selection.push(newSelectionItem);
      // 		// selectionForBuild.push(newSelectionItem);
      // 		tableFrom = is(builtTableFrom.sql, PgTable)
      // 			? builtTableFrom.sql
      // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
      // 	}
      // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
      // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
      // 	}
      // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
      // 	function prepareSelectedColumns() {
      // 		return selectedColumns.map((key) => ({
      // 			dbKey: tableConfig.columns[key]!.name,
      // 			tsKey: key,
      // 			field: tableConfig.columns[key] as PgColumn,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 	}
      // 	function prepareSelectedExtras() {
      // 		return selectedExtras.map((item) => ({
      // 			dbKey: item.value.fieldAlias,
      // 			tsKey: item.tsKey,
      // 			field: item.value,
      // 			relationTableTsKey: undefined,
      // 			isJson: false,
      // 			selection: [],
      // 		}));
      // 	}
      // 	if (isRoot) {
      // 		selection = [
      // 			...prepareSelectedColumns(),
      // 			...prepareSelectedExtras(),
      // 		];
      // 	}
      // 	if (hasUserDefinedWhere || orderBy.length > 0) {
      // 		tableFrom = new Subquery(
      // 			this.buildSelectQuery({
      // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
      // 				fields: {},
      // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
      // 					path: [],
      // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
      // 				})),
      // 				joins,
      // 				distinct,
      // 			}),
      // 			{},
      // 			tableAlias,
      // 		);
      // 		selectionForBuild = selection.map((item) =>
      // 			is(item.field, SQL.Aliased)
      // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
      // 				: item
      // 		);
      // 		joins = [];
      // 		distinct = undefined;
      // 	}
      // 	const result = this.buildSelectQuery({
      // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
      // 		fields: {},
      // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
      // 			path: [],
      // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
      // 		})),
      // 		where,
      // 		limit,
      // 		offset,
      // 		joins,
      // 		orderBy,
      // 		distinct,
      // 	});
      // 	return {
      // 		tableTsKey: tableConfig.tsName,
      // 		sql: result,
      // 		selection,
      // 	};
      // }
      buildRelationalQueryWithoutPK({
        fullSchema,
        schema,
        tableNamesMap,
        table: table3,
        tableConfig,
        queryConfig: config2,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config2 === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config2.where) {
            const whereSql = typeof config2.where === "function" ? config2.where(aliasedColumns, getOperators()) : config2.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config2.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config2.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config2.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config2.with) {
            selectedRelations = Object.entries(config2.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config2.extras) {
            extras = typeof config2.extras === "function" ? config2.extras(aliasedColumns, { sql }) : config2.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config2.orderBy === "function" ? config2.orderBy(aliasedColumns, getOrderByOperators()) : config2.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config2.limit;
          offset = config2.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i) => eq(
                  aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQueryWithoutPK({
              fullSchema,
              schema,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
            joins.push({
              on: sql`true`,
              table: new Subquery(builtRelation.sql, {}, relationTableAlias),
              alias: relationTableAlias,
              joinType: "left",
              lateral: true
            });
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_build_array(${sql.join(
            selection.map(
              ({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table3, tableAlias),
              fields: {},
              fieldsFlat: [{
                path: [],
                field: sql.raw("*")
              }],
              where,
              limit,
              offset,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = [];
          } else {
            result = aliasedTable(table3, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table3, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/select.js
function createSetOperator3(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var PgSelectBuilder, PgSelectQueryBuilderBase, PgSelectBase, getPgSetOperators, union3, unionAll3, intersect3, intersectAll2, except3, exceptAll2;
var init_select4 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/select.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_view_base3();
    init_query_builder();
    init_query_promise();
    init_selection_proxy();
    init_sql();
    init_subquery();
    init_table();
    init_tracing();
    init_utils2();
    init_utils2();
    init_view_common();
    PgSelectBuilder = class {
      static {
        __name(this, "PgSelectBuilder");
      }
      static [entityKind] = "PgSelectBuilder";
      fields;
      session;
      dialect;
      withList = [];
      distinct;
      constructor(config2) {
        this.fields = config2.fields;
        this.session = config2.session;
        this.dialect = config2.dialect;
        if (config2.withList) {
          this.withList = config2.withList;
        }
        this.distinct = config2.distinct;
      }
      /**
       * Specify the table, subquery, or other target that you're
       * building a select query against.
       *
       * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}
       */
      from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source._.selectedFields).map((key) => [key, source[key]])
          );
        } else if (is(source, PgViewBase)) {
          fields = source[ViewBaseConfig].selectedFields;
        } else if (is(source, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source);
        }
        return new PgSelectBase({
          table: source,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    PgSelectQueryBuilderBase = class extends TypedQueryBuilder {
      static {
        __name(this, "PgSelectQueryBuilderBase");
      }
      static [entityKind] = "PgSelectQueryBuilder";
      _;
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      constructor({ table: table3, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table: table3,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields
        };
        this.tableName = getTableLikeName(table3);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
      }
      createJoin(joinType) {
        return (table3, on2) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table3);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table3, SQL)) {
              const selection = is(table3, Subquery) ? table3._.selectedFields : is(table3, View) ? table3[ViewBaseConfig].selectedFields : table3[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on2 === "function") {
            on2 = on2(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on: on2, table: table3, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/pg-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/pg-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/pg-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `intersect all` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets including all duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}
       *
       * @example
       *
       * ```ts
       * // Select all products and quantities that are ordered by both regular and VIP customers
       * await db.select({
       *   productId: regularCustomerOrders.productId,
       *   quantityOrdered: regularCustomerOrders.quantityOrdered
       * })
       * .from(regularCustomerOrders)
       * .intersectAll(
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * // or
       * import { intersectAll } from 'drizzle-orm/pg-core'
       *
       * await intersectAll(
       *   db.select({
       *     productId: regularCustomerOrders.productId,
       *     quantityOrdered: regularCustomerOrders.quantityOrdered
       *   })
       *   .from(regularCustomerOrders),
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * ```
       */
      intersectAll = this.createSetOperator("intersect", true);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/pg-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /**
       * Adds `except all` set operator to the query.
       *
       * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}
       *
       * @example
       *
       * ```ts
       * // Select all products that are ordered by regular customers but not by VIP customers
       * await db.select({
       *   productId: regularCustomerOrders.productId,
       *   quantityOrdered: regularCustomerOrders.quantityOrdered,
       * })
       * .from(regularCustomerOrders)
       * .exceptAll(
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered,
       *   })
       *   .from(vipCustomerOrders)
       * );
       * // or
       * import { exceptAll } from 'drizzle-orm/pg-core'
       *
       * await exceptAll(
       *   db.select({
       *     productId: regularCustomerOrders.productId,
       *     quantityOrdered: regularCustomerOrders.quantityOrdered
       *   })
       *   .from(regularCustomerOrders),
       *   db.select({
       *     productId: vipCustomerOrders.productId,
       *     quantityOrdered: vipCustomerOrders.quantityOrdered
       *   })
       *   .from(vipCustomerOrders)
       * );
       * ```
       */
      exceptAll = this.createSetOperator("except", true);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset;
        } else {
          this.config.offset = offset;
        }
        return this;
      }
      /**
       * Adds a `for` clause to the query.
       *
       * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.
       *
       * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}
       *
       * @param strength the lock strength.
       * @param config the lock configuration.
       */
      for(strength, config2 = {}) {
        this.config.lockingClause = { strength, config: config2 };
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    PgSelectBase = class extends PgSelectQueryBuilderBase {
      static {
        __name(this, "PgSelectBase");
      }
      static [entityKind] = "PgSelect";
      /** @internal */
      _prepare(name) {
        const { session, config: config2, dialect, joinsNotNullableMap } = this;
        if (!session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          const fieldsList = orderSelectedFields(config2.fields);
          const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true);
          query.joinsNotNullableMap = joinsNotNullableMap;
          return query;
        });
      }
      /**
       * Create a prepared statement for this query. This allows
       * the database to remember this query for the given session
       * and call it by name, rather than specifying the full query.
       *
       * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}
       */
      prepare(name) {
        return this._prepare(name);
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues);
        });
      }, "execute");
    };
    applyMixins(PgSelectBase, [QueryPromise]);
    __name(createSetOperator3, "createSetOperator");
    getPgSetOperators = /* @__PURE__ */ __name(() => ({
      union: union3,
      unionAll: unionAll3,
      intersect: intersect3,
      intersectAll: intersectAll2,
      except: except3,
      exceptAll: exceptAll2
    }), "getPgSetOperators");
    union3 = createSetOperator3("union", false);
    unionAll3 = createSetOperator3("union", true);
    intersect3 = createSetOperator3("intersect", false);
    intersectAll2 = createSetOperator3("intersect", true);
    except3 = createSetOperator3("except", false);
    exceptAll2 = createSetOperator3("except", true);
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
var QueryBuilder3;
var init_query_builder4 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/query-builder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_dialect3();
    init_selection_proxy();
    init_subquery();
    init_select4();
    QueryBuilder3 = class {
      static {
        __name(this, "QueryBuilder");
      }
      static [entityKind] = "PgQueryBuilder";
      dialect;
      $with(alias) {
        const queryBuilder = this;
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(queryBuilder);
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      with(...queries) {
        const self = this;
        function select(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function selectDistinctOn(on2, fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            distinct: { on: on2 }
          });
        }
        __name(selectDistinctOn, "selectDistinctOn");
        return { select, selectDistinct, selectDistinctOn };
      }
      select(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect()
        });
      }
      selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      selectDistinctOn(on2, fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: { on: on2 }
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new PgDialect();
        }
        return this.dialect;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
var PgRefreshMaterializedView;
var init_refresh_materialized_view = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_tracing();
    PgRefreshMaterializedView = class extends QueryPromise {
      static {
        __name(this, "PgRefreshMaterializedView");
      }
      constructor(view, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { view };
      }
      static [entityKind] = "PgRefreshMaterializedView";
      config;
      concurrently() {
        if (this.config.withNoData !== void 0) {
          throw new Error("Cannot use concurrently and withNoData together");
        }
        this.config.concurrently = true;
        return this;
      }
      withNoData() {
        if (this.config.concurrently !== void 0) {
          throw new Error("Cannot use concurrently and withNoData together");
        }
        this.config.withNoData = true;
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildRefreshMaterializedViewQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0, name, true);
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute(placeholderValues);
        });
      }, "execute");
    };
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/select.types.js
var init_select_types3 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/select.types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/update.js
var PgUpdateBuilder, PgUpdateBase;
var init_update3 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/update.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_table();
    init_utils2();
    PgUpdateBuilder = class {
      static {
        __name(this, "PgUpdateBuilder");
      }
      constructor(table3, session, dialect, withList) {
        this.table = table3;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "PgUpdateBuilder";
      set(values) {
        return new PgUpdateBase(
          this.table,
          mapUpdateSet(this.table, values),
          this.session,
          this.dialect,
          this.withList
        );
      }
    };
    PgUpdateBase = class extends QueryPromise {
      static {
        __name(this, "PgUpdateBase");
      }
      constructor(table3, set, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table: table3, withList };
      }
      static [entityKind] = "PgUpdate";
      config;
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * await db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * await db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * await db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * await db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(name) {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true);
      }
      prepare(name) {
        return this._prepare(name);
      }
      execute = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().execute(placeholderValues);
      }, "execute");
      $dynamic() {
        return this;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/index.js
var init_query_builders3 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_delete3();
    init_insert3();
    init_query_builder4();
    init_refresh_materialized_view();
    init_select4();
    init_select_types3();
    init_update3();
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/query.js
var RelationalQueryBuilder3, PgRelationalQuery;
var init_query3 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/query.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    init_relations();
    init_tracing();
    RelationalQueryBuilder3 = class {
      static {
        __name(this, "RelationalQueryBuilder");
      }
      constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table3;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      static [entityKind] = "PgRelationalQueryBuilder";
      findMany(config2) {
        return new PgRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? config2 : {},
          "many"
        );
      }
      findFirst(config2) {
        return new PgRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config2 ? { ...config2, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    };
    PgRelationalQuery = class extends QueryPromise {
      static {
        __name(this, "PgRelationalQuery");
      }
      constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session, config2, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table3;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config2;
        this.mode = mode;
      }
      static [entityKind] = "PgRelationalQuery";
      /** @internal */
      _prepare(name) {
        return tracer.startActiveSpan("drizzle.prepareQuery", () => {
          const { query, builtQuery } = this._toSQL();
          return this.session.prepareQuery(
            builtQuery,
            void 0,
            name,
            true,
            (rawRows, mapColumnValue) => {
              const rows = rawRows.map(
                (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
              );
              if (this.mode === "first") {
                return rows[0];
              }
              return rows;
            }
          );
        });
      }
      prepare(name) {
        return this._prepare(name);
      }
      _getQuery() {
        return this.dialect.buildRelationalQueryWithoutPK({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
      }
      /** @internal */
      getSQL() {
        return this._getQuery().sql;
      }
      _toSQL() {
        const query = this._getQuery();
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      execute() {
        return tracer.startActiveSpan("drizzle.operation", () => {
          return this._prepare().execute();
        });
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/query-builders/raw.js
var PgRaw;
var init_raw2 = __esm({
  "node_modules/drizzle-orm/pg-core/query-builders/raw.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_promise();
    PgRaw = class extends QueryPromise {
      static {
        __name(this, "PgRaw");
      }
      constructor(execute, sql2, query, mapBatchResult) {
        super();
        this.execute = execute;
        this.sql = sql2;
        this.query = query;
        this.mapBatchResult = mapBatchResult;
      }
      static [entityKind] = "PgRaw";
      /** @internal */
      getSQL() {
        return this.sql;
      }
      getQuery() {
        return this.query;
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
      /** @internal */
      isResponseInArrayMode() {
        return false;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/db.js
var PgDatabase;
var init_db3 = __esm({
  "node_modules/drizzle-orm/pg-core/db.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_query_builders3();
    init_selection_proxy();
    init_subquery();
    init_query3();
    init_raw2();
    init_refresh_materialized_view();
    PgDatabase = class {
      static {
        __name(this, "PgDatabase");
      }
      constructor(dialect, session, schema) {
        this.dialect = dialect;
        this.session = session;
        this._ = schema ? {
          schema: schema.schema,
          fullSchema: schema.fullSchema,
          tableNamesMap: schema.tableNamesMap,
          session
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {},
          session
        };
        this.query = {};
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            this.query[tableName] = new RelationalQueryBuilder3(
              schema.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
      }
      static [entityKind] = "PgDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with(alias) {
        return {
          as(qb) {
            if (typeof qb === "function") {
              qb = qb(new QueryBuilder3());
            }
            return new Proxy(
              new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
              new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
            );
          }
        };
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function selectDistinctOn(on2, fields) {
          return new PgSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: { on: on2 }
          });
        }
        __name(selectDistinctOn, "selectDistinctOn");
        function update(table3) {
          return new PgUpdateBuilder(table3, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function insert(table3) {
          return new PgInsertBuilder(table3, self.session, self.dialect, queries);
        }
        __name(insert, "insert");
        function delete_(table3) {
          return new PgDeleteBase(table3, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
      }
      select(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect
        });
      }
      selectDistinct(fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      selectDistinctOn(on2, fields) {
        return new PgSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: { on: on2 }
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table3) {
        return new PgUpdateBuilder(table3, this.session, this.dialect);
      }
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(table3) {
        return new PgInsertBuilder(table3, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(table3) {
        return new PgDeleteBase(table3, this.session, this.dialect);
      }
      refreshMaterializedView(view) {
        return new PgRefreshMaterializedView(view, this.session, this.dialect);
      }
      execute(query) {
        const sql2 = query.getSQL();
        const builtQuery = this.dialect.sqlToQuery(sql2);
        const prepared = this.session.prepareQuery(
          builtQuery,
          void 0,
          void 0,
          false
        );
        return new PgRaw(
          () => prepared.execute(),
          sql2,
          builtQuery,
          (result) => prepared.mapResult(result, true)
        );
      }
      transaction(transaction, config2) {
        return this.session.transaction(transaction, config2);
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/indexes.js
var IndexBuilderOn3, IndexBuilder3, Index3;
var init_indexes3 = __esm({
  "node_modules/drizzle-orm/pg-core/indexes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sql();
    init_entity();
    init_columns3();
    IndexBuilderOn3 = class {
      static {
        __name(this, "IndexBuilderOn");
      }
      constructor(unique, name) {
        this.unique = unique;
        this.name = name;
      }
      static [entityKind] = "PgIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder3(
          columns.map((it) => {
            if (is(it, SQL)) {
              return it;
            }
            it = it;
            const clonedIndexedColumn = new IndexedColumn(it.name, it.columnType, it.indexConfig);
            it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
            return clonedIndexedColumn;
          }),
          this.unique,
          false,
          this.name
        );
      }
      onOnly(...columns) {
        return new IndexBuilder3(
          columns.map((it) => {
            if (is(it, SQL)) {
              return it;
            }
            it = it;
            const clonedIndexedColumn = new IndexedColumn(it.name, it.columnType, it.indexConfig);
            it.indexConfig = it.defaultConfig;
            return clonedIndexedColumn;
          }),
          this.unique,
          true,
          this.name
        );
      }
      /**
       * Specify what index method to use. Choices are `btree`, `hash`, `gist`, `spgist`, `gin`, `brin`, or user-installed access methods like `bloom`. The default method is `btree.
       *
       * If you have the `pg_vector` extension installed in your database, you can use the `hnsw` and `ivfflat` options, which are predefined types.
       *
       * **You can always specify any string you want in the method, in case Drizzle doesn't have it natively in its types**
       *
       * @param method The name of the index method to be used
       * @param columns
       * @returns
       */
      using(method, ...columns) {
        return new IndexBuilder3(
          columns.map((it) => {
            if (is(it, SQL)) {
              return it;
            }
            it = it;
            const clonedIndexedColumn = new IndexedColumn(it.name, it.columnType, it.indexConfig);
            it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
            return clonedIndexedColumn;
          }),
          this.unique,
          true,
          this.name,
          method
        );
      }
    };
    IndexBuilder3 = class {
      static {
        __name(this, "IndexBuilder");
      }
      static [entityKind] = "PgIndexBuilder";
      /** @internal */
      config;
      constructor(columns, unique, only, name, method = "btree") {
        this.config = {
          name,
          columns,
          unique,
          only,
          method
        };
      }
      concurrently() {
        this.config.concurrently = true;
        return this;
      }
      with(obj) {
        this.config.with = obj;
        return this;
      }
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table3) {
        return new Index3(this.config, table3);
      }
    };
    Index3 = class {
      static {
        __name(this, "Index");
      }
      static [entityKind] = "PgIndex";
      config;
      constructor(config2, table3) {
        this.config = { ...config2, table: table3 };
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/sequence.js
function pgSequenceWithSchema(name, options, schema) {
  return new PgSequence(name, options, schema);
}
var PgSequence;
var init_sequence = __esm({
  "node_modules/drizzle-orm/pg-core/sequence.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    PgSequence = class {
      static {
        __name(this, "PgSequence");
      }
      constructor(seqName, seqOptions, schema) {
        this.seqName = seqName;
        this.seqOptions = seqOptions;
        this.schema = schema;
      }
      static [entityKind] = "PgSequence";
    };
    __name(pgSequenceWithSchema, "pgSequenceWithSchema");
  }
});

// node_modules/drizzle-orm/pg-core/view-common.js
var PgViewConfig;
var init_view_common4 = __esm({
  "node_modules/drizzle-orm/pg-core/view-common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    PgViewConfig = Symbol.for("drizzle:PgViewConfig");
  }
});

// node_modules/drizzle-orm/pg-core/view.js
function pgViewWithSchema(name, selection, schema) {
  if (selection) {
    return new ManualViewBuilder3(name, selection, schema);
  }
  return new ViewBuilder3(name, schema);
}
function pgMaterializedViewWithSchema(name, selection, schema) {
  if (selection) {
    return new ManualMaterializedViewBuilder(name, selection, schema);
  }
  return new MaterializedViewBuilder(name, schema);
}
var DefaultViewBuilderCore, ViewBuilder3, ManualViewBuilder3, MaterializedViewBuilderCore, MaterializedViewBuilder, ManualMaterializedViewBuilder, PgView, PgMaterializedViewConfig, PgMaterializedView;
var init_view3 = __esm({
  "node_modules/drizzle-orm/pg-core/view.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_selection_proxy();
    init_utils2();
    init_query_builder4();
    init_table2();
    init_view_base3();
    init_view_common4();
    DefaultViewBuilderCore = class {
      static {
        __name(this, "DefaultViewBuilderCore");
      }
      constructor(name, schema) {
        this.name = name;
        this.schema = schema;
      }
      static [entityKind] = "PgDefaultViewBuilderCore";
      config = {};
      with(config2) {
        this.config.with = config2;
        return this;
      }
    };
    ViewBuilder3 = class extends DefaultViewBuilderCore {
      static {
        __name(this, "ViewBuilder");
      }
      static [entityKind] = "PgViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder3());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(
          new PgView({
            pgConfig: this.config,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: aliasedSelection,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualViewBuilder3 = class extends DefaultViewBuilderCore {
      static {
        __name(this, "ManualViewBuilder");
      }
      static [entityKind] = "PgManualViewBuilder";
      columns;
      constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
      }
      existing() {
        return new Proxy(
          new PgView({
            pgConfig: void 0,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new PgView({
            pgConfig: this.config,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    MaterializedViewBuilderCore = class {
      static {
        __name(this, "MaterializedViewBuilderCore");
      }
      constructor(name, schema) {
        this.name = name;
        this.schema = schema;
      }
      static [entityKind] = "PgMaterializedViewBuilderCore";
      config = {};
      using(using) {
        this.config.using = using;
        return this;
      }
      with(config2) {
        this.config.with = config2;
        return this;
      }
      tablespace(tablespace) {
        this.config.tablespace = tablespace;
        return this;
      }
      withNoData() {
        this.config.withNoData = true;
        return this;
      }
    };
    MaterializedViewBuilder = class extends MaterializedViewBuilderCore {
      static {
        __name(this, "MaterializedViewBuilder");
      }
      static [entityKind] = "PgMaterializedViewBuilder";
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder3());
        }
        const selectionProxy = new SelectionProxyHandler({
          alias: this.name,
          sqlBehavior: "error",
          sqlAliasedBehavior: "alias",
          replaceOriginalName: true
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(
          new PgMaterializedView({
            pgConfig: {
              with: this.config.with,
              using: this.config.using,
              tablespace: this.config.tablespace,
              withNoData: this.config.withNoData
            },
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: aliasedSelection,
              query: qb.getSQL().inlineParams()
            }
          }),
          selectionProxy
        );
      }
    };
    ManualMaterializedViewBuilder = class extends MaterializedViewBuilderCore {
      static {
        __name(this, "ManualMaterializedViewBuilder");
      }
      static [entityKind] = "PgManualMaterializedViewBuilder";
      columns;
      constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
      }
      existing() {
        return new Proxy(
          new PgMaterializedView({
            pgConfig: void 0,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: void 0
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
      as(query) {
        return new Proxy(
          new PgMaterializedView({
            pgConfig: void 0,
            config: {
              name: this.name,
              schema: this.schema,
              selectedFields: this.columns,
              query: query.inlineParams()
            }
          }),
          new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: "error",
            sqlAliasedBehavior: "alias",
            replaceOriginalName: true
          })
        );
      }
    };
    PgView = class extends PgViewBase {
      static {
        __name(this, "PgView");
      }
      static [entityKind] = "PgView";
      [PgViewConfig];
      constructor({ pgConfig, config: config2 }) {
        super(config2);
        if (pgConfig) {
          this[PgViewConfig] = {
            with: pgConfig.with
          };
        }
      }
    };
    PgMaterializedViewConfig = Symbol.for("drizzle:PgMaterializedViewConfig");
    PgMaterializedView = class extends PgViewBase {
      static {
        __name(this, "PgMaterializedView");
      }
      static [entityKind] = "PgMaterializedView";
      [PgMaterializedViewConfig];
      constructor({ pgConfig, config: config2 }) {
        super(config2);
        this[PgMaterializedViewConfig] = {
          with: pgConfig?.with,
          using: pgConfig?.using,
          tablespace: pgConfig?.tablespace,
          withNoData: pgConfig?.withNoData
        };
      }
    };
    __name(pgViewWithSchema, "pgViewWithSchema");
    __name(pgMaterializedViewWithSchema, "pgMaterializedViewWithSchema");
  }
});

// node_modules/drizzle-orm/pg-core/schema.js
var PgSchema;
var init_schema2 = __esm({
  "node_modules/drizzle-orm/pg-core/schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_sql();
    init_enum();
    init_sequence();
    init_table2();
    init_view3();
    PgSchema = class {
      static {
        __name(this, "PgSchema");
      }
      constructor(schemaName) {
        this.schemaName = schemaName;
      }
      static [entityKind] = "PgSchema";
      table = /* @__PURE__ */ __name((name, columns, extraConfig) => {
        return pgTableWithSchema(name, columns, extraConfig, this.schemaName);
      }, "table");
      view = /* @__PURE__ */ __name((name, columns) => {
        return pgViewWithSchema(name, columns, this.schemaName);
      }, "view");
      materializedView = /* @__PURE__ */ __name((name, columns) => {
        return pgMaterializedViewWithSchema(name, columns, this.schemaName);
      }, "materializedView");
      enum = /* @__PURE__ */ __name((name, values) => {
        return pgEnumWithSchema(name, values, this.schemaName);
      }, "enum");
      sequence = /* @__PURE__ */ __name((name, options) => {
        return pgSequenceWithSchema(name, options, this.schemaName);
      }, "sequence");
      getSQL() {
        return new SQL([sql.identifier(this.schemaName)]);
      }
      shouldOmitSQLParens() {
        return true;
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/session.js
var PgPreparedQuery, PgSession, PgTransaction;
var init_session4 = __esm({
  "node_modules/drizzle-orm/pg-core/session.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entity();
    init_errors3();
    init_sql2();
    init_tracing();
    init_db3();
    PgPreparedQuery = class {
      static {
        __name(this, "PgPreparedQuery");
      }
      constructor(query) {
        this.query = query;
      }
      getQuery() {
        return this.query;
      }
      mapResult(response, _isFromBatch) {
        return response;
      }
      static [entityKind] = "PgPreparedQuery";
      /** @internal */
      joinsNotNullableMap;
    };
    PgSession = class {
      static {
        __name(this, "PgSession");
      }
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "PgSession";
      execute(query) {
        return tracer.startActiveSpan("drizzle.operation", () => {
          const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
            return this.prepareQuery(
              this.dialect.sqlToQuery(query),
              void 0,
              void 0,
              false
            );
          });
          return prepared.execute();
        });
      }
      all(query) {
        return this.prepareQuery(
          this.dialect.sqlToQuery(query),
          void 0,
          void 0,
          false
        ).all();
      }
    };
    PgTransaction = class extends PgDatabase {
      static {
        __name(this, "PgTransaction");
      }
      constructor(dialect, session, schema, nestedIndex = 0) {
        super(dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "PgTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
      /** @internal */
      getTransactionConfigSQL(config2) {
        const chunks = [];
        if (config2.isolationLevel) {
          chunks.push(`isolation level ${config2.isolationLevel}`);
        }
        if (config2.accessMode) {
          chunks.push(config2.accessMode);
        }
        if (typeof config2.deferrable === "boolean") {
          chunks.push(config2.deferrable ? "deferrable" : "not deferrable");
        }
        return sql.raw(chunks.join(" "));
      }
      setTransaction(config2) {
        return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config2)}`);
      }
    };
  }
});

// node_modules/drizzle-orm/pg-core/subquery.js
var init_subquery4 = __esm({
  "node_modules/drizzle-orm/pg-core/subquery.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/pg-core/utils.js
var init_utils6 = __esm({
  "node_modules/drizzle-orm/pg-core/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/drizzle-orm/pg-core/utils/index.js
var init_utils7 = __esm({
  "node_modules/drizzle-orm/pg-core/utils/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array();
  }
});

// node_modules/drizzle-orm/pg-core/index.js
var init_pg_core = __esm({
  "node_modules/drizzle-orm/pg-core/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_alias4();
    init_checks3();
    init_columns3();
    init_db3();
    init_dialect3();
    init_foreign_keys();
    init_indexes3();
    init_primary_keys();
    init_query_builders3();
    init_schema2();
    init_sequence();
    init_session4();
    init_subquery4();
    init_table2();
    init_unique_constraint();
    init_utils6();
    init_utils7();
    init_view_common4();
    init_view3();
  }
});

// node_modules/drizzle-zod/index.mjs
function c(t, n) {
  const r = getTableColumns(t), o = Object.entries(r);
  let i = Object.fromEntries(o.map(([e, t2]) => [e, p(t2)]));
  n && (i = Object.assign(i, Object.fromEntries(Object.entries(n).map(([e, t2]) => [e, "function" == typeof t2 ? t2(i) : t2]))));
  for (const [e, t2] of o) t2.notNull ? t2.hasDefault && (i[e] = i[e].optional()) : i[e] = i[e].nullable().optional();
  return external_exports.object(i);
}
function b(t, n) {
  const r = getTableColumns(t), o = Object.entries(r);
  let i = Object.fromEntries(o.map(([e, t2]) => [e, p(t2)]));
  n && (i = Object.assign(i, Object.fromEntries(Object.entries(n).map(([e, t2]) => [e, "function" == typeof t2 ? t2(i) : t2]))));
  for (const [e, t2] of o) t2.notNull || (i[e] = i[e].nullable());
  return external_exports.object(i);
}
function p(e) {
  let m2;
  if (function(e2) {
    return "enumValues" in e2 && Array.isArray(e2.enumValues) && e2.enumValues.length > 0;
  }(e) && (m2 = e.enumValues.length ? external_exports.enum(e.enumValues) : external_exports.string()), !m2) {
    if (is(e, PgUUID)) m2 = external_exports.string().uuid();
    else if ("custom" === e.dataType) m2 = external_exports.any();
    else if ("json" === e.dataType) m2 = f;
    else if ("array" === e.dataType) m2 = external_exports.array(p(e.baseColumn));
    else if ("number" === e.dataType) m2 = external_exports.number();
    else if ("bigint" === e.dataType) m2 = external_exports.bigint();
    else if ("boolean" === e.dataType) m2 = external_exports.boolean();
    else if ("date" === e.dataType) m2 = external_exports.date();
    else if ("string" === e.dataType) {
      let i = external_exports.string();
      (is(e, PgChar) || is(e, PgVarchar) || is(e, MySqlVarChar) || is(e, MySqlVarBinary) || is(e, MySqlChar) || is(e, SQLiteText)) && "number" == typeof e.length && (i = i.max(e.length)), m2 = i;
    }
  }
  return m2 || (m2 = external_exports.any()), m2;
}
var m, f;
var init_drizzle_zod = __esm({
  "node_modules/drizzle-zod/index.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_drizzle_orm();
    init_mysql_core();
    init_pg_core();
    init_sqlite_core();
    init_zod();
    m = external_exports.union([external_exports.string(), external_exports.number(), external_exports.boolean(), external_exports.null()]);
    f = external_exports.lazy(() => external_exports.union([m, external_exports.array(f), external_exports.record(f)]));
    __name(c, "c");
    __name(b, "b");
    __name(p, "p");
  }
});

// dist/database/schema.js
var schema_exports = {};
__export(schema_exports, {
  audioUploads: () => audioUploads,
  audioUploadsRelations: () => audioUploadsRelations,
  campaignShows: () => campaignShows,
  campaignShowsRelations: () => campaignShowsRelations,
  campaigns: () => campaigns,
  campaignsRelations: () => campaignsRelations,
  creatives: () => creatives,
  creativesRelations: () => creativesRelations,
  episodes: () => episodes,
  episodesRelations: () => episodesRelations,
  imageUploads: () => imageUploads,
  imageUploadsRelations: () => imageUploadsRelations,
  insertAudioUploadSchema: () => insertAudioUploadSchema,
  insertCampaignSchema: () => insertCampaignSchema,
  insertCampaignShowSchema: () => insertCampaignShowSchema,
  insertCreativeSchema: () => insertCreativeSchema,
  insertEpisodeSchema: () => insertEpisodeSchema,
  insertImageUploadSchema: () => insertImageUploadSchema,
  insertOrganizationSchema: () => insertOrganizationSchema,
  insertShowSchema: () => insertShowSchema,
  insertTaskSchema: () => insertTaskSchema,
  insertWorkflowSchema: () => insertWorkflowSchema,
  organizations: () => organizations,
  organizationsRelations: () => organizationsRelations,
  selectAudioUploadSchema: () => selectAudioUploadSchema,
  selectCampaignSchema: () => selectCampaignSchema,
  selectCampaignShowSchema: () => selectCampaignShowSchema,
  selectCreativeSchema: () => selectCreativeSchema,
  selectEpisodeSchema: () => selectEpisodeSchema,
  selectImageUploadSchema: () => selectImageUploadSchema,
  selectOrganizationSchema: () => selectOrganizationSchema,
  selectShowSchema: () => selectShowSchema,
  selectTaskSchema: () => selectTaskSchema,
  selectWorkflowSchema: () => selectWorkflowSchema,
  shows: () => shows,
  showsRelations: () => showsRelations,
  tasks: () => tasks,
  tasksRelations: () => tasksRelations,
  workflows: () => workflows,
  workflowsRelations: () => workflowsRelations
});
var organizations, shows, episodes, audioUploads, imageUploads, tasks, workflows, campaigns, creatives, campaignShows, organizationsRelations, showsRelations, episodesRelations, audioUploadsRelations, imageUploadsRelations, tasksRelations, workflowsRelations, campaignsRelations, creativesRelations, campaignShowsRelations, insertOrganizationSchema, selectOrganizationSchema, insertShowSchema, selectShowSchema, insertEpisodeSchema, selectEpisodeSchema, insertAudioUploadSchema, selectAudioUploadSchema, insertImageUploadSchema, selectImageUploadSchema, insertTaskSchema, selectTaskSchema, insertWorkflowSchema, selectWorkflowSchema, insertCampaignSchema, selectCampaignSchema, insertCreativeSchema, selectCreativeSchema, insertCampaignShowSchema, selectCampaignShowSchema;
var init_schema3 = __esm({
  "dist/database/schema.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sqlite_core();
    init_drizzle_zod();
    init_drizzle_orm();
    organizations = sqliteTable("organizations", {
      id: text("id").primaryKey(),
      // This will be the Auth0 organization ID
      name: text("name").notNull(),
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull()
    });
    shows = sqliteTable("shows", {
      id: text("id").primaryKey(),
      organizationId: text("organization_id").notNull().references(() => organizations.id, { onDelete: "cascade" }),
      title: text("title").notNull(),
      description: text("description").notNull(),
      imageUrl: text("image_url"),
      language: text("language"),
      // Language code (e.g. "en", "es")
      categories: text("categories"),
      // JSON string containing array of categories
      author: text("author"),
      // Show author/creator
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull()
    });
    episodes = sqliteTable("episodes", {
      id: text("id").primaryKey(),
      organizationId: text("organization_id").notNull().references(() => organizations.id, { onDelete: "cascade" }),
      showId: text("show_id").notNull().references(() => shows.id, { onDelete: "cascade" }),
      title: text("title").notNull(),
      description: text("description").notNull(),
      imageUrl: text("image_url"),
      audioUrl: text("audio_url"),
      transcriptUrl: text("transcript_url"),
      encodedAudioUrls: text("encoded_audio_urls"),
      // JSON string containing encoded audio URLs
      published: integer("published", { mode: "boolean" }).default(false),
      publishedAt: text("published_at"),
      duration: integer("duration"),
      // Duration in seconds
      episodeNumber: integer("episode_number"),
      // Episode number within season
      seasonNumber: integer("season_number"),
      // Season number
      episodeType: text("episode_type"),
      // full, trailer, bonus
      author: text("author"),
      // Episode-specific author/narrator
      subtitle: text("subtitle"),
      // iTunes subtitle
      explicit: integer("explicit", { mode: "boolean" }),
      // Explicit content flag
      keywords: text("keywords"),
      // JSON string containing array of keywords/tags
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull()
    });
    audioUploads = sqliteTable("audio_uploads", {
      id: text("id").primaryKey(),
      episodeId: text("episode_id").notNull().references(() => episodes.id, { onDelete: "cascade" }),
      fileName: text("file_name").notNull(),
      fileSize: integer("file_size").notNull(),
      mimeType: text("mime_type").notNull(),
      url: text("url").notNull(),
      uploadedAt: text("uploaded_at").notNull()
    });
    imageUploads = sqliteTable("image_uploads", {
      id: text("id").primaryKey(),
      showId: text("show_id").references(() => shows.id, { onDelete: "cascade" }),
      episodeId: text("episode_id").references(() => episodes.id, {
        onDelete: "cascade"
      }),
      fileName: text("file_name").notNull(),
      fileSize: integer("file_size").notNull(),
      mimeType: text("mime_type").notNull(),
      url: text("url").notNull(),
      uploadedAt: text("uploaded_at").notNull()
    });
    tasks = sqliteTable("tasks", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      type: text("type").notNull(),
      // "transcribe", "encode", "publish", "notification", "audio_processing"
      status: text("status").notNull().default("pending"),
      // "pending", "processing", "done", "failed", "retry"
      payload: text("payload"),
      // JSON string with input data
      result: text("result"),
      // JSON string with output data
      error: text("error"),
      // Error message if failed
      attempts: integer("attempts").default(0),
      startedAt: text("started_at"),
      // When task processing actually started
      progress: integer("progress").default(0),
      // Progress percentage (0-100)
      step: text("step"),
      // Current step description (e.g., "2/10 Encoding audio for processing")
      workflowId: text("workflow_id"),
      // Associated workflow instance ID
      workflowInstanceId: text("workflow_instance_id"),
      // Cloudflare workflow instance ID
      organizationId: text("organization_id").notNull().references(() => organizations.id, { onDelete: "cascade" }),
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull()
    });
    workflows = sqliteTable("workflows", {
      id: text("id").primaryKey(),
      taskId: integer("task_id").references(() => tasks.id, {
        onDelete: "cascade"
      }),
      workflowName: text("workflow_name").notNull(),
      instanceId: text("instance_id").notNull(),
      // Cloudflare workflow instance ID
      status: text("status").notNull().default("queued"),
      // "queued", "running", "paused", "completed", "failed", "cancelled", "terminated"
      episodeId: text("episode_id"),
      metadata: text("metadata"),
      // JSON string with workflow metadata
      progress: text("progress"),
      // JSON string with step progress
      estimatedProgress: integer("estimated_progress").default(0),
      // Overall progress percentage (0-100)
      estimatedDuration: text("estimated_duration"),
      actualDuration: integer("actual_duration"),
      // Duration in seconds
      error: text("error"),
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull(),
      completedAt: text("completed_at")
    });
    campaigns = sqliteTable("campaigns", {
      id: text("id").primaryKey(),
      organizationId: text("organization_id").notNull().references(() => organizations.id, { onDelete: "cascade" }),
      name: text("name").notNull(),
      advertiser: text("advertiser"),
      startDate: text("start_date"),
      endDate: text("end_date"),
      targetImpressions: integer("target_impressions"),
      priority: integer("priority").notNull().default(5),
      // Lower number = higher priority
      status: text("status", { enum: ["draft", "active", "paused", "ended"] }).notNull().default("draft"),
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull()
    });
    creatives = sqliteTable("creatives", {
      id: text("id").primaryKey(),
      campaignId: text("campaign_id").notNull().references(() => campaigns.id, { onDelete: "cascade" }),
      name: text("name").notNull(),
      type: text("type", { enum: ["audio", "video", "display"] }).notNull().default("audio"),
      audioUrl: text("audio_url"),
      imageUrl: text("image_url"),
      duration: integer("duration"),
      // Length in seconds
      placementType: text("placement_type", { enum: ["pre", "mid", "post", "any"] }).notNull().default("any"),
      language: text("language"),
      // Optional (e.g. "en", "es")
      createdAt: text("created_at").notNull(),
      updatedAt: text("updated_at").notNull()
    });
    campaignShows = sqliteTable("campaign_shows", {
      campaignId: text("campaign_id").notNull().references(() => campaigns.id, { onDelete: "cascade" }),
      showId: text("show_id").notNull().references(() => shows.id, { onDelete: "cascade" }),
      createdAt: text("created_at").notNull()
    });
    organizationsRelations = relations(organizations, ({ many }) => ({
      shows: many(shows),
      campaigns: many(campaigns),
      tasks: many(tasks)
    }));
    showsRelations = relations(shows, ({ one, many }) => ({
      organization: one(organizations, {
        fields: [shows.organizationId],
        references: [organizations.id]
      }),
      episodes: many(episodes),
      imageUploads: many(imageUploads),
      campaignShows: many(campaignShows)
    }));
    episodesRelations = relations(episodes, ({ one, many }) => ({
      organization: one(organizations, {
        fields: [episodes.organizationId],
        references: [organizations.id]
      }),
      show: one(shows, {
        fields: [episodes.showId],
        references: [shows.id]
      }),
      audioUploads: many(audioUploads),
      imageUploads: many(imageUploads)
    }));
    audioUploadsRelations = relations(audioUploads, ({ one }) => ({
      episode: one(episodes, {
        fields: [audioUploads.episodeId],
        references: [episodes.id]
      })
    }));
    imageUploadsRelations = relations(imageUploads, ({ one }) => ({
      show: one(shows, {
        fields: [imageUploads.showId],
        references: [shows.id]
      }),
      episode: one(episodes, {
        fields: [imageUploads.episodeId],
        references: [episodes.id]
      })
    }));
    tasksRelations = relations(tasks, ({ one }) => ({
      organization: one(organizations, {
        fields: [tasks.organizationId],
        references: [organizations.id]
      }),
      workflow: one(workflows, {
        fields: [tasks.id],
        references: [workflows.taskId]
      })
    }));
    workflowsRelations = relations(workflows, ({ one }) => ({
      task: one(tasks, {
        fields: [workflows.taskId],
        references: [tasks.id]
      })
    }));
    campaignsRelations = relations(campaigns, ({ one, many }) => ({
      organization: one(organizations, {
        fields: [campaigns.organizationId],
        references: [organizations.id]
      }),
      creatives: many(creatives),
      campaignShows: many(campaignShows)
    }));
    creativesRelations = relations(creatives, ({ one }) => ({
      campaign: one(campaigns, {
        fields: [creatives.campaignId],
        references: [campaigns.id]
      })
    }));
    campaignShowsRelations = relations(campaignShows, ({ one }) => ({
      campaign: one(campaigns, {
        fields: [campaignShows.campaignId],
        references: [campaigns.id]
      }),
      show: one(shows, {
        fields: [campaignShows.showId],
        references: [shows.id]
      })
    }));
    insertOrganizationSchema = c(organizations);
    selectOrganizationSchema = b(organizations);
    insertShowSchema = c(shows);
    selectShowSchema = b(shows);
    insertEpisodeSchema = c(episodes);
    selectEpisodeSchema = b(episodes);
    insertAudioUploadSchema = c(audioUploads);
    selectAudioUploadSchema = b(audioUploads);
    insertImageUploadSchema = c(imageUploads);
    selectImageUploadSchema = b(imageUploads);
    insertTaskSchema = c(tasks);
    selectTaskSchema = b(tasks);
    insertWorkflowSchema = c(workflows);
    selectWorkflowSchema = b(workflows);
    insertCampaignSchema = c(campaigns);
    selectCampaignSchema = b(campaigns);
    insertCreativeSchema = c(creatives);
    selectCreativeSchema = b(creatives);
    insertCampaignShowSchema = c(campaignShows);
    selectCampaignShowSchema = b(campaignShows);
  }
});

// dist/database/client.js
var client_exports = {};
__export(client_exports, {
  getDatabase: () => getDatabase
});
var db, getDatabase;
var init_client = __esm({
  "dist/database/client.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_d1();
    init_schema3();
    getDatabase = /* @__PURE__ */ __name((D1Database) => {
      if (db) {
        return db;
      }
      if (D1Database) {
        db = drizzle(D1Database, { schema: schema_exports });
        return db;
      }
      throw new Error("D1 database binding is required. Make sure DB is bound in wrangler.toml");
    }, "getDatabase");
  }
});

// dist/tasks/repository.js
var repository_exports = {};
__export(repository_exports, {
  TaskRepository: () => TaskRepository
});
var TaskRepository;
var init_repository = __esm({
  "dist/tasks/repository.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_drizzle_orm();
    init_schema3();
    init_client();
    TaskRepository = class {
      static {
        __name(this, "TaskRepository");
      }
      db;
      constructor(database) {
        this.db = getDatabase(database);
      }
      async create(task) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const newTask = {
          ...task,
          createdAt: now,
          updatedAt: now
        };
        const result = await this.db.insert(tasks).values(newTask).returning();
        return result[0];
      }
      async findById(id) {
        const result = await this.db.select().from(tasks).where(eq(tasks.id, id));
        return result[0] || null;
      }
      async findByIdAndOrganization(id, organizationId) {
        const result = await this.db.select().from(tasks).where(and(eq(tasks.id, id), eq(tasks.organizationId, organizationId)));
        return result[0] || null;
      }
      async findByStatus(status, limit = 10, offset = 0, sortBy = "created_at", sortOrder = "desc", organizationId) {
        const sortColumn = sortBy === "created_at" ? tasks.createdAt : sortBy === "updated_at" ? tasks.updatedAt : sortBy === "type" ? tasks.type : sortBy === "status" ? tasks.status : tasks.createdAt;
        const orderByColumn = sortOrder === "asc" ? asc(sortColumn) : desc(sortColumn);
        let whereConditions = [];
        if (status) {
          whereConditions.push(eq(tasks.status, status));
        }
        if (organizationId) {
          whereConditions.push(eq(tasks.organizationId, organizationId));
        }
        if (whereConditions.length > 0) {
          return await this.db.select().from(tasks).where(and(...whereConditions)).orderBy(orderByColumn).limit(limit).offset(offset);
        }
        return await this.db.select().from(tasks).orderBy(orderByColumn).limit(limit).offset(offset);
      }
      async findPendingTasks(limit = 5) {
        return await this.db.select().from(tasks).where(eq(tasks.status, "pending")).orderBy(tasks.createdAt).limit(limit);
      }
      async findPendingAndRetryTasks(limit = 5) {
        return await this.db.select().from(tasks).where(or(eq(tasks.status, "pending"), eq(tasks.status, "retry"))).orderBy(tasks.createdAt).limit(limit);
      }
      async updateStatus(id, status, updates = {}) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await this.db.update(tasks).set({
          status,
          updatedAt: now,
          ...updates
        }).where(eq(tasks.id, id)).returning();
        return result[0] || null;
      }
      async incrementAttempts(id) {
        console.log(`Incrementing attempts for task ${id}`);
        const task = await this.findById(id);
        if (!task) {
          console.log(`Task ${id} not found`);
          return null;
        }
        console.log(`Task ${id} current status: ${task.status}, attempts: ${task.attempts || 0}`);
        const updatedTask = await this.updateStatus(id, "processing", {
          attempts: (task.attempts || 0) + 1
        });
        console.log(`Task ${id} updated status: ${updatedTask?.status}, attempts: ${updatedTask?.attempts}`);
        return updatedTask;
      }
      async markAsDone(id, result) {
        return await this.updateStatus(id, "done", {
          result: result ? JSON.stringify(result) : void 0
        });
      }
      async markAsFailed(id, error3) {
        return await this.updateStatus(id, "failed", {
          error: error3
        });
      }
      async markAsRetry(id, error3, attempts) {
        return await this.updateStatus(id, "retry", {
          error: error3,
          attempts
        });
      }
      async resetForRetry(id) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await this.db.update(tasks).set({
          status: "pending",
          error: null,
          result: null,
          progress: 0,
          step: null,
          startedAt: null,
          updatedAt: now
        }).where(eq(tasks.id, id)).returning();
        return result[0] || null;
      }
      async updateProgress(id, progress) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await this.db.update(tasks).set({
          progress,
          updatedAt: now
        }).where(eq(tasks.id, id)).returning();
        return result[0] || null;
      }
      async updateStep(id, step, progress) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const updateData = {
          step,
          updatedAt: now
        };
        if (progress !== void 0) {
          updateData.progress = progress;
        }
        const result = await this.db.update(tasks).set(updateData).where(eq(tasks.id, id)).returning();
        return result[0] || null;
      }
      async markAsStarted(id) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await this.db.update(tasks).set({
          status: "processing",
          startedAt: now,
          progress: 0,
          updatedAt: now
        }).where(eq(tasks.id, id)).returning();
        return result[0] || null;
      }
      async update(id, updates) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const result = await this.db.update(tasks).set({
          ...updates,
          updatedAt: now
        }).where(eq(tasks.id, id)).returning();
        return result[0] || null;
      }
    };
  }
});

// dist/workflows/repository.js
var WorkflowRepository;
var init_repository2 = __esm({
  "dist/workflows/repository.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_d1();
    init_drizzle_orm();
    init_schema3();
    WorkflowRepository = class {
      static {
        __name(this, "WorkflowRepository");
      }
      db;
      constructor(database) {
        if (database) {
          this.db = drizzle(database);
        } else {
          this.db = {};
        }
      }
      async create(workflow) {
        const [result] = await this.db.insert(workflows).values(workflow).returning();
        return result;
      }
      async findById(id) {
        const result = await this.db.select().from(workflows).where(eq(workflows.id, id)).limit(1);
        return result[0] || null;
      }
      async findByTaskId(taskId) {
        const result = await this.db.select().from(workflows).where(eq(workflows.taskId, taskId)).limit(1);
        return result[0] || null;
      }
      async findByInstanceId(instanceId) {
        const result = await this.db.select().from(workflows).where(eq(workflows.instanceId, instanceId)).limit(1);
        return result[0] || null;
      }
      async findByStatus(status, limit = 10, offset = 0, sortBy = "createdAt", sortOrder = "desc") {
        let baseQuery = this.db.select().from(workflows);
        if (status) {
          baseQuery = baseQuery.where(eq(workflows.status, status));
        }
        const orderFn = sortOrder === "desc" ? desc : asc;
        const sortColumn = sortBy === "createdAt" ? workflows.createdAt : workflows.updatedAt;
        return await baseQuery.orderBy(orderFn(sortColumn)).limit(limit).offset(offset);
      }
      async updateStatus(id, status, updates) {
        const updateData = {
          status,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...updates
        };
        const [result] = await this.db.update(workflows).set(updateData).where(eq(workflows.id, id)).returning();
        return result || null;
      }
      async updateProgress(id, estimatedProgress, progress) {
        await this.db.update(workflows).set({
          estimatedProgress,
          progress,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        }).where(eq(workflows.id, id));
      }
      async markAsCompleted(id, result, actualDuration) {
        const completedAt = (/* @__PURE__ */ new Date()).toISOString();
        const updateData = {
          status: "completed",
          estimatedProgress: 100,
          completedAt,
          updatedAt: completedAt,
          ...actualDuration && { actualDuration },
          ...result && { metadata: JSON.stringify(result) }
        };
        const [updated] = await this.db.update(workflows).set(updateData).where(eq(workflows.id, id)).returning();
        return updated || null;
      }
      async markAsFailed(id, error3, actualDuration) {
        const completedAt = (/* @__PURE__ */ new Date()).toISOString();
        const updateData = {
          status: "failed",
          error: error3,
          completedAt,
          updatedAt: completedAt,
          ...actualDuration && { actualDuration }
        };
        const [updated] = await this.db.update(workflows).set(updateData).where(eq(workflows.id, id)).returning();
        return updated || null;
      }
      async deleteById(id) {
        const result = await this.db.delete(workflows).where(eq(workflows.id, id));
        return result.changes > 0;
      }
      async findByEpisodeId(episodeId) {
        return await this.db.select().from(workflows).where(eq(workflows.episodeId, episodeId)).orderBy(desc(workflows.createdAt));
      }
      async getStats() {
        const allWorkflows = await this.db.select().from(workflows);
        const total = allWorkflows.length;
        const byStatus = allWorkflows.reduce((acc, workflow) => {
          acc[workflow.status] = (acc[workflow.status] || 0) + 1;
          return acc;
        }, {});
        const now = /* @__PURE__ */ new Date();
        const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
        const last7d = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
        const last30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
        const recentActivity = {
          last24h: allWorkflows.filter((w) => new Date(w.createdAt) >= last24h).length,
          last7d: allWorkflows.filter((w) => new Date(w.createdAt) >= last7d).length,
          last30d: allWorkflows.filter((w) => new Date(w.createdAt) >= last30d).length
        };
        const completed = byStatus.completed || 0;
        const failed = byStatus.failed || 0;
        const totalFinished = completed + failed;
        const successRate = totalFinished > 0 ? completed / totalFinished * 100 : 0;
        return {
          total,
          byStatus,
          recentActivity,
          successRate
        };
      }
    };
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    rnds8 = new Uint8Array(16);
    __name(rng, "rng");
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
var byteToHex;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    __name(unsafeStringify, "unsafeStringify");
  }
});

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID, native_default;
var init_native = __esm({
  "node_modules/uuid/dist/esm-browser/native.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    native_default = {
      randomUUID
    };
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_native();
    init_rng();
    init_stringify();
    __name(v4, "v4");
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_v4();
  }
});

// dist/workflows/service.js
var service_exports = {};
__export(service_exports, {
  WorkflowService: () => WorkflowService
});
var WorkflowService;
var init_service = __esm({
  "dist/workflows/service.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_repository2();
    init_repository();
    init_esm_browser();
    WorkflowService = class {
      static {
        __name(this, "WorkflowService");
      }
      repository;
      taskRepository;
      constructor(database) {
        this.repository = new WorkflowRepository(database);
        this.taskRepository = new TaskRepository(database);
      }
      async createWorkflow(taskId, workflowName, params, workflowBinding) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const workflowId = v4_default();
        let instanceId;
        try {
          if (workflowName === "audio-processing" && workflowBinding) {
            const instance = await workflowBinding.create({
              id: workflowId,
              params: {
                ...params,
                taskId: taskId.toString(),
                // Pass task ID to the workflow as string
                workflowId
                // Pass workflow ID to the workflow
              }
            });
            instanceId = instance.id;
          } else if (workflowName === "import-show" && workflowBinding) {
            const instance = await workflowBinding.create({
              id: workflowId,
              params: {
                ...params,
                taskId: taskId.toString(),
                // Pass task ID to the workflow as string
                workflowId
                // Pass workflow ID to the workflow
              }
            });
            instanceId = instance.id;
          } else {
            throw new Error(`Workflow ${workflowName} not available or binding not provided`);
          }
        } catch (error3) {
          console.error(`Failed to create ${workflowName} workflow:`, error3);
          throw new Error(`Failed to create workflow: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
        }
        const workflow = await this.repository.create({
          id: workflowId,
          taskId,
          workflowName,
          instanceId,
          status: "queued",
          episodeId: params.episodeId,
          metadata: JSON.stringify(params),
          estimatedProgress: 0,
          estimatedDuration: workflowName === "audio-processing" ? "5-15 minutes" : workflowName === "import-show" ? "2-10 minutes" : void 0,
          createdAt: now,
          updatedAt: now
        });
        return { workflow, instanceId };
      }
      async getWorkflow(id) {
        return await this.repository.findById(id);
      }
      async getWorkflowByTaskId(taskId) {
        return await this.repository.findByTaskId(taskId);
      }
      async getWorkflowByInstanceId(instanceId) {
        return await this.repository.findByInstanceId(instanceId);
      }
      async updateWorkflowStatus(workflowId, status, updates) {
        const updateData = {
          ...updates,
          ...updates?.metadata && { metadata: JSON.stringify(updates.metadata) },
          ...updates?.progress && typeof updates.progress === "object" && {
            progress: JSON.stringify(updates.progress)
          }
        };
        return await this.repository.updateStatus(workflowId, status, updateData);
      }
      async updateWorkflowProgress(workflowId, progressUpdate) {
        const workflow = await this.repository.findById(workflowId);
        if (!workflow) {
          throw new Error(`Workflow ${workflowId} not found`);
        }
        let currentProgress = {};
        if (workflow.progress) {
          try {
            currentProgress = JSON.parse(workflow.progress);
          } catch (error3) {
            console.warn("Failed to parse existing workflow progress:", error3);
          }
        }
        currentProgress[progressUpdate.step] = {
          progress: progressUpdate.progress,
          message: progressUpdate.message,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          ...progressUpdate.data && { data: progressUpdate.data }
        };
        const estimatedProgress = this.calculateOverallProgress(currentProgress);
        await this.repository.updateProgress(workflowId, estimatedProgress, JSON.stringify(currentProgress));
        if (workflow.taskId) {
          await this.taskRepository.updateProgress(workflow.taskId, estimatedProgress);
        }
      }
      async completeWorkflow(workflowId, result, actualDuration) {
        const completed = await this.repository.markAsCompleted(workflowId, result, actualDuration);
        if (completed?.taskId) {
          await this.taskRepository.markAsDone(completed.taskId, result || {});
        }
        return completed;
      }
      async failWorkflow(workflowId, error3, actualDuration) {
        const failed = await this.repository.markAsFailed(workflowId, error3, actualDuration);
        if (failed?.taskId) {
          await this.taskRepository.markAsFailed(failed.taskId, error3);
        }
        return failed;
      }
      async getWorkflowsByEpisodeId(episodeId) {
        return await this.repository.findByEpisodeId(episodeId);
      }
      async getWorkflowStats() {
        return await this.repository.getStats();
      }
      async listWorkflows(status, limit = 10, offset = 0, sortBy = "createdAt", sortOrder = "desc") {
        return await this.repository.findByStatus(status, limit, offset, sortBy, sortOrder);
      }
      /**
       * Calculate overall progress based on individual step progress
       * This uses predefined weights for different workflow steps
       */
      calculateOverallProgress(stepProgress) {
        const stepWeights = {
          "initialize-workflow": 5,
          "encode-for-processing": 15,
          "prepare-chunk-storage": 5,
          "audio-chunking": 15,
          "transcribe-chunks": 30,
          "audio-encoding": 20,
          "update-episode-encodings": 5,
          "cleanup-resources": 3,
          "finalize-processing": 2
        };
        let totalWeight = 0;
        let completedWeight = 0;
        for (const [stepName, weight] of Object.entries(stepWeights)) {
          totalWeight += weight;
          if (stepProgress[stepName]) {
            const stepProgressPercent = stepProgress[stepName].progress || 0;
            completedWeight += weight * stepProgressPercent / 100;
          }
        }
        return totalWeight > 0 ? Math.round(completedWeight / totalWeight * 100) : 0;
      }
      /**
       * Handle workflow progress updates from Cloudflare Workflows
       * This would be called by workflow steps to report progress
       */
      async handleWorkflowProgressUpdate(instanceId, step, progress, message2, data) {
        const workflow = await this.repository.findByInstanceId(instanceId);
        if (!workflow) {
          console.warn(`Workflow with instance ID ${instanceId} not found`);
          return;
        }
        await this.updateWorkflowProgress(workflow.id, {
          step,
          progress,
          message: message2,
          data
        });
      }
    };
  }
});

// dist/tasks/service.js
var service_exports2 = {};
__export(service_exports2, {
  TaskService: () => TaskService
});
var TaskService;
var init_service2 = __esm({
  "dist/tasks/service.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_repository();
    init_service();
    TaskService = class {
      static {
        __name(this, "TaskService");
      }
      repository;
      workflowService;
      audioProcessingWorkflow;
      // This is the Cloudflare Workflow binding
      importShowWorkflow;
      // This is the Cloudflare Workflow binding
      constructor(database, audioProcessingWorkflow, importShowWorkflow) {
        this.repository = new TaskRepository(database);
        this.workflowService = new WorkflowService(database);
        this.audioProcessingWorkflow = audioProcessingWorkflow;
        this.importShowWorkflow = importShowWorkflow;
        console.log(`TaskService initialized with workflows: audio=${!!audioProcessingWorkflow}, import=${!!importShowWorkflow}`);
      }
      async createTask(type, payload, organizationId) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const task = await this.repository.create({
          type,
          status: "pending",
          attempts: 0,
          organizationId,
          createdAt: now,
          updatedAt: now,
          payload: payload ? JSON.stringify(payload) : void 0
        });
        try {
          if (type === "audio_processing" && payload) {
            console.log(`Creating workflow for audio_processing task ${task.id}`);
            await this.handleAudioProcessing({ ...payload, taskId: task.id });
          } else if (type === "import_show" && payload) {
            console.log(`Creating workflow for import_show task ${task.id}`);
            await this.handleImportShow({ ...payload, taskId: task.id });
          } else {
            console.log(`Task ${task.id} created, will be processed in batch`);
          }
        } catch (error3) {
          console.error(`Failed to start workflow for task ${task.id}:`, error3);
          await this.repository.update(task.id, {
            status: "failed",
            error: error3 instanceof Error ? error3.message : String(error3)
          });
          throw error3;
        }
        return task;
      }
      async getTask(id, organizationId) {
        if (organizationId) {
          return await this.repository.findByIdAndOrganization(id, organizationId);
        }
        return await this.repository.findById(id);
      }
      async getTasks(status, limit = 10, offset = 0, sortBy = "created_at", sortOrder = "desc", organizationId) {
        return await this.repository.findByStatus(status, limit, offset, sortBy, sortOrder, organizationId);
      }
      async retryTask(id, organizationId) {
        const task = organizationId ? await this.repository.findByIdAndOrganization(id, organizationId) : await this.repository.findById(id);
        if (!task) {
          throw new Error("Task not found");
        }
        const retriedTask = await this.repository.resetForRetry(id);
        if (!retriedTask) {
          throw new Error("Failed to reset task for retry");
        }
        try {
          if (retriedTask.type === "audio_processing" && retriedTask.payload) {
            const payload = JSON.parse(retriedTask.payload);
            console.log(`Retrying workflow for audio_processing task ${retriedTask.id}`);
            await this.handleAudioProcessing({
              ...payload,
              taskId: retriedTask.id
            });
            await this.repository.update(retriedTask.id, { status: "running" });
          } else {
            console.log(`Task ${retriedTask.id} reset to pending, will be processed in next batch`);
          }
        } catch (error3) {
          console.error(`Failed to retry workflow for task ${retriedTask.id}:`, error3);
          await this.repository.update(retriedTask.id, {
            status: "failed",
            error: error3 instanceof Error ? error3.message : String(error3)
          });
          throw error3;
        }
        return retriedTask;
      }
      // Method for task handlers to update progress
      async updateTaskProgress(taskId, progress, message2) {
        console.log(`Updating task ${taskId} progress to ${progress}%`);
        const updates = { progress };
        if (message2) {
          updates.result = JSON.stringify({ message: message2, progress });
          updates.step = message2;
        }
        return await this.repository.updateStatus(taskId, "processing", updates);
      }
      // Method for workflows to update task status
      async updateTaskStatus(taskId, status, options = {}) {
        console.log(`Updating task ${taskId} status to ${status}`);
        const updates = {};
        if (options.message) {
          if (status === "failed") {
            updates.error = options.message;
          } else {
            updates.result = JSON.stringify({ message: options.message, status });
          }
        }
        return await this.repository.updateStatus(taskId, status, updates);
      }
      async handleAudioProcessing(payload) {
        console.log(`handleAudioProcessing called with workflow: ${!!this.audioProcessingWorkflow}`);
        if (!this.audioProcessingWorkflow) {
          console.error("Audio processing workflow is null/undefined");
          throw new Error("Audio processing workflow not available");
        }
        const { taskId, episodeId, audioR2Key } = payload;
        if (!episodeId || !audioR2Key) {
          throw new Error("Episode ID and audio R2 key are required for audio processing");
        }
        console.log(`Creating audio processing workflow for episode ${episodeId} (task ${taskId})`);
        try {
          if (taskId) {
            await this.repository.updateStatus(taskId, "processing", {
              startedAt: (/* @__PURE__ */ new Date()).toISOString()
            });
            console.log(`Task ${taskId} status updated to processing`);
          }
          const { workflow, instanceId } = await this.workflowService.createWorkflow(taskId || 0, "audio-processing", {
            ...payload,
            workflowId: void 0
            // Will be set by the workflow service
          }, this.audioProcessingWorkflow);
          console.log(`Audio processing workflow created: ${workflow.id} (instance: ${instanceId})`);
          if (taskId) {
            await this.repository.update(taskId, {
              workflowId: workflow.id,
              workflowInstanceId: instanceId
            });
          }
        } catch (error3) {
          console.error("Failed to create audio processing workflow:", error3);
          throw error3;
        }
      }
      async handleImportShow(payload) {
        console.log(`handleImportShow called with workflow: ${!!this.importShowWorkflow}`);
        if (!this.importShowWorkflow) {
          console.error("Import show workflow is null/undefined");
          throw new Error("Import show workflow not available");
        }
        const { taskId, rssUrl } = payload;
        if (!rssUrl) {
          throw new Error("RSS URL is required for import show");
        }
        console.log(`Creating import show workflow for RSS ${rssUrl} (task ${taskId})`);
        try {
          if (taskId) {
            await this.repository.updateStatus(taskId, "processing", {
              startedAt: (/* @__PURE__ */ new Date()).toISOString()
            });
            console.log(`Task ${taskId} status updated to processing`);
          }
          const { workflow, instanceId } = await this.workflowService.createWorkflow(taskId || 0, "import-show", {
            ...payload,
            workflowId: void 0
            // Will be set by the workflow service
          }, this.importShowWorkflow);
          console.log(`Import show workflow created: ${workflow.id} (instance: ${instanceId})`);
          if (taskId) {
            await this.repository.update(taskId, {
              workflowId: workflow.id,
              workflowInstanceId: instanceId
            });
          }
        } catch (error3) {
          console.error("Failed to create import show workflow:", error3);
          throw error3;
        }
      }
      async updateTaskStep(taskId, step, progress) {
        try {
          await this.repository.updateStep(taskId, step, progress);
          console.log(`Task ${taskId} step updated to: ${step}${progress !== void 0 ? ` (${progress}%)` : ""}`);
        } catch (error3) {
          console.error(`Failed to update task ${taskId} step:`, error3);
          throw error3;
        }
      }
    };
  }
});

// dist/workflows/import-show/types.js
var types_exports = {};
__export(types_exports, {
  EpisodeProcessingResultSchema: () => EpisodeProcessingResultSchema,
  ImportShowParamsSchema: () => ImportShowParamsSchema,
  ImportShowWorkflowStateSchema: () => ImportShowWorkflowStateSchema,
  RSSEpisodeSchema: () => RSSEpisodeSchema,
  RSSShowSchema: () => RSSShowSchema,
  ShowCreationResultSchema: () => ShowCreationResultSchema
});
var RSSEpisodeSchema, RSSShowSchema, ImportShowParamsSchema, ImportShowWorkflowStateSchema, EpisodeProcessingResultSchema, ShowCreationResultSchema;
var init_types2 = __esm({
  "dist/workflows/import-show/types.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_zod();
    RSSEpisodeSchema = external_exports.object({
      title: external_exports.string(),
      description: external_exports.string(),
      audioUrl: external_exports.string().url(),
      imageUrl: external_exports.string().url().nullable().optional(),
      publishedAt: external_exports.string().datetime().nullable().optional(),
      duration: external_exports.number().positive().nullable().optional(),
      episodeNumber: external_exports.number().int().nonnegative().nullable().optional(),
      seasonNumber: external_exports.number().int().nonnegative().nullable().optional(),
      episodeType: external_exports.string().nullable().optional(),
      author: external_exports.string().nullable().optional(),
      subtitle: external_exports.string().nullable().optional(),
      explicit: external_exports.boolean().nullable().optional(),
      keywords: external_exports.array(external_exports.string()).nullable().optional()
    });
    RSSShowSchema = external_exports.object({
      title: external_exports.string(),
      description: external_exports.string(),
      imageUrl: external_exports.string().url().nullable().optional(),
      language: external_exports.string().optional(),
      categories: external_exports.array(external_exports.string()).optional(),
      author: external_exports.string().optional(),
      episodes: external_exports.array(RSSEpisodeSchema)
    });
    ImportShowParamsSchema = external_exports.object({
      rssUrl: external_exports.string().url("Invalid RSS URL"),
      taskId: external_exports.string().optional(),
      workflowId: external_exports.string().optional(),
      skipExistingEpisodes: external_exports.boolean().optional().default(false),
      maxEpisodes: external_exports.number().int().positive().optional().default(100)
    });
    ImportShowWorkflowStateSchema = external_exports.object({
      workflowId: external_exports.string().uuid(),
      rssUrl: external_exports.string().url(),
      taskId: external_exports.string().optional(),
      startedAt: external_exports.string().datetime(),
      skipExistingEpisodes: external_exports.boolean(),
      maxEpisodes: external_exports.number().int().positive(),
      showId: external_exports.string().uuid().optional(),
      // Set after show creation
      totalEpisodes: external_exports.number().int().nonnegative().optional(),
      processedEpisodes: external_exports.number().int().nonnegative().optional().default(0)
    });
    EpisodeProcessingResultSchema = external_exports.object({
      episodeId: external_exports.string().uuid(),
      title: external_exports.string(),
      status: external_exports.enum(["created", "skipped", "failed"]),
      error: external_exports.string().optional(),
      audioR2Key: external_exports.string().optional(),
      audioProcessingTaskId: external_exports.string().optional()
    });
    ShowCreationResultSchema = external_exports.object({
      showId: external_exports.string().uuid(),
      title: external_exports.string(),
      description: external_exports.string(),
      imageUrl: external_exports.string().nullable().optional(),
      totalEpisodes: external_exports.number().int().nonnegative()
    });
  }
});

// dist/shows/repository.js
var repository_exports2 = {};
__export(repository_exports2, {
  ShowRepository: () => ShowRepository
});
var ShowRepository;
var init_repository3 = __esm({
  "dist/shows/repository.js"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_drizzle_orm();
    init_client();
    init_schema3();
    init_errors2();
    ShowRepository = class {
      static {
        __name(this, "ShowRepository");
      }
      db;
      constructor(database) {
        this.db = getDatabase(database);
      }
      async findAll({ limit, offset }, organizationId) {
        const results = await this.db.select().from(shows).where(eq(shows.organizationId, organizationId)).limit(limit).offset(offset).orderBy(shows.createdAt);
        return results.map((show) => ({
          ...show,
          categories: show.categories ? JSON.parse(show.categories) : null
        }));
      }
      async findById(id, organizationId) {
        const result = await this.db.select().from(shows).where(and(eq(shows.id, id), eq(shows.organizationId, organizationId))).limit(1);
        const show = result[0] || null;
        if (!show)
          return null;
        return {
          ...show,
          categories: show.categories ? JSON.parse(show.categories) : null
        };
      }
      // Public method for RSS feeds - finds show by ID without organization context
      async findByIdPublic(id) {
        const result = await this.db.select().from(shows).where(eq(shows.id, id)).limit(1);
        const show = result[0] || null;
        if (!show)
          return null;
        return {
          ...show,
          categories: show.categories ? JSON.parse(show.categories) : null
        };
      }
      async create(data) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const newShow = {
          ...data,
          categories: data.categories ? JSON.stringify(data.categories) : null,
          createdAt: now,
          updatedAt: now
        };
        await this.db.insert(shows).values(newShow);
        return {
          ...newShow,
          categories: data.categories || null
        };
      }
      async update(id, data, organizationId) {
        const existing = await this.findById(id, organizationId);
        if (!existing) {
          throw new NotFoundError("Show not found");
        }
        const updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        const updateData = {
          ...data,
          categories: data.categories ? JSON.stringify(data.categories) : void 0,
          updatedAt
        };
        await this.db.update(shows).set(updateData).where(and(eq(shows.id, id), eq(shows.organizationId, organizationId)));
        const updatedShow = {
          ...existing,
          ...data,
          updatedAt
        };
        return updatedShow;
      }
      async delete(id, organizationId) {
        const existing = await this.findById(id, organizationId);
        if (!existing) {
          throw new NotFoundError("Show not found");
        }
        await this.db.delete(shows).where(and(eq(shows.id, id), eq(shows.organizationId, organizationId)));
        return true;
      }
    };
  }
});

// .wrangler/tmp/bundle-wvXYCG/middleware-loader.entry.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-wvXYCG/middleware-insertion-facade.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/worker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/app.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@hono/zod-openapi/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@asteasolutions/zod-to-openapi/dist/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function __rest(s, e) {
  var t = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
    t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
}
__name(__rest, "__rest");
function isZodType(schema, typeName) {
  var _a2;
  return ((_a2 = schema === null || schema === void 0 ? void 0 : schema._def) === null || _a2 === void 0 ? void 0 : _a2.typeName) === typeName;
}
__name(isZodType, "isZodType");
function isAnyZodType(schema) {
  return "_def" in schema;
}
__name(isAnyZodType, "isAnyZodType");
function preserveMetadataFromModifier(zod, modifier) {
  const zodModifier = zod.ZodType.prototype[modifier];
  zod.ZodType.prototype[modifier] = function(...args) {
    const result = zodModifier.apply(this, args);
    result._def.openapi = this._def.openapi;
    return result;
  };
}
__name(preserveMetadataFromModifier, "preserveMetadataFromModifier");
function extendZodWithOpenApi(zod) {
  if (typeof zod.ZodType.prototype.openapi !== "undefined") {
    return;
  }
  zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
    var _a2, _b, _c, _d, _e, _f;
    const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
    const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, ["param"]);
    const _internal = Object.assign(Object.assign({}, (_a2 = this._def.openapi) === null || _a2 === void 0 ? void 0 : _a2._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : void 0);
    const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === void 0 ? void 0 : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.param) || param ? {
      param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === void 0 ? void 0 : _e.metadata) === null || _f === void 0 ? void 0 : _f.param), param)
    } : void 0);
    const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : void 0), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : void 0) }));
    if (isZodType(this, "ZodObject")) {
      const originalExtend = this.extend;
      result.extend = function(...args) {
        var _a3, _b2, _c2, _d2, _e2, _f2, _g2;
        const extendedResult = originalExtend.apply(this, args);
        extendedResult._def.openapi = {
          _internal: {
            extendedFrom: ((_b2 = (_a3 = this._def.openapi) === null || _a3 === void 0 ? void 0 : _a3._internal) === null || _b2 === void 0 ? void 0 : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === void 0 ? void 0 : _c2._internal) === null || _d2 === void 0 ? void 0 : _d2.refId, schema: this } : (_f2 = (_e2 = this._def.openapi) === null || _e2 === void 0 ? void 0 : _e2._internal) === null || _f2 === void 0 ? void 0 : _f2.extendedFrom
          },
          metadata: (_g2 = extendedResult._def.openapi) === null || _g2 === void 0 ? void 0 : _g2.metadata
        };
        return extendedResult;
      };
    }
    return result;
  };
  preserveMetadataFromModifier(zod, "optional");
  preserveMetadataFromModifier(zod, "nullable");
  preserveMetadataFromModifier(zod, "default");
  preserveMetadataFromModifier(zod, "transform");
  preserveMetadataFromModifier(zod, "refine");
  const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
  zod.ZodObject.prototype.deepPartial = function() {
    const initialShape = this._def.shape();
    const result = zodDeepPartial.apply(this);
    const resultShape = result._def.shape();
    Object.entries(resultShape).forEach(([key, value]) => {
      var _a2, _b;
      value._def.openapi = (_b = (_a2 = initialShape[key]) === null || _a2 === void 0 ? void 0 : _a2._def) === null || _b === void 0 ? void 0 : _b.openapi;
    });
    result._def.openapi = void 0;
    return result;
  };
  const zodPick = zod.ZodObject.prototype.pick;
  zod.ZodObject.prototype.pick = function(...args) {
    const result = zodPick.apply(this, args);
    result._def.openapi = void 0;
    return result;
  };
  const zodOmit = zod.ZodObject.prototype.omit;
  zod.ZodObject.prototype.omit = function(...args) {
    const result = zodOmit.apply(this, args);
    result._def.openapi = void 0;
    return result;
  };
}
__name(extendZodWithOpenApi, "extendZodWithOpenApi");
function isEqual(x, y) {
  if (x === null || x === void 0 || y === null || y === void 0) {
    return x === y;
  }
  if (x === y || x.valueOf() === y.valueOf()) {
    return true;
  }
  if (Array.isArray(x)) {
    if (!Array.isArray(y)) {
      return false;
    }
    if (x.length !== y.length) {
      return false;
    }
  }
  if (!(x instanceof Object) || !(y instanceof Object)) {
    return false;
  }
  const keysX = Object.keys(x);
  return Object.keys(y).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x[key], y[key]));
}
__name(isEqual, "isEqual");
var ObjectSet = class {
  static {
    __name(this, "ObjectSet");
  }
  constructor() {
    this.buckets = /* @__PURE__ */ new Map();
  }
  put(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      this.buckets.set(hashCode, [value]);
      return;
    }
    const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
    if (!alreadyHasItem) {
      itemsByCode.push(value);
    }
  }
  contains(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      return false;
    }
    return itemsByCode.some((_) => isEqual(_, value));
  }
  values() {
    return [...this.buckets.values()].flat();
  }
  stats() {
    let totalBuckets = 0;
    let totalValues = 0;
    let collisions = 0;
    for (const bucket of this.buckets.values()) {
      totalBuckets += 1;
      totalValues += bucket.length;
      if (bucket.length > 1) {
        collisions += 1;
      }
    }
    const hashEffectiveness = totalBuckets / totalValues;
    return { totalBuckets, collisions, totalValues, hashEffectiveness };
  }
  hashCodeOf(object) {
    let hashCode = 0;
    if (Array.isArray(object)) {
      for (let i = 0; i < object.length; i++) {
        hashCode ^= this.hashCodeOf(object[i]) * i;
      }
      return hashCode;
    }
    if (typeof object === "string") {
      for (let i = 0; i < object.length; i++) {
        hashCode ^= object.charCodeAt(i) * i;
      }
      return hashCode;
    }
    if (typeof object === "number") {
      return object;
    }
    if (typeof object === "object") {
      for (const [key, value] of Object.entries(object)) {
        hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== void 0 ? value : "");
      }
    }
    return hashCode;
  }
};
function isUndefined(value) {
  return value === void 0;
}
__name(isUndefined, "isUndefined");
function mapValues(object, mapper) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    result[key] = mapper(value);
  });
  return result;
}
__name(mapValues, "mapValues");
function omit(object, keys) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    if (!keys.some((keyToOmit) => keyToOmit === key)) {
      result[key] = value;
    }
  });
  return result;
}
__name(omit, "omit");
function omitBy(object, predicate) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    if (!predicate(value, key)) {
      result[key] = value;
    }
  });
  return result;
}
__name(omitBy, "omitBy");
function compact(arr) {
  return arr.filter((elem) => !isUndefined(elem));
}
__name(compact, "compact");
var objectEquals = isEqual;
function uniq(values) {
  const set = new ObjectSet();
  values.forEach((value) => set.put(value));
  return [...set.values()];
}
__name(uniq, "uniq");
function isString(val) {
  return typeof val === "string";
}
__name(isString, "isString");
var OpenAPIRegistry = class {
  static {
    __name(this, "OpenAPIRegistry");
  }
  constructor(parents) {
    this.parents = parents;
    this._definitions = [];
  }
  get definitions() {
    var _a2, _b;
    const parentDefinitions = (_b = (_a2 = this.parents) === null || _a2 === void 0 ? void 0 : _a2.flatMap((par) => par.definitions)) !== null && _b !== void 0 ? _b : [];
    return [...parentDefinitions, ...this._definitions];
  }
  /**
   * Registers a new component schema under /components/schemas/${name}
   */
  register(refId, zodSchema) {
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    this._definitions.push({ type: "schema", schema: schemaWithRefId });
    return schemaWithRefId;
  }
  /**
   * Registers a new parameter schema under /components/parameters/${name}
   */
  registerParameter(refId, zodSchema) {
    var _a2, _b, _c;
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    const currentMetadata = (_a2 = schemaWithRefId._def.openapi) === null || _a2 === void 0 ? void 0 : _a2.metadata;
    const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : refId }) }));
    this._definitions.push({
      type: "parameter",
      schema: schemaWithMetadata
    });
    return schemaWithMetadata;
  }
  /**
   * Registers a new path that would be generated under paths:
   */
  registerPath(route) {
    this._definitions.push({
      type: "route",
      route
    });
  }
  /**
   * Registers a new webhook that would be generated under webhooks:
   */
  registerWebhook(webhook) {
    this._definitions.push({
      type: "webhook",
      webhook
    });
  }
  /**
   * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.
   *
   * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.
   * @param name The name of the object, it is the key under the component
   *             type in the resulting OpenAPI document
   * @param component The actual object to put there
   */
  registerComponent(type, name, component) {
    this._definitions.push({
      type: "component",
      componentType: type,
      name,
      component
    });
    return {
      name,
      ref: { $ref: `#/components/${type}/${name}` }
    };
  }
  schemaWithRefId(refId, zodSchema) {
    return zodSchema.openapi(refId);
  }
};
var ZodToOpenAPIError = class {
  static {
    __name(this, "ZodToOpenAPIError");
  }
  constructor(message2) {
    this.message = message2;
  }
};
var ConflictError = class extends ZodToOpenAPIError {
  static {
    __name(this, "ConflictError");
  }
  constructor(message2, data) {
    super(message2);
    this.data = data;
  }
};
var MissingParameterDataError = class extends ZodToOpenAPIError {
  static {
    __name(this, "MissingParameterDataError");
  }
  constructor(data) {
    super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
    this.data = data;
  }
};
function enhanceMissingParametersError(action, paramsToAdd) {
  try {
    return action();
  } catch (error3) {
    if (error3 instanceof MissingParameterDataError) {
      throw new MissingParameterDataError(Object.assign(Object.assign({}, error3.data), paramsToAdd));
    }
    throw error3;
  }
}
__name(enhanceMissingParametersError, "enhanceMissingParametersError");
var UnknownZodTypeError = class extends ZodToOpenAPIError {
  static {
    __name(this, "UnknownZodTypeError");
  }
  constructor(data) {
    super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
    this.data = data;
  }
};
var Metadata = class {
  static {
    __name(this, "Metadata");
  }
  static getMetadata(zodSchema) {
    var _a2;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a2 = zodSchema.description) !== null && _a2 !== void 0 ? _a2 : innerSchema.description;
    return {
      _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
      metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
    };
  }
  static getInternalMetadata(zodSchema) {
    const innerSchema = this.unwrapChained(zodSchema);
    const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
  }
  static getParamMetadata(zodSchema) {
    var _a2, _b;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a2 = zodSchema.description) !== null && _a2 !== void 0 ? _a2 : innerSchema.description;
    return {
      _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
      metadata: Object.assign(Object.assign({}, metadata === null || metadata === void 0 ? void 0 : metadata.metadata), {
        // A description provided from .openapi() should be taken with higher precedence
        param: Object.assign({ description: zodDescription }, (_b = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _b === void 0 ? void 0 : _b.param)
      })
    };
  }
  /**
   * A method that omits all custom keys added to the regular OpenAPI
   * metadata properties
   */
  static buildSchemaMetadata(metadata) {
    return omitBy(omit(metadata, ["param"]), isUndefined);
  }
  static buildParameterMetadata(metadata) {
    return omitBy(metadata, isUndefined);
  }
  static applySchemaMetadata(initialData, metadata) {
    return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), isUndefined);
  }
  static getRefId(zodSchema) {
    var _a2;
    return (_a2 = this.getInternalMetadata(zodSchema)) === null || _a2 === void 0 ? void 0 : _a2.refId;
  }
  static unwrapChained(schema) {
    return this.unwrapUntil(schema);
  }
  static getDefaultValue(zodSchema) {
    const unwrapped = this.unwrapUntil(zodSchema, "ZodDefault");
    return unwrapped === null || unwrapped === void 0 ? void 0 : unwrapped._def.defaultValue();
  }
  static unwrapUntil(schema, typeName) {
    if (typeName && isZodType(schema, typeName)) {
      return schema;
    }
    if (isZodType(schema, "ZodOptional") || isZodType(schema, "ZodNullable") || isZodType(schema, "ZodBranded")) {
      return this.unwrapUntil(schema.unwrap(), typeName);
    }
    if (isZodType(schema, "ZodDefault") || isZodType(schema, "ZodReadonly")) {
      return this.unwrapUntil(schema._def.innerType, typeName);
    }
    if (isZodType(schema, "ZodEffects")) {
      return this.unwrapUntil(schema._def.schema, typeName);
    }
    if (isZodType(schema, "ZodPipeline")) {
      return this.unwrapUntil(schema._def.in, typeName);
    }
    return typeName ? void 0 : schema;
  }
  static isOptionalSchema(zodSchema) {
    return zodSchema.isOptional();
  }
};
var ArrayTransformer = class {
  static {
    __name(this, "ArrayTransformer");
  }
  transform(zodSchema, mapNullableType, mapItems) {
    var _a2, _b;
    const itemType = zodSchema._def.type;
    return Object.assign(Object.assign({}, mapNullableType("array")), { items: mapItems(itemType), minItems: (_a2 = zodSchema._def.minLength) === null || _a2 === void 0 ? void 0 : _a2.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === void 0 ? void 0 : _b.value });
  }
};
var BigIntTransformer = class {
  static {
    __name(this, "BigIntTransformer");
  }
  transform(mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { pattern: `^d+$` });
  }
};
var DiscriminatedUnionTransformer = class {
  static {
    __name(this, "DiscriminatedUnionTransformer");
  }
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {
    const options = [...zodSchema.options.values()];
    const optionSchema = options.map(mapItem);
    if (isNullable) {
      return {
        oneOf: mapNullableOfArray(optionSchema, isNullable)
      };
    }
    return {
      oneOf: optionSchema,
      discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef)
    };
  }
  mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {
    if (zodObjects.some((obj) => Metadata.getRefId(obj) === void 0)) {
      return void 0;
    }
    const mapping = {};
    zodObjects.forEach((obj) => {
      var _a2;
      const refId = Metadata.getRefId(obj);
      const value = (_a2 = obj.shape) === null || _a2 === void 0 ? void 0 : _a2[discriminator];
      if (isZodType(value, "ZodEnum") || isZodType(value, "ZodNativeEnum")) {
        const keys = Object.values(value.enum).filter(isString);
        keys.forEach((enumValue) => {
          mapping[enumValue] = generateSchemaRef(refId);
        });
        return;
      }
      const literalValue = value === null || value === void 0 ? void 0 : value._def.value;
      if (typeof literalValue !== "string") {
        throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
      }
      mapping[literalValue] = generateSchemaRef(refId);
    });
    return {
      propertyName: discriminator,
      mapping
    };
  }
};
var EnumTransformer = class {
  static {
    __name(this, "EnumTransformer");
  }
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { enum: zodSchema._def.values });
  }
};
var IntersectionTransformer = class {
  static {
    __name(this, "IntersectionTransformer");
  }
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {
    const subtypes = this.flattenIntersectionTypes(zodSchema);
    const allOfSchema = {
      allOf: subtypes.map(mapItem)
    };
    if (isNullable) {
      return {
        anyOf: mapNullableOfArray([allOfSchema], isNullable)
      };
    }
    return allOfSchema;
  }
  flattenIntersectionTypes(schema) {
    if (!isZodType(schema, "ZodIntersection")) {
      return [schema];
    }
    const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
    const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
    return [...leftSubTypes, ...rightSubTypes];
  }
};
var LiteralTransformer = class {
  static {
    __name(this, "LiteralTransformer");
  }
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });
  }
};
function enumInfo(enumObject) {
  const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
  const values = keysExceptReverseMappings.map((key) => enumObject[key]);
  const numericCount = values.filter((_) => typeof _ === "number").length;
  const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
  return { values, type };
}
__name(enumInfo, "enumInfo");
var NativeEnumTransformer = class {
  static {
    __name(this, "NativeEnumTransformer");
  }
  transform(zodSchema, mapNullableType) {
    const { type, values } = enumInfo(zodSchema._def.values);
    if (type === "mixed") {
      throw new ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
    }
    return Object.assign(Object.assign({}, mapNullableType(type === "numeric" ? "integer" : "string")), { enum: values });
  }
};
var NumberTransformer = class {
  static {
    __name(this, "NumberTransformer");
  }
  transform(zodSchema, mapNullableType, getNumberChecks) {
    return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? "integer" : "number")), getNumberChecks(zodSchema._def.checks));
  }
};
var ObjectTransformer = class {
  static {
    __name(this, "ObjectTransformer");
  }
  transform(zodSchema, defaultValue, mapNullableType, mapItem) {
    var _a2;
    const extendedFrom = (_a2 = Metadata.getInternalMetadata(zodSchema)) === null || _a2 === void 0 ? void 0 : _a2.extendedFrom;
    const required = this.requiredKeysOf(zodSchema);
    const properties = mapValues(zodSchema._def.shape(), mapItem);
    if (!extendedFrom) {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { properties, default: defaultValue }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    }
    const parent = extendedFrom.schema;
    mapItem(parent);
    const keysRequiredByParent = this.requiredKeysOf(parent);
    const propsOfParent = mapValues(parent === null || parent === void 0 ? void 0 : parent._def.shape(), mapItem);
    const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
      return !objectEquals(propsOfParent[key], type);
    }));
    const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
    const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    return {
      allOf: [
        { $ref: `#/components/schemas/${extendedFrom.refId}` },
        objectData
      ]
    };
  }
  generateAdditionalProperties(zodSchema, mapItem) {
    const unknownKeysOption = zodSchema._def.unknownKeys;
    const catchallSchema = zodSchema._def.catchall;
    if (isZodType(catchallSchema, "ZodNever")) {
      if (unknownKeysOption === "strict") {
        return { additionalProperties: false };
      }
      return {};
    }
    return { additionalProperties: mapItem(catchallSchema) };
  }
  requiredKeysOf(objectSchema) {
    return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !Metadata.isOptionalSchema(type)).map(([key, _type]) => key);
  }
};
var RecordTransformer = class {
  static {
    __name(this, "RecordTransformer");
  }
  transform(zodSchema, mapNullableType, mapItem) {
    const propertiesType = zodSchema._def.valueType;
    const keyType = zodSchema._def.keyType;
    const propertiesSchema = mapItem(propertiesType);
    if (isZodType(keyType, "ZodEnum") || isZodType(keyType, "ZodNativeEnum")) {
      const keys = Object.values(keyType.enum).filter(isString);
      const properties = keys.reduce((acc, curr) => Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema }), {});
      return Object.assign(Object.assign({}, mapNullableType("object")), { properties });
    }
    return Object.assign(Object.assign({}, mapNullableType("object")), { additionalProperties: propertiesSchema });
  }
};
var StringTransformer = class {
  static {
    __name(this, "StringTransformer");
  }
  transform(zodSchema, mapNullableType) {
    var _a2, _b, _c;
    const regexCheck = this.getZodStringCheck(zodSchema, "regex");
    const length = (_a2 = this.getZodStringCheck(zodSchema, "length")) === null || _a2 === void 0 ? void 0 : _a2.value;
    const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== void 0 ? _b : void 0 : void 0;
    const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== void 0 ? _c : void 0 : void 0;
    return Object.assign(Object.assign({}, mapNullableType("string")), {
      // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
      minLength: length !== null && length !== void 0 ? length : maxLength,
      maxLength: length !== null && length !== void 0 ? length : minLength,
      format: this.mapStringFormat(zodSchema),
      pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source
    });
  }
  /**
   * Attempts to map Zod strings to known formats
   * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
   */
  mapStringFormat(zodString) {
    if (zodString.isUUID)
      return "uuid";
    if (zodString.isEmail)
      return "email";
    if (zodString.isURL)
      return "uri";
    if (zodString.isDate)
      return "date";
    if (zodString.isDatetime)
      return "date-time";
    if (zodString.isCUID)
      return "cuid";
    if (zodString.isCUID2)
      return "cuid2";
    if (zodString.isULID)
      return "ulid";
    if (zodString.isIP)
      return "ip";
    if (zodString.isEmoji)
      return "emoji";
    return void 0;
  }
  getZodStringCheck(zodString, kind) {
    return zodString._def.checks.find((check) => {
      return check.kind === kind;
    });
  }
};
var TupleTransformer = class {
  static {
    __name(this, "TupleTransformer");
  }
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
  }
  transform(zodSchema, mapNullableType, mapItem) {
    const { items } = zodSchema._def;
    const schemas = items.map(mapItem);
    return Object.assign(Object.assign({}, mapNullableType("array")), this.versionSpecifics.mapTupleItems(schemas));
  }
};
var UnionTransformer = class {
  static {
    __name(this, "UnionTransformer");
  }
  transform(zodSchema, mapNullableOfArray, mapItem) {
    const options = this.flattenUnionTypes(zodSchema);
    const schemas = options.map((schema) => {
      const optionToGenerate = this.unwrapNullable(schema);
      return mapItem(optionToGenerate);
    });
    return {
      anyOf: mapNullableOfArray(schemas)
    };
  }
  flattenUnionTypes(schema) {
    if (!isZodType(schema, "ZodUnion")) {
      return [schema];
    }
    const options = schema._def.options;
    return options.flatMap((option) => this.flattenUnionTypes(option));
  }
  unwrapNullable(schema) {
    if (isZodType(schema, "ZodNullable")) {
      return this.unwrapNullable(schema.unwrap());
    }
    return schema;
  }
};
var OpenApiTransformer = class {
  static {
    __name(this, "OpenApiTransformer");
  }
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
    this.objectTransformer = new ObjectTransformer();
    this.stringTransformer = new StringTransformer();
    this.numberTransformer = new NumberTransformer();
    this.bigIntTransformer = new BigIntTransformer();
    this.literalTransformer = new LiteralTransformer();
    this.enumTransformer = new EnumTransformer();
    this.nativeEnumTransformer = new NativeEnumTransformer();
    this.arrayTransformer = new ArrayTransformer();
    this.unionTransformer = new UnionTransformer();
    this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer();
    this.intersectionTransformer = new IntersectionTransformer();
    this.recordTransformer = new RecordTransformer();
    this.tupleTransformer = new TupleTransformer(versionSpecifics);
  }
  transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {
    if (isZodType(zodSchema, "ZodNull")) {
      return this.versionSpecifics.nullType;
    }
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(void 0, isNullable);
    }
    if (isZodType(zodSchema, "ZodObject")) {
      return this.objectTransformer.transform(
        zodSchema,
        defaultValue,
        // verified on TS level from input
        // verified on TS level from input
        (_) => this.versionSpecifics.mapNullableType(_, isNullable),
        mapItem
      );
    }
    const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);
    return Object.assign(Object.assign({}, schema), { default: defaultValue });
  }
  transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(void 0, isNullable);
    }
    if (isZodType(zodSchema, "ZodString")) {
      return this.stringTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNumber")) {
      return this.numberTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable), (_) => this.versionSpecifics.getNumberChecks(_));
    }
    if (isZodType(zodSchema, "ZodBigInt")) {
      return this.bigIntTransformer.transform((schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodBoolean")) {
      return this.versionSpecifics.mapNullableType("boolean", isNullable);
    }
    if (isZodType(zodSchema, "ZodLiteral")) {
      return this.literalTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodEnum")) {
      return this.enumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNativeEnum")) {
      return this.nativeEnumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodArray")) {
      return this.arrayTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodTuple")) {
      return this.tupleTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodUnion")) {
      return this.unionTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDiscriminatedUnion")) {
      return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem, generateSchemaRef);
    }
    if (isZodType(zodSchema, "ZodIntersection")) {
      return this.intersectionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodRecord")) {
      return this.recordTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDate")) {
      return this.versionSpecifics.mapNullableType("string", isNullable);
    }
    const refId = Metadata.getRefId(zodSchema);
    throw new UnknownZodTypeError({
      currentSchema: zodSchema._def,
      schemaName: refId
    });
  }
};
var OpenAPIGenerator = class {
  static {
    __name(this, "OpenAPIGenerator");
  }
  constructor(definitions, versionSpecifics) {
    this.definitions = definitions;
    this.versionSpecifics = versionSpecifics;
    this.schemaRefs = {};
    this.paramRefs = {};
    this.pathRefs = {};
    this.rawComponents = [];
    this.openApiTransformer = new OpenApiTransformer(versionSpecifics);
    this.sortDefinitions();
  }
  generateDocumentData() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents(),
      paths: this.pathRefs
    };
  }
  generateComponents() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents()
    };
  }
  buildComponents() {
    var _a2, _b;
    const rawComponents = {};
    this.rawComponents.forEach(({ componentType, name, component }) => {
      var _a3;
      (_a3 = rawComponents[componentType]) !== null && _a3 !== void 0 ? _a3 : rawComponents[componentType] = {};
      rawComponents[componentType][name] = component;
    });
    return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a2 = rawComponents.schemas) !== null && _a2 !== void 0 ? _a2 : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {}), this.paramRefs) });
  }
  sortDefinitions() {
    const generationOrder = [
      "schema",
      "parameter",
      "component",
      "route"
    ];
    this.definitions.sort((left, right) => {
      if (!("type" in left)) {
        if (!("type" in right)) {
          return 0;
        }
        return -1;
      }
      if (!("type" in right)) {
        return 1;
      }
      const leftIndex = generationOrder.findIndex((type) => type === left.type);
      const rightIndex = generationOrder.findIndex((type) => type === right.type);
      return leftIndex - rightIndex;
    });
  }
  generateSingle(definition) {
    if (!("type" in definition)) {
      this.generateSchemaWithRef(definition);
      return;
    }
    switch (definition.type) {
      case "parameter":
        this.generateParameterDefinition(definition.schema);
        return;
      case "schema":
        this.generateSchemaWithRef(definition.schema);
        return;
      case "route":
        this.generateSingleRoute(definition.route);
        return;
      case "component":
        this.rawComponents.push(definition);
        return;
    }
  }
  generateParameterDefinition(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateParameter(zodSchema);
    if (refId) {
      this.paramRefs[refId] = result;
    }
    return result;
  }
  getParameterRef(schemaMetadata, external) {
    var _a2, _b, _c, _d, _e;
    const parameterMetadata = (_a2 = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId] : void 0;
    if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
      return void 0;
    }
    if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in) {
      throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
        key: "in",
        values: compact([
          existingRef.in,
          external === null || external === void 0 ? void 0 : external.in,
          parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in
        ])
      });
    }
    if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name)) {
      throw new ConflictError(`Conflicting names for parameter`, {
        key: "name",
        values: compact([
          existingRef.name,
          external === null || external === void 0 ? void 0 : external.name,
          parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name
        ])
      });
    }
    return {
      $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === void 0 ? void 0 : _e.refId}`
    };
  }
  generateInlineParameters(zodSchema, location) {
    var _a2;
    const metadata = Metadata.getMetadata(zodSchema);
    const parameterMetadata = (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const referencedSchema = this.getParameterRef(metadata, { in: location });
    if (referencedSchema) {
      return [referencedSchema];
    }
    if (isZodType(zodSchema, "ZodObject")) {
      const propTypes = zodSchema._def.shape();
      const parameters = Object.entries(propTypes).map(([key, schema]) => {
        var _a3, _b;
        const innerMetadata = Metadata.getMetadata(schema);
        const referencedSchema2 = this.getParameterRef(innerMetadata, {
          in: location,
          name: key
        });
        if (referencedSchema2) {
          return referencedSchema2;
        }
        const innerParameterMetadata = (_a3 = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a3 === void 0 ? void 0 : _a3.param;
        if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
          throw new ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: [key, innerParameterMetadata.name]
          });
        }
        if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
          throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key}`, {
            key: "in",
            values: [location, innerParameterMetadata.in]
          });
        }
        return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
      });
      return parameters;
    }
    if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
      throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
        key: "in",
        values: [location, parameterMetadata.in]
      });
    }
    return [
      this.generateParameter(zodSchema.openapi({ param: { in: location } }))
    ];
  }
  generateSimpleParameter(zodSchema) {
    var _a2;
    const metadata = Metadata.getParamMetadata(zodSchema);
    const paramMetadata = (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
    const schema = this.generateSchemaWithRef(zodSchema);
    return Object.assign({
      schema,
      required
    }, paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {});
  }
  generateParameter(zodSchema) {
    var _a2;
    const metadata = Metadata.getMetadata(zodSchema);
    const paramMetadata = (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
    const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
    if (!paramName) {
      throw new MissingParameterDataError({ missingField: "name" });
    }
    if (!paramLocation) {
      throw new MissingParameterDataError({
        missingField: "in",
        paramName
      });
    }
    const baseParameter = this.generateSimpleParameter(zodSchema);
    return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
  }
  generateSchemaWithMetadata(zodSchema) {
    var _a2;
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const metadata = Metadata.getMetadata(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const result = ((_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.type) ? { type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
    return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata) ? Metadata.applySchemaMetadata(result, metadata.metadata) : omitBy(result, isUndefined);
  }
  /**
   * Same as above but applies nullable
   */
  constructReferencedOpenAPISchema(zodSchema) {
    var _a2;
    const metadata = Metadata.getMetadata(zodSchema);
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const isNullableSchema = zodSchema.isNullable();
    if ((_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.type) {
      return this.versionSpecifics.mapNullableType(metadata.metadata.type, isNullableSchema);
    }
    return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
  }
  /**
   * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
   */
  generateSimpleSchema(zodSchema) {
    var _a2;
    const metadata = Metadata.getMetadata(zodSchema);
    const refId = Metadata.getRefId(zodSchema);
    if (!refId || !this.schemaRefs[refId]) {
      return this.generateSchemaWithMetadata(zodSchema);
    }
    const schemaRef = this.schemaRefs[refId];
    const referenceObject = {
      $ref: this.generateSchemaRef(refId)
    };
    const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _a2 !== void 0 ? _a2 : {}), (value, key) => value === void 0 || objectEquals(value, schemaRef[key]));
    if (newMetadata.type) {
      return {
        allOf: [referenceObject, newMetadata]
      };
    }
    const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === void 0 || objectEquals(value, schemaRef[key]));
    const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);
    if (Object.keys(appliedMetadata).length > 0) {
      return {
        allOf: [referenceObject, appliedMetadata]
      };
    }
    return referenceObject;
  }
  /**
   * Same as `generateSchema` but if the new schema is added into the
   * referenced schemas, it would return a ReferenceObject and not the
   * whole result.
   *
   * Should be used for nested objects, arrays, etc.
   */
  generateSchemaWithRef(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateSimpleSchema(zodSchema);
    if (refId && this.schemaRefs[refId] === void 0) {
      this.schemaRefs[refId] = result;
      return { $ref: this.generateSchemaRef(refId) };
    }
    return result;
  }
  generateSchemaRef(refId) {
    return `#/components/schemas/${refId}`;
  }
  getRequestBody(requestBody) {
    if (!requestBody) {
      return;
    }
    const { content } = requestBody, rest = __rest(requestBody, ["content"]);
    const requestBodyContent = this.getBodyContent(content);
    return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
  }
  getParameters(request) {
    if (!request) {
      return [];
    }
    const { headers } = request;
    const query = this.cleanParameter(request.query);
    const params = this.cleanParameter(request.params);
    const cookies = this.cleanParameter(request.cookies);
    const queryParameters = enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
    const pathParameters = enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
    const cookieParameters = enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
    const headerParameters = enhanceMissingParametersError(() => {
      if (Array.isArray(headers)) {
        return headers.flatMap((header) => this.generateInlineParameters(header, "header"));
      }
      const cleanHeaders = this.cleanParameter(headers);
      return cleanHeaders ? this.generateInlineParameters(cleanHeaders, "header") : [];
    }, { location: "header" });
    return [
      ...pathParameters,
      ...queryParameters,
      ...headerParameters,
      ...cookieParameters
    ];
  }
  cleanParameter(schema) {
    if (!schema) {
      return void 0;
    }
    return isZodType(schema, "ZodEffects") ? this.cleanParameter(schema._def.schema) : schema;
  }
  generatePath(route) {
    const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
    const generatedResponses = mapValues(responses, (response) => {
      return this.getResponse(response);
    });
    const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
    const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
    const routeDoc = {
      [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
        parameters: [...pathItemConfig.parameters || [], ...parameters]
      } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
    };
    return routeDoc;
  }
  generateSingleRoute(route) {
    const routeDoc = this.generatePath(route);
    this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
    return routeDoc;
  }
  getResponse(response) {
    if (this.isReferenceObject(response)) {
      return response;
    }
    const { content, headers } = response, rest = __rest(response, ["content", "headers"]);
    const responseContent = content ? { content: this.getBodyContent(content) } : {};
    if (!headers) {
      return Object.assign(Object.assign({}, rest), responseContent);
    }
    const responseHeaders = isZodType(headers, "ZodObject") ? this.getResponseHeaders(headers) : (
      // This is input data so it is okay to cast in the common generator
      // since this is the user's responsibility to keep it correct
      headers
    );
    return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
  }
  isReferenceObject(schema) {
    return "$ref" in schema;
  }
  getResponseHeaders(headers) {
    const schemaShape = headers._def.shape();
    const responseHeaders = mapValues(schemaShape, (_) => this.generateSimpleParameter(_));
    return responseHeaders;
  }
  getBodyContent(content) {
    return mapValues(content, (config2) => {
      if (!config2 || !isAnyZodType(config2.schema)) {
        return config2;
      }
      const { schema: configSchema } = config2, rest = __rest(config2, ["schema"]);
      const schema = this.generateSchemaWithRef(configSchema);
      return Object.assign({ schema }, rest);
    });
  }
  toOpenAPISchema(zodSchema, isNullable, defaultValue) {
    return this.openApiTransformer.transform(zodSchema, isNullable, (_) => this.generateSchemaWithRef(_), (_) => this.generateSchemaRef(_), defaultValue);
  }
};
var OpenApiGeneratorV30Specifics = class {
  static {
    __name(this, "OpenApiGeneratorV30Specifics");
  }
  get nullType() {
    return { nullable: true };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    return Object.assign(Object.assign({}, type ? { type } : void 0), isNullable ? this.nullType : void 0);
  }
  mapTupleItems(schemas) {
    const uniqueSchemas = uniq(schemas);
    return {
      items: uniqueSchemas.length === 1 ? uniqueSchemas[0] : { anyOf: uniqueSchemas },
      minItems: schemas.length,
      maxItems: schemas.length
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { minimum: Number(check.value), exclusiveMinimum: true };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { maximum: Number(check.value), exclusiveMaximum: true };
        default:
          return {};
      }
    }));
  }
};
var OpenApiGeneratorV3 = class {
  static {
    __name(this, "OpenApiGeneratorV3");
  }
  constructor(definitions) {
    const specifics = new OpenApiGeneratorV30Specifics();
    this.generator = new OpenAPIGenerator(definitions, specifics);
  }
  generateDocument(config2) {
    const baseData = this.generator.generateDocumentData();
    return Object.assign(Object.assign({}, config2), baseData);
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
};
var OpenApiGeneratorV31Specifics = class {
  static {
    __name(this, "OpenApiGeneratorV31Specifics");
  }
  get nullType() {
    return { type: "null" };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    if (!type) {
      return {};
    }
    if (isNullable) {
      return {
        type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
      };
    }
    return {
      type
    };
  }
  mapTupleItems(schemas) {
    return {
      prefixItems: schemas
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { exclusiveMinimum: Number(check.value) };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { exclusiveMaximum: Number(check.value) };
        default:
          return {};
      }
    }));
  }
};
function isWebhookDefinition(definition) {
  return "type" in definition && definition.type === "webhook";
}
__name(isWebhookDefinition, "isWebhookDefinition");
var OpenApiGeneratorV31 = class {
  static {
    __name(this, "OpenApiGeneratorV31");
  }
  constructor(definitions) {
    this.definitions = definitions;
    this.webhookRefs = {};
    const specifics = new OpenApiGeneratorV31Specifics();
    this.generator = new OpenAPIGenerator(this.definitions, specifics);
  }
  generateDocument(config2) {
    const baseDocument = this.generator.generateDocumentData();
    this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
    return Object.assign(Object.assign(Object.assign({}, config2), baseDocument), { webhooks: this.webhookRefs });
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
  generateSingleWebhook(route) {
    const routeDoc = this.generator.generatePath(route);
    this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
    return routeDoc;
  }
};

// node_modules/@hono/zod-validator/dist/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/validator/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/validator/validator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/helper/cookie/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/cookie.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/url.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var splitPath = /* @__PURE__ */ __name((path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder2) => {
  try {
    return decoder2(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder2(match);
      } catch {
        return match;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request) => {
  const url = request.url;
  const start = url.indexOf(
    "/",
    url.charCodeAt(9) === 58 ? 13 : 8
  );
  let i = start;
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key) => {
  return _getQueryParam(url, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = /* @__PURE__ */ __name((cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = cookieValue.indexOf("%") !== -1 ? tryDecode(cookieValue, decodeURIComponent_) : cookieValue;
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
}, "parse");

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = /* @__PURE__ */ __name((c2, key, prefix) => {
  const cookie = c2.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return void 0;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
}, "getCookie");

// node_modules/hono/dist/validator/validator.js
init_http_exception();

// node_modules/hono/dist/utils/buffer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/crypto.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = /* @__PURE__ */ __name((arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
}, "bufferToFormData");

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = /* @__PURE__ */ __name((target, validationFunc) => {
  return async (c2, next) => {
    let value = {};
    const contentType = c2.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c2.req.json();
        } catch {
          const message2 = "Malformed JSON in request body";
          throw new HTTPException(400, { message: message2 });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c2.req.bodyCache.formData) {
          formData = await c2.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c2.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c2.req.bodyCache.formData = formData;
          } catch (e) {
            let message2 = "Malformed FormData request.";
            message2 += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message: message2 });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            ;
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            ;
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(
          Object.entries(c2.req.queries()).map(([k, v]) => {
            return v.length === 1 ? [k, v[0]] : [k, v];
          })
        );
        break;
      case "param":
        value = c2.req.param();
        break;
      case "header":
        value = c2.req.header();
        break;
      case "cookie":
        value = getCookie(c2);
        break;
    }
    const res = await validationFunc(value, c2);
    if (res instanceof Response) {
      return res;
    }
    c2.req.addValidatedData(target, res);
    await next();
  };
}, "validator");

// node_modules/@hono/zod-validator/dist/esm/index.js
var zValidator = /* @__PURE__ */ __name((target, schema, hook) => (
  // @ts-expect-error not typed well
  validator(target, async (value, c2) => {
    const result = await schema.safeParseAsync(value);
    if (hook) {
      const hookResult = await hook({ data: value, ...result, target }, c2);
      if (hookResult) {
        if (hookResult instanceof Response) {
          return hookResult;
        }
        if ("response" in hookResult) {
          return hookResult.response;
        }
      }
    }
    if (!result.success) {
      return c2.json(result, 400);
    }
    return result.data;
  })
), "zValidator");

// node_modules/hono/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/hono.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/hono-base.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/compose.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var compose = /* @__PURE__ */ __name((middleware2, onError, onNotFound) => {
  return (context2, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware2[i]) {
        handler = middleware2[i][0][0];
        context2.req.routeIndex = i;
      } else {
        handler = i === middleware2.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context2, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context2.error = err;
            res = await onError(err, context2);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context2.finalized === false && onNotFound) {
          res = await onNotFound(context2);
        }
      }
      if (res && (context2.finalized === false || isError)) {
        context2.res = res;
      }
      return context2;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/hono/dist/context.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/request.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/request/constants.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  }, "#cachedBody");
  json() {
    return this.#cachedBody("text").then((text2) => JSON.parse(text2));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var escapeRe = /[&<>'"]/;
var stringBufferToString = /* @__PURE__ */ __name(async (buffer, callbacks) => {
  let str = "";
  callbacks ||= [];
  const resolvedBuffer = await Promise.all(buffer);
  for (let i = resolvedBuffer.length - 1; ; i--) {
    str += resolvedBuffer[i];
    i--;
    if (i < 0) {
      break;
    }
    let r = resolvedBuffer[i];
    if (typeof r === "object") {
      callbacks.push(...r.callbacks || []);
    }
    const isEscaped = r.isEscaped;
    r = await (typeof r === "object" ? r.toString() : r);
    if (typeof r === "object") {
      callbacks.push(...r.callbacks || []);
    }
    if (r.isEscaped ?? isEscaped) {
      str += r;
    } else {
      const buf = [str];
      escapeToBuffer(r, buf);
      str = buf[0];
    }
  }
  return raw(str, callbacks);
}, "stringBufferToString");
var escapeToBuffer = /* @__PURE__ */ __name((str, buffer) => {
  const match = str.search(escapeRe);
  if (match === -1) {
    buffer[0] += str;
    return;
  }
  let escape;
  let index;
  let lastIndex = 0;
  for (index = match; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    buffer[0] += str.substring(lastIndex, index) + escape;
    lastIndex = index + 1;
  }
  buffer[0] += str.substring(lastIndex, index);
}, "escapeToBuffer");
var resolveCallbackSync = /* @__PURE__ */ __name((str) => {
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return str;
  }
  const buffer = [str];
  const context2 = {};
  callbacks.forEach((c2) => c2({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context: context2 }));
  return buffer[0];
}, "resolveCallbackSync");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context2, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c2) => c2({ phase, buffer, context: context2 }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context2, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = /* @__PURE__ */ __name((...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  }, "render");
  setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  setRenderer = /* @__PURE__ */ __name((renderer) => {
    this.#renderer = renderer;
  }, "setRenderer");
  header = /* @__PURE__ */ __name((name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status) => {
    this.#status = status;
  }, "status");
  set = /* @__PURE__ */ __name((key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  }, "set");
  get = /* @__PURE__ */ __name((key) => {
    return this.#var ? this.#var.get(key) : void 0;
  }, "get");
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
  body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
  text = /* @__PURE__ */ __name((text2, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text2) : this.#newResponse(
      text2,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  json = /* @__PURE__ */ __name((object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html2, arg, headers) => {
    const res = /* @__PURE__ */ __name((html22) => this.#newResponse(html22, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html2 === "object" ? resolveCallback(html2, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html2);
  }, "html");
  redirect = /* @__PURE__ */ __name((location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  }, "redirect");
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// node_modules/hono/dist/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/hono/dist/utils/constants.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c2) => {
  return c2.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c2) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c2.newResponse(res.body, res);
  }
  console.error(err);
  return c2.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class {
  static {
    __name(this, "Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p2 of [path].flat()) {
        this.#path = p2;
        for (const m2 of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m2.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone2 = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone2.errorHandler = this.errorHandler;
    clone2.#notFoundHandler = this.#notFoundHandler;
    clone2.routes = this.routes;
    return clone2;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c2, next) => (await compose([], app.errorHandler)(c2, () => r.handler(c2, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c2) => {
      const options2 = optionHandler(c2);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c2) => {
      let executionContext = void 0;
      try {
        executionContext = c2.executionCtx;
      } catch {
      }
      return [c2.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c2, next) => {
      const res = await applicationHandler(replaceRequest(c2.req.raw), ...getOptions(c2));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c2) {
    if (err instanceof Error) {
      return this.errorHandler(err, c2);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env2, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, "GET")))();
    }
    const path = this.getPath(request, { env: env2 });
    const matchResult = this.router.match(method, path);
    const c2 = new Context(request, {
      path,
      matchResult,
      env: env2,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c2, async () => {
          c2.res = await this.#notFoundHandler(c2);
        });
      } catch (err) {
        return this.#handleError(err, c2);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c2.finalized ? c2.res : this.#notFoundHandler(c2))
      ).catch((err) => this.#handleError(err, c2)) : res ?? this.#notFoundHandler(c2);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context2 = await composed(c2);
        if (!context2.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context2.res;
      } catch (err) {
        return this.#handleError(err, c2);
      }
    })();
  }
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/hono/dist/router/reg-exp-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/node.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b2) {
  if (a.length === 1) {
    return b2.length === 1 ? a < b2 ? -1 : 1 : -1;
  }
  if (b2.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b2 === ONLY_WILDCARD_REG_EXP_STR || b2 === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b2 === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b2.length ? a < b2 ? -1 : 1 : b2.length - a.length;
}
__name(compareKey, "compareKey");
var Node = class {
  static {
    __name(this, "Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context2, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node();
        if (name !== "") {
          node.#varIndex = context2.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context2, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c2 = this.#children[k];
      return (typeof c2.#varIndex === "number" ? `(${k})@${c2.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c2.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m2) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m2];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware2, path) {
  if (!middleware2) {
    return void 0;
  }
  for (const k of Object.keys(middleware2).sort((a, b2) => b2.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware2[k]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware2 = this.#middleware;
    const routes = this.#routes;
    if (!middleware2 || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware2[method]) {
      ;
      [middleware2, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p2) => {
          handlerMap[method][p2] = [...handlerMap[METHOD_NAME_ALL][p2]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware2).forEach((m2) => {
          middleware2[m2][path] ||= findMiddleware(middleware2[m2], path) || findMiddleware(middleware2[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware2[method][path] ||= findMiddleware(middleware2[method], path) || findMiddleware(middleware2[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware2).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(middleware2[m2]).forEach((p2) => {
            re.test(p2) && middleware2[m2][p2].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(routes[m2]).forEach(
            (p2) => re.test(p2) && routes[m2][p2].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          routes[m2][path2] ||= [
            ...findMiddleware(middleware2[m2], path2) || findMiddleware(middleware2[METHOD_NAME_ALL], path2) || []
          ];
          routes[m2][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/smart-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/trie-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/trie-router/node.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  static {
    __name(this, "Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m2 = /* @__PURE__ */ Object.create(null);
      m2[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m2];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p2 = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p2, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p2;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m2 = node.#methods[i];
      const handlerSet = m2[method] || m2[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m2 = matcher.exec(restPathString);
            if (m2) {
              params[name] = m2[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m2[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b2) => {
        return a.score - b2.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/@hono/zod-openapi/dist/index.mjs
init_zod();
var OpenAPIHono = class _OpenAPIHono extends Hono2 {
  static {
    __name(this, "_OpenAPIHono");
  }
  openAPIRegistry;
  defaultHook;
  constructor(init) {
    super(init);
    this.openAPIRegistry = new OpenAPIRegistry();
    this.defaultHook = init?.defaultHook;
  }
  /**
   *
   * @param {RouteConfig} route - The route definition which you create with `createRoute()`.
   * @param {Handler} handler - The handler. If you want to return a JSON object, you should specify the status code with `c.json()`.
   * @param {Hook} hook - Optional. The hook method defines what it should do after validation.
   * @example
   * app.openapi(
   *   route,
   *   (c) => {
   *     // ...
   *     return c.json(
   *       {
   *         age: 20,
   *         name: 'Young man',
   *       },
   *       200 // You should specify the status code even if it's 200.
   *     )
   *   },
   *  (result, c) => {
   *    if (!result.success) {
   *      return c.json(
   *        {
   *          code: 400,
   *          message: 'Custom Message',
   *        },
   *        400
   *      )
   *    }
   *  }
   *)
   */
  openapi = /* @__PURE__ */ __name(({ middleware: routeMiddleware, ...route }, handler, hook = this.defaultHook) => {
    this.openAPIRegistry.registerPath(route);
    const validators = [];
    if (route.request?.query) {
      const validator2 = zValidator("query", route.request.query, hook);
      validators.push(validator2);
    }
    if (route.request?.params) {
      const validator2 = zValidator("param", route.request.params, hook);
      validators.push(validator2);
    }
    if (route.request?.headers) {
      const validator2 = zValidator("header", route.request.headers, hook);
      validators.push(validator2);
    }
    if (route.request?.cookies) {
      const validator2 = zValidator("cookie", route.request.cookies, hook);
      validators.push(validator2);
    }
    const bodyContent = route.request?.body?.content;
    if (bodyContent) {
      for (const mediaType of Object.keys(bodyContent)) {
        if (!bodyContent[mediaType]) {
          continue;
        }
        const schema = bodyContent[mediaType]["schema"];
        if (!(schema instanceof ZodType)) {
          continue;
        }
        if (isJSONContentType(mediaType)) {
          const validator2 = zValidator("json", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = /* @__PURE__ */ __name(async (c2, next) => {
              if (c2.req.header("content-type")) {
                if (isJSONContentType(c2.req.header("content-type"))) {
                  return await validator2(c2, next);
                }
              }
              c2.req.addValidatedData("json", {});
              await next();
            }, "mw");
            validators.push(mw);
          }
        }
        if (isFormContentType(mediaType)) {
          const validator2 = zValidator("form", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = /* @__PURE__ */ __name(async (c2, next) => {
              if (c2.req.header("content-type")) {
                if (isFormContentType(c2.req.header("content-type"))) {
                  return await validator2(c2, next);
                }
              }
              c2.req.addValidatedData("form", {});
              await next();
            }, "mw");
            validators.push(mw);
          }
        }
      }
    }
    const middleware2 = routeMiddleware ? Array.isArray(routeMiddleware) ? routeMiddleware : [routeMiddleware] : [];
    this.on(
      [route.method],
      route.path.replaceAll(/\/{(.+?)}/g, "/:$1"),
      ...middleware2,
      ...validators,
      handler
    );
    return this;
  }, "openapi");
  getOpenAPIDocument = /* @__PURE__ */ __name((config2) => {
    const generator = new OpenApiGeneratorV3(this.openAPIRegistry.definitions);
    const document = generator.generateDocument(config2);
    return this._basePath ? addBasePathToDocument(document, this._basePath) : document;
  }, "getOpenAPIDocument");
  getOpenAPI31Document = /* @__PURE__ */ __name((config2) => {
    const generator = new OpenApiGeneratorV31(this.openAPIRegistry.definitions);
    const document = generator.generateDocument(config2);
    return this._basePath ? addBasePathToDocument(document, this._basePath) : document;
  }, "getOpenAPI31Document");
  doc = /* @__PURE__ */ __name((path, configure) => {
    return this.get(path, (c2) => {
      const config2 = typeof configure === "function" ? configure(c2) : configure;
      try {
        const document = this.getOpenAPIDocument(config2);
        return c2.json(document);
      } catch (e) {
        return c2.json(e, 500);
      }
    });
  }, "doc");
  doc31 = /* @__PURE__ */ __name((path, configure) => {
    return this.get(path, (c2) => {
      const config2 = typeof configure === "function" ? configure(c2) : configure;
      try {
        const document = this.getOpenAPI31Document(config2);
        return c2.json(document);
      } catch (e) {
        return c2.json(e, 500);
      }
    });
  }, "doc31");
  route(path, app) {
    const pathForOpenAPI = path.replaceAll(/:([^\/]+)/g, "{$1}");
    super.route(path, app);
    if (!(app instanceof _OpenAPIHono)) {
      return this;
    }
    app.openAPIRegistry.definitions.forEach((def) => {
      switch (def.type) {
        case "component":
          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component);
        case "route":
          return this.openAPIRegistry.registerPath({
            ...def.route,
            path: mergePath(pathForOpenAPI, def.route.path)
          });
        case "webhook":
          return this.openAPIRegistry.registerWebhook({
            ...def.webhook,
            path: mergePath(pathForOpenAPI, def.webhook.path)
          });
        case "schema":
          return this.openAPIRegistry.register(def.schema._def.openapi._internal.refId, def.schema);
        case "parameter":
          return this.openAPIRegistry.registerParameter(
            def.schema._def.openapi._internal.refId,
            def.schema
          );
        default: {
          const errorIfNotExhaustive = def;
          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`);
        }
      }
    });
    return this;
  }
  basePath(path) {
    return new _OpenAPIHono({ ...super.basePath(path), defaultHook: this.defaultHook });
  }
};
var createRoute = /* @__PURE__ */ __name((routeConfig) => {
  const route = {
    ...routeConfig,
    getRoutingPath() {
      return routeConfig.path.replaceAll(/\/{(.+?)}/g, "/:$1");
    }
  };
  return Object.defineProperty(route, "getRoutingPath", { enumerable: false });
}, "createRoute");
extendZodWithOpenApi(external_exports);
function addBasePathToDocument(document, basePath) {
  const updatedPaths = {};
  Object.keys(document.paths).forEach((path) => {
    updatedPaths[mergePath(basePath, path)] = document.paths[path];
  });
  return {
    ...document,
    paths: updatedPaths
  };
}
__name(addBasePathToDocument, "addBasePathToDocument");
function isJSONContentType(contentType) {
  return /^application\/([a-z-\.]+\+)?json/.test(contentType);
}
__name(isJSONContentType, "isJSONContentType");
function isFormContentType(contentType) {
  return contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded");
}
__name(isFormContentType, "isFormContentType");

// node_modules/@hono/swagger-ui/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/helper/html/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var html = /* @__PURE__ */ __name((strings, ...values) => {
  const buffer = [""];
  for (let i = 0, len = strings.length - 1; i < len; i++) {
    buffer[0] += strings[i];
    const children = Array.isArray(values[i]) ? values[i].flat(Infinity) : [values[i]];
    for (let i2 = 0, len2 = children.length; i2 < len2; i2++) {
      const child = children[i2];
      if (typeof child === "string") {
        escapeToBuffer(child, buffer);
      } else if (typeof child === "number") {
        ;
        buffer[0] += child;
      } else if (typeof child === "boolean" || child === null || child === void 0) {
        continue;
      } else if (typeof child === "object" && child.isEscaped) {
        if (child.callbacks) {
          buffer.unshift("", child);
        } else {
          const tmp = child.toString();
          if (tmp instanceof Promise) {
            buffer.unshift("", tmp);
          } else {
            buffer[0] += tmp;
          }
        }
      } else if (child instanceof Promise) {
        buffer.unshift("", child);
      } else {
        escapeToBuffer(child.toString(), buffer);
      }
    }
  }
  buffer[0] += strings.at(-1);
  return buffer.length === 1 ? "callbacks" in buffer ? raw(resolveCallbackSync(raw(buffer[0], buffer.callbacks))) : raw(buffer[0]) : stringBufferToString(buffer, buffer.callbacks);
}, "html");

// node_modules/@hono/swagger-ui/dist/index.js
var RENDER_TYPE = {
  STRING_ARRAY: "string_array",
  STRING: "string",
  JSON_STRING: "json_string",
  RAW: "raw"
};
var RENDER_TYPE_MAP = {
  configUrl: RENDER_TYPE.STRING,
  deepLinking: RENDER_TYPE.RAW,
  presets: RENDER_TYPE.STRING_ARRAY,
  plugins: RENDER_TYPE.STRING_ARRAY,
  spec: RENDER_TYPE.JSON_STRING,
  url: RENDER_TYPE.STRING,
  urls: RENDER_TYPE.JSON_STRING,
  layout: RENDER_TYPE.STRING,
  docExpansion: RENDER_TYPE.STRING,
  maxDisplayedTags: RENDER_TYPE.RAW,
  operationsSorter: RENDER_TYPE.RAW,
  requestInterceptor: RENDER_TYPE.RAW,
  responseInterceptor: RENDER_TYPE.RAW,
  persistAuthorization: RENDER_TYPE.RAW,
  defaultModelsExpandDepth: RENDER_TYPE.RAW,
  defaultModelExpandDepth: RENDER_TYPE.RAW,
  defaultModelRendering: RENDER_TYPE.STRING,
  displayRequestDuration: RENDER_TYPE.RAW,
  filter: RENDER_TYPE.RAW,
  showExtensions: RENDER_TYPE.RAW,
  showCommonExtensions: RENDER_TYPE.RAW,
  queryConfigEnabled: RENDER_TYPE.RAW,
  displayOperationId: RENDER_TYPE.RAW,
  tagsSorter: RENDER_TYPE.RAW,
  onComplete: RENDER_TYPE.RAW,
  syntaxHighlight: RENDER_TYPE.JSON_STRING,
  tryItOutEnabled: RENDER_TYPE.RAW,
  requestSnippetsEnabled: RENDER_TYPE.RAW,
  requestSnippets: RENDER_TYPE.JSON_STRING,
  oauth2RedirectUrl: RENDER_TYPE.STRING,
  showMutabledRequest: RENDER_TYPE.RAW,
  request: RENDER_TYPE.JSON_STRING,
  supportedSubmitMethods: RENDER_TYPE.JSON_STRING,
  validatorUrl: RENDER_TYPE.STRING,
  withCredentials: RENDER_TYPE.RAW,
  modelPropertyMacro: RENDER_TYPE.RAW,
  parameterMacro: RENDER_TYPE.RAW
};
var renderSwaggerUIOptions = /* @__PURE__ */ __name((options) => {
  const optionsStrings = Object.entries(options).map(([k, v]) => {
    const key = k;
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.STRING) {
      return `${key}: '${v}'`;
    }
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.STRING_ARRAY) {
      if (!Array.isArray(v)) {
        return "";
      }
      return `${key}: [${v.map((ve) => `${ve}`).join(",")}]`;
    }
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.JSON_STRING) {
      return `${key}: ${JSON.stringify(v)}`;
    }
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.RAW) {
      return `${key}: ${v}`;
    }
    return "";
  }).join(",");
  return optionsStrings;
}, "renderSwaggerUIOptions");
var remoteAssets = /* @__PURE__ */ __name(({ version: version4 }) => {
  const url = `https://cdn.jsdelivr.net/npm/swagger-ui-dist${version4 !== void 0 ? `@${version4}` : ""}`;
  return {
    css: [`${url}/swagger-ui.css`],
    js: [`${url}/swagger-ui-bundle.js`]
  };
}, "remoteAssets");
var _a;
var SwaggerUI = /* @__PURE__ */ __name((options) => {
  const asset = remoteAssets({ version: options?.version });
  delete options.version;
  if (options.manuallySwaggerUIHtml) {
    return options.manuallySwaggerUIHtml(asset);
  }
  const optionsStrings = renderSwaggerUIOptions(options);
  return `
    <div>
      <div id="swagger-ui"></div>
      ${asset.css.map((url) => html`<link rel="stylesheet" href="${url}" />`)}
      ${asset.js.map((url) => html(_a || (_a = __template(['<script src="', '" crossorigin="anonymous"><\/script>'])), url))}
      <script>
        window.onload = () => {
          window.ui = SwaggerUIBundle({
            dom_id: '#swagger-ui',${optionsStrings},
          })
        }
      <\/script>
    </div>
  `;
}, "SwaggerUI");
var middleware = /* @__PURE__ */ __name((options) => async (c2) => {
  return c2.html(
    /* html */
    `
      <html lang="en">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <meta name="description" content="SwaggerUI" />
          <title>SwaggerUI</title>
        </head>
        <body>
          ${SwaggerUI(options)}
        </body>
      </html>
    `
  );
}, "middleware");

// node_modules/hono/dist/middleware/cors/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cors = /* @__PURE__ */ __name((options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return /* @__PURE__ */ __name(async function cors2(c2, next) {
    function set(key, value) {
      c2.res.headers.set(key, value);
    }
    __name(set, "set");
    const allowOrigin = await findAllowOrigin(c2.req.header("origin") || "", c2);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c2.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c2.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = await findAllowMethods(c2.req.header("origin") || "", c2);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c2.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c2.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c2.res.headers.delete("Content-Length");
      c2.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c2.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  }, "cors2");
}, "cors");

// node_modules/hono/dist/middleware/logger/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/color.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getColorEnabled() {
  const { process: process2, Deno: Deno2 } = globalThis;
  const isNoColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : process2 !== void 0 ? "NO_COLOR" in process2?.env : false;
  return !isNoColor;
}
__name(getColorEnabled, "getColorEnabled");
async function getColorEnabledAsync() {
  const { navigator: navigator2 } = globalThis;
  const cfWorkers = "cloudflare:workers";
  const isNoColor = navigator2 !== void 0 && navigator2.userAgent === "Cloudflare-Workers" ? await (async () => {
    try {
      return "NO_COLOR" in ((await import(cfWorkers)).env ?? {});
    } catch {
      return false;
    }
  })() : !getColorEnabled();
  return !isNoColor;
}
__name(getColorEnabledAsync, "getColorEnabledAsync");

// node_modules/hono/dist/middleware/logger/index.js
var humanize = /* @__PURE__ */ __name((times) => {
  const [delimiter, separator] = [",", "."];
  const orderTimes = times.map((v) => v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter));
  return orderTimes.join(separator);
}, "humanize");
var time3 = /* @__PURE__ */ __name((start) => {
  const delta = Date.now() - start;
  return humanize([delta < 1e3 ? delta + "ms" : Math.round(delta / 1e3) + "s"]);
}, "time");
var colorStatus = /* @__PURE__ */ __name(async (status) => {
  const colorEnabled = await getColorEnabledAsync();
  if (colorEnabled) {
    switch (status / 100 | 0) {
      case 5:
        return `\x1B[31m${status}\x1B[0m`;
      case 4:
        return `\x1B[33m${status}\x1B[0m`;
      case 3:
        return `\x1B[36m${status}\x1B[0m`;
      case 2:
        return `\x1B[32m${status}\x1B[0m`;
    }
  }
  return `${status}`;
}, "colorStatus");
async function log3(fn, prefix, method, path, status = 0, elapsed) {
  const out = prefix === "<--" ? `${prefix} ${method} ${path}` : `${prefix} ${method} ${path} ${await colorStatus(status)} ${elapsed}`;
  fn(out);
}
__name(log3, "log");
var logger = /* @__PURE__ */ __name((fn = console.log) => {
  return /* @__PURE__ */ __name(async function logger2(c2, next) {
    const { method, url } = c2.req;
    const path = url.slice(url.indexOf("/", 8));
    await log3(fn, "<--", method, path);
    const start = Date.now();
    await next();
    await log3(fn, "-->", method, path, c2.res.status, time3(start));
  }, "logger2");
}, "logger");

// dist/app.js
init_errors2();

// dist/auth/middleware.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/helper/factory/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var createMiddleware = /* @__PURE__ */ __name((middleware2) => middleware2, "createMiddleware");

// node_modules/hono/dist/middleware/jwt/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/middleware/jwt/jwt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();

// node_modules/hono/dist/utils/jwt/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/jwt/jwt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/encode.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var decodeBase64Url = /* @__PURE__ */ __name((str) => {
  return decodeBase64(str.replace(/_|-/g, (m2) => ({ _: "/", "-": "+" })[m2] ?? m2));
}, "decodeBase64Url");
var encodeBase64Url = /* @__PURE__ */ __name((buf) => encodeBase64(buf).replace(/\/|\+/g, (m2) => ({ "/": "_", "+": "-" })[m2] ?? m2), "encodeBase64Url");
var encodeBase64 = /* @__PURE__ */ __name((buf) => {
  let binary = "";
  const bytes = new Uint8Array(buf);
  for (let i = 0, len = bytes.length; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}, "encodeBase64");
var decodeBase64 = /* @__PURE__ */ __name((str) => {
  const binary = atob(str);
  const bytes = new Uint8Array(new ArrayBuffer(binary.length));
  const half = binary.length / 2;
  for (let i = 0, j = binary.length - 1; i <= half; i++, j--) {
    bytes[i] = binary.charCodeAt(i);
    bytes[j] = binary.charCodeAt(j);
  }
  return bytes;
}, "decodeBase64");

// node_modules/hono/dist/utils/jwt/jwa.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AlgorithmTypes = /* @__PURE__ */ ((AlgorithmTypes2) => {
  AlgorithmTypes2["HS256"] = "HS256";
  AlgorithmTypes2["HS384"] = "HS384";
  AlgorithmTypes2["HS512"] = "HS512";
  AlgorithmTypes2["RS256"] = "RS256";
  AlgorithmTypes2["RS384"] = "RS384";
  AlgorithmTypes2["RS512"] = "RS512";
  AlgorithmTypes2["PS256"] = "PS256";
  AlgorithmTypes2["PS384"] = "PS384";
  AlgorithmTypes2["PS512"] = "PS512";
  AlgorithmTypes2["ES256"] = "ES256";
  AlgorithmTypes2["ES384"] = "ES384";
  AlgorithmTypes2["ES512"] = "ES512";
  AlgorithmTypes2["EdDSA"] = "EdDSA";
  return AlgorithmTypes2;
})(AlgorithmTypes || {});

// node_modules/hono/dist/utils/jwt/jws.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/helper/adapter/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var knownUserAgents = {
  deno: "Deno",
  bun: "Bun",
  workerd: "Cloudflare-Workers",
  node: "Node.js"
};
var getRuntimeKey = /* @__PURE__ */ __name(() => {
  const global = globalThis;
  const userAgentSupported = typeof navigator !== "undefined" && true;
  if (userAgentSupported) {
    for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {
      if (checkUserAgentEquals(userAgent)) {
        return runtimeKey;
      }
    }
  }
  if (typeof global?.EdgeRuntime === "string") {
    return "edge-light";
  }
  if (global?.fastly !== void 0) {
    return "fastly";
  }
  if (global?.process?.release?.name === "node") {
    return "node";
  }
  return "other";
}, "getRuntimeKey");
var checkUserAgentEquals = /* @__PURE__ */ __name((platform2) => {
  const userAgent = "Cloudflare-Workers";
  return userAgent.startsWith(platform2);
}, "checkUserAgentEquals");

// node_modules/hono/dist/utils/jwt/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JwtAlgorithmNotImplemented = class extends Error {
  static {
    __name(this, "JwtAlgorithmNotImplemented");
  }
  constructor(alg) {
    super(`${alg} is not an implemented algorithm`);
    this.name = "JwtAlgorithmNotImplemented";
  }
};
var JwtTokenInvalid = class extends Error {
  static {
    __name(this, "JwtTokenInvalid");
  }
  constructor(token) {
    super(`invalid JWT token: ${token}`);
    this.name = "JwtTokenInvalid";
  }
};
var JwtTokenNotBefore = class extends Error {
  static {
    __name(this, "JwtTokenNotBefore");
  }
  constructor(token) {
    super(`token (${token}) is being used before it's valid`);
    this.name = "JwtTokenNotBefore";
  }
};
var JwtTokenExpired = class extends Error {
  static {
    __name(this, "JwtTokenExpired");
  }
  constructor(token) {
    super(`token (${token}) expired`);
    this.name = "JwtTokenExpired";
  }
};
var JwtTokenIssuedAt = class extends Error {
  static {
    __name(this, "JwtTokenIssuedAt");
  }
  constructor(currentTimestamp, iat) {
    super(
      `Invalid "iat" claim, must be a valid number lower than "${currentTimestamp}" (iat: "${iat}")`
    );
    this.name = "JwtTokenIssuedAt";
  }
};
var JwtTokenIssuer = class extends Error {
  static {
    __name(this, "JwtTokenIssuer");
  }
  constructor(expected, iss) {
    super(`expected issuer "${expected}", got ${iss ? `"${iss}"` : "none"} `);
    this.name = "JwtTokenIssuer";
  }
};
var JwtHeaderInvalid = class extends Error {
  static {
    __name(this, "JwtHeaderInvalid");
  }
  constructor(header) {
    super(`jwt header is invalid: ${JSON.stringify(header)}`);
    this.name = "JwtHeaderInvalid";
  }
};
var JwtHeaderRequiresKid = class extends Error {
  static {
    __name(this, "JwtHeaderRequiresKid");
  }
  constructor(header) {
    super(`required "kid" in jwt header: ${JSON.stringify(header)}`);
    this.name = "JwtHeaderRequiresKid";
  }
};
var JwtTokenSignatureMismatched = class extends Error {
  static {
    __name(this, "JwtTokenSignatureMismatched");
  }
  constructor(token) {
    super(`token(${token}) signature mismatched`);
    this.name = "JwtTokenSignatureMismatched";
  }
};
var CryptoKeyUsage = /* @__PURE__ */ ((CryptoKeyUsage2) => {
  CryptoKeyUsage2["Encrypt"] = "encrypt";
  CryptoKeyUsage2["Decrypt"] = "decrypt";
  CryptoKeyUsage2["Sign"] = "sign";
  CryptoKeyUsage2["Verify"] = "verify";
  CryptoKeyUsage2["DeriveKey"] = "deriveKey";
  CryptoKeyUsage2["DeriveBits"] = "deriveBits";
  CryptoKeyUsage2["WrapKey"] = "wrapKey";
  CryptoKeyUsage2["UnwrapKey"] = "unwrapKey";
  return CryptoKeyUsage2;
})(CryptoKeyUsage || {});

// node_modules/hono/dist/utils/jwt/utf8.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var utf8Encoder = new TextEncoder();
var utf8Decoder = new TextDecoder();

// node_modules/hono/dist/utils/jwt/jws.js
async function signing(privateKey, alg, data) {
  const algorithm = getKeyAlgorithm(alg);
  const cryptoKey = await importPrivateKey(privateKey, algorithm);
  return await crypto.subtle.sign(algorithm, cryptoKey, data);
}
__name(signing, "signing");
async function verifying(publicKey, alg, signature, data) {
  const algorithm = getKeyAlgorithm(alg);
  const cryptoKey = await importPublicKey(publicKey, algorithm);
  return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
}
__name(verifying, "verifying");
function pemToBinary(pem) {
  return decodeBase64(pem.replace(/-+(BEGIN|END).*/g, "").replace(/\s/g, ""));
}
__name(pemToBinary, "pemToBinary");
async function importPrivateKey(key, alg) {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  if (isCryptoKey(key)) {
    if (key.type !== "private" && key.type !== "secret") {
      throw new Error(
        `unexpected key type: CryptoKey.type is ${key.type}, expected private or secret`
      );
    }
    return key;
  }
  const usages = [CryptoKeyUsage.Sign];
  if (typeof key === "object") {
    return await crypto.subtle.importKey("jwk", key, alg, false, usages);
  }
  if (key.includes("PRIVATE")) {
    return await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, false, usages);
  }
  return await crypto.subtle.importKey("raw", utf8Encoder.encode(key), alg, false, usages);
}
__name(importPrivateKey, "importPrivateKey");
async function importPublicKey(key, alg) {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  if (isCryptoKey(key)) {
    if (key.type === "public" || key.type === "secret") {
      return key;
    }
    key = await exportPublicJwkFrom(key);
  }
  if (typeof key === "string" && key.includes("PRIVATE")) {
    const privateKey = await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, true, [
      CryptoKeyUsage.Sign
    ]);
    key = await exportPublicJwkFrom(privateKey);
  }
  const usages = [CryptoKeyUsage.Verify];
  if (typeof key === "object") {
    return await crypto.subtle.importKey("jwk", key, alg, false, usages);
  }
  if (key.includes("PUBLIC")) {
    return await crypto.subtle.importKey("spki", pemToBinary(key), alg, false, usages);
  }
  return await crypto.subtle.importKey("raw", utf8Encoder.encode(key), alg, false, usages);
}
__name(importPublicKey, "importPublicKey");
async function exportPublicJwkFrom(privateKey) {
  if (privateKey.type !== "private") {
    throw new Error(`unexpected key type: ${privateKey.type}`);
  }
  if (!privateKey.extractable) {
    throw new Error("unexpected private key is unextractable");
  }
  const jwk = await crypto.subtle.exportKey("jwk", privateKey);
  const { kty } = jwk;
  const { alg, e, n } = jwk;
  const { crv, x, y } = jwk;
  return { kty, alg, e, n, crv, x, y, key_ops: [CryptoKeyUsage.Verify] };
}
__name(exportPublicJwkFrom, "exportPublicJwkFrom");
function getKeyAlgorithm(name) {
  switch (name) {
    case "HS256":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      };
    case "HS384":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-384"
        }
      };
    case "HS512":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-512"
        }
      };
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-256"
        }
      };
    case "RS384":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-384"
        }
      };
    case "RS512":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-512"
        }
      };
    case "PS256":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-256"
        },
        saltLength: 32
      };
    case "PS384":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-384"
        },
        saltLength: 48
      };
    case "PS512":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-512"
        },
        saltLength: 64
      };
    case "ES256":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-256"
        },
        namedCurve: "P-256"
      };
    case "ES384":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-384"
        },
        namedCurve: "P-384"
      };
    case "ES512":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-512"
        },
        namedCurve: "P-521"
      };
    case "EdDSA":
      return {
        name: "Ed25519",
        namedCurve: "Ed25519"
      };
    default:
      throw new JwtAlgorithmNotImplemented(name);
  }
}
__name(getKeyAlgorithm, "getKeyAlgorithm");
function isCryptoKey(key) {
  const runtime = getRuntimeKey();
  if (runtime === "node" && !!crypto.webcrypto) {
    return key instanceof crypto.webcrypto.CryptoKey;
  }
  return key instanceof CryptoKey;
}
__name(isCryptoKey, "isCryptoKey");

// node_modules/hono/dist/utils/jwt/jwt.js
var encodeJwtPart = /* @__PURE__ */ __name((part) => encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, ""), "encodeJwtPart");
var encodeSignaturePart = /* @__PURE__ */ __name((buf) => encodeBase64Url(buf).replace(/=/g, ""), "encodeSignaturePart");
var decodeJwtPart = /* @__PURE__ */ __name((part) => JSON.parse(utf8Decoder.decode(decodeBase64Url(part))), "decodeJwtPart");
function isTokenHeader(obj) {
  if (typeof obj === "object" && obj !== null) {
    const objWithAlg = obj;
    return "alg" in objWithAlg && Object.values(AlgorithmTypes).includes(objWithAlg.alg) && (!("typ" in objWithAlg) || objWithAlg.typ === "JWT");
  }
  return false;
}
__name(isTokenHeader, "isTokenHeader");
var sign = /* @__PURE__ */ __name(async (payload, privateKey, alg = "HS256") => {
  const encodedPayload = encodeJwtPart(payload);
  let encodedHeader;
  if (typeof privateKey === "object" && "alg" in privateKey) {
    alg = privateKey.alg;
    encodedHeader = encodeJwtPart({ alg, typ: "JWT", kid: privateKey.kid });
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: "JWT" });
  }
  const partialToken = `${encodedHeader}.${encodedPayload}`;
  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken));
  const signature = encodeSignaturePart(signaturePart);
  return `${partialToken}.${signature}`;
}, "sign");
var verify = /* @__PURE__ */ __name(async (token, publicKey, algOrOptions) => {
  const optsIn = typeof algOrOptions === "string" ? { alg: algOrOptions } : algOrOptions || {};
  const opts = {
    alg: optsIn.alg ?? "HS256",
    iss: optsIn.iss,
    nbf: optsIn.nbf ?? true,
    exp: optsIn.exp ?? true,
    iat: optsIn.iat ?? true
  };
  const tokenParts = token.split(".");
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token);
  }
  const { header, payload } = decode(token);
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header);
  }
  const now = Date.now() / 1e3 | 0;
  if (opts.nbf && payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token);
  }
  if (opts.exp && payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token);
  }
  if (opts.iat && payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat);
  }
  if (opts.iss) {
    if (!payload.iss) {
      throw new JwtTokenIssuer(opts.iss, null);
    }
    if (typeof opts.iss === "string" && payload.iss !== opts.iss) {
      throw new JwtTokenIssuer(opts.iss, payload.iss);
    }
    if (opts.iss instanceof RegExp && !opts.iss.test(payload.iss)) {
      throw new JwtTokenIssuer(opts.iss, payload.iss);
    }
  }
  const headerPayload = token.substring(0, token.lastIndexOf("."));
  const verified = await verifying(
    publicKey,
    opts.alg,
    decodeBase64Url(tokenParts[2]),
    utf8Encoder.encode(headerPayload)
  );
  if (!verified) {
    throw new JwtTokenSignatureMismatched(token);
  }
  return payload;
}, "verify");
var verifyWithJwks = /* @__PURE__ */ __name(async (token, options, init) => {
  const verifyOpts = options.verification || {};
  const header = decodeHeader(token);
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header);
  }
  if (!header.kid) {
    throw new JwtHeaderRequiresKid(header);
  }
  if (options.jwks_uri) {
    const response = await fetch(options.jwks_uri, init);
    if (!response.ok) {
      throw new Error(`failed to fetch JWKS from ${options.jwks_uri}`);
    }
    const data = await response.json();
    if (!data.keys) {
      throw new Error('invalid JWKS response. "keys" field is missing');
    }
    if (!Array.isArray(data.keys)) {
      throw new Error('invalid JWKS response. "keys" field is not an array');
    }
    if (options.keys) {
      options.keys.push(...data.keys);
    } else {
      options.keys = data.keys;
    }
  } else if (!options.keys) {
    throw new Error('verifyWithJwks requires options for either "keys" or "jwks_uri" or both');
  }
  const matchingKey = options.keys.find((key) => key.kid === header.kid);
  if (!matchingKey) {
    throw new JwtTokenInvalid(token);
  }
  return await verify(token, matchingKey, {
    alg: matchingKey.alg || header.alg,
    ...verifyOpts
  });
}, "verifyWithJwks");
var decode = /* @__PURE__ */ __name((token) => {
  try {
    const [h, p2] = token.split(".");
    const header = decodeJwtPart(h);
    const payload = decodeJwtPart(p2);
    return {
      header,
      payload
    };
  } catch {
    throw new JwtTokenInvalid(token);
  }
}, "decode");
var decodeHeader = /* @__PURE__ */ __name((token) => {
  try {
    const [h] = token.split(".");
    return decodeJwtPart(h);
  } catch {
    throw new JwtTokenInvalid(token);
  }
}, "decodeHeader");

// node_modules/hono/dist/utils/jwt/index.js
var Jwt = { sign, verify, decode, verifyWithJwks };

// node_modules/hono/dist/middleware/jwt/jwt.js
var verifyWithJwks2 = Jwt.verifyWithJwks;
var verify2 = Jwt.verify;
var decode2 = Jwt.decode;
var sign2 = Jwt.sign;

// dist/auth/middleware.js
init_http_exception();
var jwksCache = null;
var JWKS_URL = "https://token.sesamy.dev/.well-known/jwks.json";
var CACHE_DURATION = 5 * 60 * 1e3;
async function getJWKS() {
  if (jwksCache && Date.now() < jwksCache.expires) {
    return jwksCache.keys;
  }
  try {
    const response = await fetch(JWKS_URL);
    if (!response.ok) {
      throw new Error(`Failed to fetch JWKS: ${response.status}`);
    }
    const jwks = await response.json();
    const keys = jwks.keys || [];
    jwksCache = {
      keys,
      expires: Date.now() + CACHE_DURATION
    };
    return keys;
  } catch (error3) {
    throw new Error("Unable to fetch JWT verification keys");
  }
}
__name(getJWKS, "getJWKS");
async function getPublicKey(kid) {
  const keys = await getJWKS();
  const key = keys.find((k) => k.kid === kid);
  if (!key) {
    throw new Error(`Key with kid ${kid} not found in JWKS`);
  }
  if (key.kty === "RSA") {
    return await jwkToPem(key);
  }
  throw new Error(`Unsupported key type: ${key.kty}`);
}
__name(getPublicKey, "getPublicKey");
async function jwkToPem(jwk) {
  try {
    const keyData = {
      kty: jwk.kty,
      n: jwk.n,
      e: jwk.e,
      alg: jwk.alg,
      use: jwk.use
    };
    const cryptoKey = await crypto.subtle.importKey("jwk", keyData, {
      name: "RSASSA-PKCS1-v1_5",
      hash: "SHA-256"
    }, true, ["verify"]);
    const exported = await crypto.subtle.exportKey("spki", cryptoKey);
    const b64 = btoa(String.fromCharCode(...new Uint8Array(exported)));
    const pem = `-----BEGIN PUBLIC KEY-----
${b64.match(/.{1,64}/g)?.join("\n")}
-----END PUBLIC KEY-----`;
    return pem;
  } catch (error3) {
    throw new Error("Failed to convert JWK to PEM format");
  }
}
__name(jwkToPem, "jwkToPem");
var jwtMiddleware = createMiddleware(async (c2, next) => {
  const authHeader = c2.req.header("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    const problem = {
      type: "unauthorized",
      title: "Unauthorized",
      status: 401,
      detail: "Missing or invalid authorization header",
      instance: c2.req.path
    };
    throw new HTTPException(401, { message: JSON.stringify(problem) });
  }
  const token = authHeader.substring(7);
  try {
    const { header } = decode2(token);
    if (!header.kid) {
      throw new Error("Token missing key ID (kid)");
    }
    const publicKey = await getPublicKey(header.kid);
    const payload = await verify2(token, publicKey, header.alg || "RS256");
    c2.set("jwtPayload", payload);
    if (payload.org_id) {
      c2.set("orgId", payload.org_id);
    }
    await next();
  } catch (error3) {
    const problem = {
      type: "unauthorized",
      title: "Unauthorized",
      status: 401,
      detail: "Invalid or expired token",
      instance: c2.req.path
    };
    throw new HTTPException(401, { message: JSON.stringify(problem) });
  }
});
var authMiddleware = createMiddleware(async (c2, next) => {
  await jwtMiddleware(c2, async () => {
    console.log("JWT verified in authMiddleware");
    const payload = c2.get("jwtPayload");
    if (!payload.org_id) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Organization context required. Please select an organization.",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    await next();
  });
});
var requireAuth = /* @__PURE__ */ __name((required) => {
  return createMiddleware(async (c2, next) => {
    const payload = c2.get("jwtPayload");
    if (!payload) {
      const problem = {
        type: "unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Missing or invalid authentication token",
        instance: c2.req.path
      };
      throw new HTTPException(401, {
        message: JSON.stringify(problem)
      });
    }
    const userPermissions = payload.permissions || [];
    const hasRequiredPermission = required.some((scope) => {
      const permissionName = scope.replace(".", ":");
      return userPermissions.includes(permissionName);
    });
    if (hasRequiredPermission) {
      await next();
      return;
    }
    let userScopes = [];
    if (payload.scope && typeof payload.scope === "string") {
      userScopes = payload.scope.split(" ").filter((s) => s.length > 0);
    } else if (payload.scopes && Array.isArray(payload.scopes)) {
      userScopes = payload.scopes;
    }
    const hasRequiredScope = required.some((scope) => userScopes.includes(scope));
    if (!hasRequiredScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: `Required permissions: ${required.map((s) => s.replace(".", ":")).join(", ")} OR scopes: ${required.join(", ")}. User permissions: ${userPermissions.join(", ")}, User scopes: ${userScopes.join(", ")}`,
        instance: c2.req.path
      };
      throw new HTTPException(403, {
        message: JSON.stringify(problem)
      });
    }
    await next();
  });
}, "requireAuth");
var hasPermissions = /* @__PURE__ */ __name((payload, requiredPermissions) => {
  const userPermissions = payload.permissions || [];
  return requiredPermissions.some((permission2) => userPermissions.includes(permission2));
}, "hasPermissions");
var hasScopes = /* @__PURE__ */ __name((payload, requiredScopes) => {
  let userScopes = [];
  if (payload.scope && typeof payload.scope === "string") {
    userScopes = payload.scope.split(" ").filter((s) => s.length > 0);
  } else if (payload.scopes && Array.isArray(payload.scopes)) {
    userScopes = payload.scopes;
  }
  return requiredScopes.some((scope) => userScopes.includes(scope));
}, "hasScopes");
var getOrgIdFromContext = /* @__PURE__ */ __name((c2) => {
  const orgId = c2.get("orgId");
  if (!orgId) {
    const problem = {
      type: "forbidden",
      title: "Forbidden",
      status: 403,
      detail: "Organization context required. Please select an organization.",
      instance: c2.req.path
    };
    throw new HTTPException(403, { message: JSON.stringify(problem) });
  }
  return orgId;
}, "getOrgIdFromContext");

// dist/health/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_client();
init_drizzle_orm();
var healthSchema = external_exports.object({
  status: external_exports.enum(["healthy", "unhealthy"]),
  timestamp: external_exports.string().datetime(),
  service: external_exports.string(),
  version: external_exports.string()
});
var livenessRoute = createRoute({
  method: "get",
  path: "/healthz",
  tags: ["health"],
  summary: "Liveness probe",
  description: "Check if the service is alive",
  responses: {
    200: {
      content: {
        "application/json": {
          schema: healthSchema
        }
      },
      description: "Service is alive"
    }
  }
});
var readinessRoute = createRoute({
  method: "get",
  path: "/readyz",
  tags: ["health"],
  summary: "Readiness probe",
  description: "Check if the service is ready to serve requests",
  responses: {
    200: {
      content: {
        "application/json": {
          schema: healthSchema
        }
      },
      description: "Service is ready"
    },
    503: {
      content: {
        "application/json": {
          schema: healthSchema
        }
      },
      description: "Service is not ready"
    }
  }
});
function registerHealthRoutes(app, database) {
  const db2 = getDatabase(database);
  app.openapi(livenessRoute, async (c2) => {
    return c2.json({
      status: "healthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      service: "podcast-service",
      version: "1.0.0"
    });
  });
  app.openapi(readinessRoute, async (c2) => {
    try {
      await db2.run(sql`SELECT 1`);
      return c2.json({
        status: "healthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        service: "podcast-service",
        version: "1.0.0"
      });
    } catch (error3) {
      return c2.json({
        status: "unhealthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        service: "podcast-service",
        version: "1.0.0"
      }, 503);
    }
  });
}
__name(registerHealthRoutes, "registerHealthRoutes");

// dist/shows/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
init_zod();

// dist/shows/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
var CreateShowSchema = external_exports.object({
  title: external_exports.string().min(1, "Title is required").max(255, "Title too long"),
  description: external_exports.string().min(1, "Description is required").max(2e3, "Description too long"),
  imageUrl: external_exports.nullable(external_exports.string().url()).optional(),
  language: external_exports.string().optional(),
  categories: external_exports.array(external_exports.string()).optional(),
  author: external_exports.string().optional()
});
var UpdateShowSchema = external_exports.object({
  title: external_exports.string().min(1).max(255).optional(),
  description: external_exports.string().min(1).max(2e3).optional(),
  imageUrl: external_exports.nullable(external_exports.string().url()).optional(),
  language: external_exports.string().optional(),
  categories: external_exports.array(external_exports.string()).optional(),
  author: external_exports.string().optional()
});
var ShowSchema = external_exports.object({
  id: external_exports.string().uuid(),
  title: external_exports.string(),
  description: external_exports.string(),
  imageUrl: external_exports.string().nullable(),
  language: external_exports.string().nullable(),
  categories: external_exports.array(external_exports.string()).nullable(),
  author: external_exports.string().nullable(),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var PaginationSchema = external_exports.object({
  limit: external_exports.string().optional().transform((val) => Math.min(parseInt(val || "10"), 100)).pipe(external_exports.number().min(1).max(100)),
  offset: external_exports.string().optional().transform((val) => parseInt(val || "0")).pipe(external_exports.number().min(0))
});
var ShowParamsSchema = external_exports.object({
  show_id: external_exports.string().uuid()
});
var ImportShowFromRSSSchema = external_exports.object({
  rssUrl: external_exports.string().url("Invalid RSS URL"),
  maxEpisodes: external_exports.number().int().positive().optional().default(100),
  skipExistingEpisodes: external_exports.boolean().optional().default(false)
});
var ImportShowResponseSchema = external_exports.object({
  taskId: external_exports.string(),
  message: external_exports.string(),
  workflowId: external_exports.string()
});
var RSSPreviewRequestSchema = external_exports.object({
  rssUrl: external_exports.string().url("Invalid RSS URL")
});
var RSSPreviewResponseSchema = external_exports.object({
  success: external_exports.boolean(),
  data: external_exports.object({
    title: external_exports.string(),
    description: external_exports.string(),
    imageUrl: external_exports.string().nullable().optional(),
    language: external_exports.string().optional(),
    categories: external_exports.array(external_exports.string()).optional(),
    author: external_exports.string().optional(),
    totalEpisodes: external_exports.number().int().nonnegative(),
    episodes: external_exports.array(external_exports.object({
      title: external_exports.string(),
      description: external_exports.string(),
      audioUrl: external_exports.string().url(),
      imageUrl: external_exports.string().url().nullable().optional(),
      publishedAt: external_exports.string().datetime().nullable().optional(),
      duration: external_exports.number().positive().nullable().optional(),
      episodeNumber: external_exports.number().int().positive().nullable().optional(),
      seasonNumber: external_exports.number().int().positive().nullable().optional()
    }))
  }).optional(),
  errors: external_exports.array(external_exports.object({
    type: external_exports.string(),
    message: external_exports.string(),
    details: external_exports.any().optional()
  })).optional()
});
var ImageUploadSchema = external_exports.object({
  id: external_exports.string().uuid(),
  showId: external_exports.string().uuid().nullable(),
  episodeId: external_exports.string().uuid().nullable(),
  fileName: external_exports.string(),
  fileSize: external_exports.number(),
  mimeType: external_exports.string(),
  url: external_exports.string(),
  uploadedAt: external_exports.string().datetime()
});

// dist/shows/routes.js
init_errors2();
init_service2();

// dist/workflows/import-show/rss-parser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
var RSSParseError = class extends Error {
  static {
    __name(this, "RSSParseError");
  }
  cause;
  constructor(message2, cause) {
    super(message2);
    this.cause = cause;
    this.name = "RSSParseError";
  }
};
var RSSValidationError = class extends Error {
  static {
    __name(this, "RSSValidationError");
  }
  validationErrors;
  constructor(message2, validationErrors) {
    super(message2);
    this.validationErrors = validationErrors;
    this.name = "RSSValidationError";
  }
};
function extractTextContent(xml, tagName, flags = "i") {
  const regex = new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)</${tagName}>`, flags);
  const match = xml.match(regex);
  return match ? match[1].trim().replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1") : "";
}
__name(extractTextContent, "extractTextContent");
function extractAttribute(xml, tagName, attributeName) {
  const regex = new RegExp(`<${tagName}[^>]*${attributeName}=["']([^"']*?)["'][^>]*>`, "i");
  const match = xml.match(regex);
  return match ? match[1] : "";
}
__name(extractAttribute, "extractAttribute");
function extractMultipleTextContent(xml, tagName) {
  const regex = new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)</${tagName}>`, "gi");
  const matches = xml.match(regex) || [];
  return matches.map((match) => {
    const textMatch = match.match(new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)</${tagName}>`, "i"));
    return textMatch ? textMatch[1].trim().replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1") : "";
  }).filter(Boolean);
}
__name(extractMultipleTextContent, "extractMultipleTextContent");
function extractItems(xml) {
  const regex = /<item[^>]*>([\s\S]*?)<\/item>/gi;
  const matches = xml.match(regex) || [];
  return matches;
}
__name(extractItems, "extractItems");
function parseDuration(durationStr) {
  if (!durationStr)
    return null;
  const secondsOnly = parseInt(durationStr);
  if (!isNaN(secondsOnly) && secondsOnly.toString() === durationStr) {
    return secondsOnly;
  }
  const parts = durationStr.split(":").map((p2) => parseInt(p2)).reverse();
  if (parts.length === 0 || parts.some((p2) => isNaN(p2)))
    return null;
  let totalSeconds = 0;
  if (parts[0] !== void 0)
    totalSeconds += parts[0];
  if (parts[1] !== void 0)
    totalSeconds += parts[1] * 60;
  if (parts[2] !== void 0)
    totalSeconds += parts[2] * 3600;
  return totalSeconds;
}
__name(parseDuration, "parseDuration");
function parseRSSDate(dateStr) {
  if (!dateStr)
    return null;
  try {
    const date = new Date(dateStr);
    if (isNaN(date.getTime()))
      return null;
    return date.toISOString();
  } catch {
    return null;
  }
}
__name(parseRSSDate, "parseRSSDate");
function extractEpisodeNumber(title2, guid) {
  const patterns = [
    /episode\s*(\d+)/i,
    /#(\d+)/,
    /ep\.?\s*(\d+)/i,
    /^(\d+)[\.\-\s]/
  ];
  for (const pattern of patterns) {
    const match = title2.match(pattern);
    if (match && match[1]) {
      const num = parseInt(match[1]);
      if (!isNaN(num) && num >= 0)
        return num;
    }
  }
  const guidMatch = guid.match(/(\d+)/);
  if (guidMatch && guidMatch[1]) {
    const num = parseInt(guidMatch[1]);
    if (!isNaN(num) && num >= 0)
      return num;
  }
  return null;
}
__name(extractEpisodeNumber, "extractEpisodeNumber");
async function fetchAndParseRSS(rssUrl) {
  try {
    const response = await fetch(rssUrl, {
      headers: {
        "User-Agent": "Sesamy Podcast Importer/1.0",
        Accept: "application/rss+xml, application/xml, text/xml, */*"
      },
      // Add timeout
      signal: AbortSignal.timeout(3e4)
      // 30 second timeout
    });
    if (!response.ok) {
      throw new RSSParseError(`HTTP ${response.status}: ${response.statusText}`);
    }
    const contentType = response.headers.get("content-type") || "";
    if (!contentType.includes("xml") && !contentType.includes("rss")) {
      console.warn(`Unexpected content-type: ${contentType}, attempting to parse anyway`);
    }
    const xmlText = await response.text();
    const channelMatch = xmlText.match(/<channel[^>]*>([\s\S]*?)<\/channel>/i);
    if (!channelMatch) {
      throw new RSSParseError("No channel element found in RSS feed");
    }
    const channelContent = channelMatch[1];
    const title2 = extractTextContent(channelContent, "title");
    const description = extractTextContent(channelContent, "description") || extractTextContent(channelContent, "itunes:summary") || extractTextContent(channelContent, "summary");
    if (!title2) {
      throw new RSSParseError("RSS feed missing required title");
    }
    if (!description) {
      throw new RSSParseError("RSS feed missing required description");
    }
    let imageUrl = null;
    imageUrl = extractAttribute(channelContent, "itunes:image", "href");
    if (!imageUrl) {
      const imageContent = extractTextContent(channelContent, "image");
      if (imageContent) {
        imageUrl = extractTextContent(imageContent, "url");
      }
    }
    const language = extractTextContent(channelContent, "language");
    const author = extractTextContent(channelContent, "itunes:author") || extractTextContent(channelContent, "managingEditor") || extractTextContent(channelContent, "author");
    const categories = extractMultipleTextContent(channelContent, "category");
    const itunesCategories = extractMultipleTextContent(channelContent, "itunes:category");
    const allCategories = [...categories, ...itunesCategories].filter(Boolean);
    const episodes2 = [];
    const itemContents = extractItems(xmlText);
    for (const itemContent of itemContents) {
      const episodeTitle = extractTextContent(itemContent, "title");
      const episodeDescription = extractTextContent(itemContent, "description") || extractTextContent(itemContent, "itunes:summary") || extractTextContent(itemContent, "content:encoded") || extractTextContent(itemContent, "summary");
      if (!episodeTitle || !episodeDescription) {
        console.warn("Skipping episode with missing title or description");
        continue;
      }
      const enclosureMatch = itemContent.match(/<enclosure[^>]*type=["'][^"']*audio[^"']*["'][^>]*>/i);
      if (!enclosureMatch) {
        console.warn(`Skipping episode "${episodeTitle}" - no audio enclosure found`);
        continue;
      }
      const audioUrl = extractAttribute(enclosureMatch[0], "enclosure", "url");
      if (!audioUrl) {
        console.warn(`Skipping episode "${episodeTitle}" - no audio URL found`);
        continue;
      }
      const episodeImageUrl = extractAttribute(itemContent, "itunes:image", "href") || null;
      const pubDate = extractTextContent(itemContent, "pubDate");
      const publishedAt = parseRSSDate(pubDate);
      const durationStr = extractTextContent(itemContent, "itunes:duration");
      let duration = parseDuration(durationStr);
      if (duration !== null && duration <= 0) {
        duration = null;
      }
      const itunesEpisodeStr = extractTextContent(itemContent, "itunes:episode");
      let episodeNumber = null;
      if (itunesEpisodeStr) {
        const parsed = parseInt(itunesEpisodeStr);
        episodeNumber = !isNaN(parsed) && parsed >= 0 ? parsed : null;
      } else {
        const guid = extractTextContent(itemContent, "guid");
        episodeNumber = extractEpisodeNumber(episodeTitle, guid);
      }
      const seasonStr = extractTextContent(itemContent, "itunes:season");
      let seasonNumber = null;
      if (seasonStr) {
        const parsed = parseInt(seasonStr);
        seasonNumber = !isNaN(parsed) && parsed >= 0 ? parsed : null;
      }
      const episodeType = extractTextContent(itemContent, "itunes:episodeType") || null;
      const author2 = extractTextContent(itemContent, "itunes:author") || null;
      const subtitle = extractTextContent(itemContent, "itunes:subtitle") || null;
      const explicitStr = extractTextContent(itemContent, "itunes:explicit");
      let explicit = null;
      if (explicitStr) {
        explicit = explicitStr.toLowerCase() === "true" || explicitStr.toLowerCase() === "yes";
      }
      const itunesCategories2 = extractMultipleTextContent(itemContent, "itunes:category");
      const itunesKeywords = extractTextContent(itemContent, "itunes:keywords");
      const keywords = [];
      keywords.push(...itunesCategories2);
      if (itunesKeywords) {
        keywords.push(...itunesKeywords.split(",").map((k) => k.trim()).filter(Boolean));
      }
      episodes2.push({
        title: episodeTitle,
        description: episodeDescription,
        audioUrl,
        imageUrl: episodeImageUrl,
        publishedAt,
        duration,
        episodeNumber,
        seasonNumber,
        episodeType,
        author: author2,
        subtitle,
        explicit,
        keywords: keywords.length > 0 ? keywords : null
      });
    }
    if (episodes2.length === 0) {
      throw new RSSParseError("No valid episodes found in RSS feed");
    }
    const show = {
      title: title2,
      description,
      imageUrl,
      language: language || void 0,
      categories: allCategories.length > 0 ? allCategories : void 0,
      author: author || void 0,
      episodes: episodes2.reverse()
      // Reverse to get chronological order (oldest first)
    };
    try {
      const { RSSShowSchema: RSSShowSchema2 } = await Promise.resolve().then(() => (init_types2(), types_exports));
      return RSSShowSchema2.parse(show);
    } catch (error3) {
      if (error3 instanceof external_exports.ZodError) {
        throw new RSSValidationError("RSS feed validation failed", error3.issues);
      }
      throw error3;
    }
  } catch (error3) {
    if (error3 instanceof RSSParseError || error3 instanceof RSSValidationError) {
      throw error3;
    }
    if (error3 instanceof Error) {
      if (error3.name === "AbortError") {
        throw new RSSParseError("RSS feed fetch timeout");
      }
      if (error3.message.includes("fetch")) {
        throw new RSSParseError(`Failed to fetch RSS feed: ${error3.message}`);
      }
    }
    throw new RSSParseError(`Unexpected error parsing RSS feed: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
  }
}
__name(fetchAndParseRSS, "fetchAndParseRSS");

// dist/shows/routes.js
async function signImageUrlInShow(show, audioService) {
  if (!show.imageUrl || !show.imageUrl.startsWith("r2://") || !audioService) {
    return show;
  }
  try {
    const r2Key = show.imageUrl.replace("r2://", "");
    const signedUrl = await audioService.generateSignedUrlFromKey(r2Key);
    if (signedUrl) {
      return {
        ...show,
        imageUrl: signedUrl
      };
    }
  } catch (error3) {
    console.warn("Failed to sign imageUrl for show:", show.id, error3);
  }
  return show;
}
__name(signImageUrlInShow, "signImageUrlInShow");
function registerShowRoutes(app, showService, audioService, imageService, database, importShowWorkflow) {
  app.openapi(createRoute({
    method: "get",
    path: "/shows",
    tags: ["shows"],
    summary: "Get all shows",
    description: "Get a paginated list of podcast shows",
    request: {
      query: PaginationSchema
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ShowSchema.array()
          }
        },
        description: "List of shows"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    const hasReadScope = hasScopes(payload, ["podcast.read"]);
    if (!hasReadPermission && !hasReadScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read OR scopes: podcast.read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const pagination = c2.req.valid("query");
    const shows2 = await showService.getAllShows(pagination, organizationId);
    const signedShows = await Promise.all(shows2.map((show) => signImageUrlInShow(show, audioService)));
    return c2.json(signedShows);
  });
  app.openapi(createRoute({
    method: "get",
    path: "/shows/{show_id}",
    tags: ["shows"],
    summary: "Get show by ID",
    description: "Get a specific podcast show by its ID",
    request: {
      params: ShowParamsSchema
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ShowSchema
          }
        },
        description: "Show details"
      },
      404: {
        description: "Show not found"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    if (!hasReadPermission) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const { show_id } = c2.req.valid("param");
    const show = await showService.getShowById(show_id, organizationId);
    if (!show) {
      const problem = {
        type: "not_found",
        title: "Not Found",
        status: 404,
        detail: "Show not found",
        instance: c2.req.path
      };
      throw new HTTPException(404, { message: JSON.stringify(problem) });
    }
    const signedShow = await signImageUrlInShow(show, audioService);
    return c2.json(signedShow);
  });
  app.openapi(createRoute({
    method: "post",
    path: "/shows",
    tags: ["shows"],
    summary: "Create a new show",
    description: "Create a new podcast show",
    request: {
      body: {
        content: {
          "application/json": {
            schema: CreateShowSchema
          }
        }
      }
    },
    responses: {
      201: {
        content: {
          "application/json": {
            schema: ShowSchema
          }
        },
        description: "Created show"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const showData = c2.req.valid("json");
    const show = await showService.createShow(showData, organizationId);
    const signedShow = await signImageUrlInShow(show, audioService);
    return c2.json(signedShow, 201);
  });
  app.openapi(createRoute({
    method: "post",
    path: "/shows/import",
    tags: ["shows"],
    summary: "Import show from RSS",
    description: "Import a podcast show and its episodes from an RSS feed URL",
    request: {
      body: {
        content: {
          "application/json": {
            schema: ImportShowFromRSSSchema
          }
        }
      }
    },
    responses: {
      202: {
        content: {
          "application/json": {
            schema: ImportShowResponseSchema
          }
        },
        description: "Import task created successfully"
      },
      400: {
        description: "Invalid RSS URL or parsing error"
      },
      500: {
        description: "Internal server error"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const importData = c2.req.valid("json");
    try {
      console.log(`Validating RSS feed: ${importData.rssUrl}`);
      await fetchAndParseRSS(importData.rssUrl);
      if (!database) {
        const problem = {
          type: "internal_error",
          title: "Internal Server Error",
          status: 500,
          detail: "Database not available",
          instance: c2.req.path
        };
        throw new HTTPException(500, { message: JSON.stringify(problem) });
      }
      if (!importShowWorkflow) {
        const problem = {
          type: "internal_error",
          title: "Internal Server Error",
          status: 500,
          detail: "Import workflow not available",
          instance: c2.req.path
        };
        throw new HTTPException(500, { message: JSON.stringify(problem) });
      }
      const taskService = new TaskService(database, void 0, importShowWorkflow);
      const task = await taskService.createTask("import_show", {
        rssUrl: importData.rssUrl,
        maxEpisodes: importData.maxEpisodes || 100,
        skipExistingEpisodes: importData.skipExistingEpisodes || false
      }, organizationId);
      console.log(`Created import task ${task.id} for RSS: ${importData.rssUrl}`);
      return c2.json({
        taskId: task.id.toString(),
        workflowId: task.workflowId || "pending",
        message: `RSS import task created successfully. Task ID: ${task.id}`
      }, 202);
    } catch (error3) {
      console.error("Import show from RSS failed:", error3);
      if (error3 instanceof RSSParseError) {
        const problem2 = {
          type: "validation_error",
          title: "RSS Validation Error",
          status: 400,
          detail: `RSS parsing failed: ${error3.message}`,
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem2) });
      }
      if (error3 instanceof RSSValidationError) {
        const problem2 = {
          type: "validation_error",
          title: "RSS Validation Error",
          status: 400,
          detail: `RSS validation failed: ${error3.message}. Errors: ${error3.validationErrors.map((e) => e.message).join(", ")}`,
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem2) });
      }
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      const problem = {
        type: "internal_error",
        title: "Internal Server Error",
        status: 500,
        detail: `Failed to create import task: ${error3 instanceof Error ? error3.message : "Unknown error"}`,
        instance: c2.req.path
      };
      throw new HTTPException(500, { message: JSON.stringify(problem) });
    }
  });
  app.openapi(createRoute({
    method: "post",
    path: "/shows/preview-rss",
    tags: ["shows"],
    summary: "Preview RSS feed",
    description: "Parse and preview an RSS feed without importing it. Returns the parsed show and episode data in JSON format with any validation errors.",
    request: {
      body: {
        content: {
          "application/json": {
            schema: RSSPreviewRequestSchema
          }
        }
      }
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: RSSPreviewResponseSchema
          }
        },
        description: "RSS feed parsed successfully (may include validation errors)"
      },
      400: {
        description: "Invalid request or RSS URL format"
      },
      500: {
        description: "Internal server error"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    const hasReadScope = hasScopes(payload, ["podcast.read"]);
    if (!hasReadPermission && !hasReadScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read or scope: podcast.read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const { rssUrl } = c2.req.valid("json");
    try {
      console.log(`Previewing RSS feed: ${rssUrl}`);
      const parsedRSS = await fetchAndParseRSS(rssUrl);
      return c2.json({
        success: true,
        data: {
          title: parsedRSS.title,
          description: parsedRSS.description,
          imageUrl: parsedRSS.imageUrl || null,
          language: parsedRSS.language,
          categories: parsedRSS.categories,
          author: parsedRSS.author,
          totalEpisodes: parsedRSS.episodes.length,
          episodes: parsedRSS.episodes
        }
      });
    } catch (error3) {
      console.error("RSS preview failed:", error3);
      if (error3 instanceof RSSParseError) {
        return c2.json({
          success: false,
          errors: [
            {
              type: "rss_parse_error",
              message: error3.message,
              details: error3.cause ? { cause: error3.cause.message } : void 0
            }
          ]
        });
      }
      if (error3 instanceof RSSValidationError) {
        return c2.json({
          success: false,
          errors: [
            {
              type: "rss_validation_error",
              message: error3.message,
              details: { validationErrors: error3.validationErrors }
            }
          ]
        });
      }
      return c2.json({
        success: false,
        errors: [
          {
            type: "unknown_error",
            message: error3 instanceof Error ? error3.message : "Unknown error occurred"
          }
        ]
      });
    }
  });
  app.openapi(createRoute({
    method: "patch",
    path: "/shows/{show_id}",
    tags: ["shows"],
    summary: "Update a show",
    description: "Update an existing podcast show",
    request: {
      params: ShowParamsSchema,
      body: {
        content: {
          "application/json": {
            schema: UpdateShowSchema
          }
        }
      }
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ShowSchema
          }
        },
        description: "Updated show"
      },
      404: {
        description: "Show not found"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const { show_id } = c2.req.valid("param");
    const updateData = c2.req.valid("json");
    try {
      const show = await showService.updateShow(show_id, updateData, organizationId);
      const signedShow = await signImageUrlInShow(show, audioService);
      return c2.json(signedShow);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Show not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(createRoute({
    method: "delete",
    path: "/shows/{show_id}",
    tags: ["shows"],
    summary: "Delete a show",
    description: "Delete an existing podcast show",
    request: {
      params: ShowParamsSchema
    },
    responses: {
      204: {
        description: "Show deleted successfully"
      },
      404: {
        description: "Show not found"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    const { show_id } = c2.req.valid("param");
    try {
      await showService.deleteShow(show_id, organizationId);
      return c2.body(null, 204);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Show not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(createRoute({
    method: "post",
    path: "/shows/{show_id}/image",
    tags: ["shows"],
    summary: "Upload show image",
    description: "Upload an image file for a show",
    request: {
      params: ShowParamsSchema,
      body: {
        content: {
          "multipart/form-data": {
            schema: external_exports.object({
              image: external_exports.any().openapi({
                type: "string",
                format: "binary",
                description: "Image file to upload"
              })
            })
          }
        }
      }
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ImageUploadSchema
          }
        },
        description: "Image uploaded successfully"
      },
      400: {
        description: "Invalid file or request"
      },
      404: {
        description: "Show not found"
      }
    },
    security: [{ Bearer: [] }]
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const organizationId = getOrgIdFromContext(c2);
    if (!imageService) {
      const problem = {
        type: "internal_error",
        title: "Internal Server Error",
        status: 500,
        detail: "Image service not available",
        instance: c2.req.path
      };
      throw new HTTPException(500, { message: JSON.stringify(problem) });
    }
    const { show_id } = c2.req.valid("param");
    try {
      const show = await showService.getShowById(show_id, organizationId);
      if (!show) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Show not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      const formData = await c2.req.formData();
      const imageFile = formData.get("image");
      if (!imageFile) {
        const problem = {
          type: "validation_error",
          title: "Bad Request",
          status: 400,
          detail: "Image file is required",
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem) });
      }
      const imageUpload = await imageService.uploadShowImage(show_id, imageFile);
      return c2.json(imageUpload);
    } catch (error3) {
      console.error("[ShowRoutes] Image upload error:", {
        message: error3.message,
        name: error3.name,
        stack: error3.stack,
        cause: error3.cause,
        errorString: String(error3),
        errorType: typeof error3
      });
      if (error3.message?.includes("not found")) {
        const problem2 = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Show not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem2) });
      }
      if (error3.message?.includes("File must be an image")) {
        const problem2 = {
          type: "validation_error",
          title: "Bad Request",
          status: 400,
          detail: "File must be an image",
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem2) });
      }
      if (error3.message?.includes("R2 bucket") || error3.message?.includes("storage service")) {
        const problem2 = {
          type: "internal_error",
          title: "Internal Server Error",
          status: 500,
          detail: "Image storage service is temporarily unavailable",
          instance: c2.req.path
        };
        throw new HTTPException(500, { message: JSON.stringify(problem2) });
      }
      if (error3.message?.includes("Database error")) {
        const problem2 = {
          type: "internal_error",
          title: "Internal Server Error",
          status: 500,
          detail: "Database error occurred",
          instance: c2.req.path
        };
        throw new HTTPException(500, { message: JSON.stringify(problem2) });
      }
      const problem = {
        type: "internal_error",
        title: "Internal Server Error",
        status: 500,
        detail: `An unexpected error occurred while uploading the image: ${error3.message || "Unknown error"}`,
        instance: c2.req.path
      };
      throw new HTTPException(500, { message: JSON.stringify(problem) });
    }
  });
}
__name(registerShowRoutes, "registerShowRoutes");

// dist/episodes/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
init_zod();

// dist/episodes/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
var CreateEpisodeSchema = external_exports.object({
  title: external_exports.string().min(1, "Title is required").max(255, "Title too long"),
  description: external_exports.string().min(1, "Description is required").max(2e3, "Description too long"),
  imageUrl: external_exports.nullable(external_exports.string().url()).optional(),
  audioUrl: external_exports.nullable(external_exports.string().url()).optional(),
  transcriptUrl: external_exports.nullable(external_exports.string().url()).optional(),
  duration: external_exports.number().int().positive().nullable().optional(),
  episodeNumber: external_exports.number().int().nonnegative().nullable().optional(),
  seasonNumber: external_exports.number().int().nonnegative().nullable().optional(),
  episodeType: external_exports.string().nullable().optional(),
  author: external_exports.string().nullable().optional(),
  subtitle: external_exports.string().nullable().optional(),
  explicit: external_exports.boolean().nullable().optional(),
  keywords: external_exports.string().nullable().optional()
  // JSON string containing array of keywords
});
var UpdateEpisodeSchema = external_exports.object({
  title: external_exports.string().min(1).max(255).optional(),
  description: external_exports.string().min(1).max(2e3).optional(),
  imageUrl: external_exports.nullable(external_exports.string().url()).optional(),
  audioUrl: external_exports.nullable(external_exports.string().url()).optional(),
  transcriptUrl: external_exports.nullable(external_exports.string().url()).optional(),
  encodedAudioUrls: external_exports.nullable(external_exports.string()).optional(),
  duration: external_exports.number().int().positive().nullable().optional(),
  episodeNumber: external_exports.number().int().nonnegative().nullable().optional(),
  seasonNumber: external_exports.number().int().nonnegative().nullable().optional(),
  episodeType: external_exports.string().nullable().optional(),
  author: external_exports.string().nullable().optional(),
  subtitle: external_exports.string().nullable().optional(),
  explicit: external_exports.boolean().nullable().optional(),
  keywords: external_exports.string().nullable().optional()
  // JSON string containing array of keywords
});
var EpisodeSchema = external_exports.object({
  id: external_exports.string().uuid(),
  showId: external_exports.string().uuid(),
  title: external_exports.string(),
  description: external_exports.string(),
  imageUrl: external_exports.string().nullable(),
  audioUrl: external_exports.string().nullable(),
  transcriptUrl: external_exports.string().nullable(),
  encodedAudioUrls: external_exports.string().nullable(),
  published: external_exports.boolean().nullable(),
  publishedAt: external_exports.string().datetime().nullable(),
  duration: external_exports.number().int().positive().nullable(),
  episodeNumber: external_exports.number().int().nonnegative().nullable(),
  seasonNumber: external_exports.number().int().nonnegative().nullable(),
  episodeType: external_exports.string().nullable(),
  author: external_exports.string().nullable(),
  subtitle: external_exports.string().nullable(),
  explicit: external_exports.boolean().nullable(),
  keywords: external_exports.string().nullable(),
  // JSON string containing array of keywords
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var EpisodeParamsSchema = external_exports.object({
  show_id: external_exports.string().uuid(),
  episode_id: external_exports.string().uuid()
});
var ShowParamsSchema2 = external_exports.object({
  show_id: external_exports.string().uuid()
});
var PaginationSchema2 = external_exports.object({
  limit: external_exports.string().optional().transform((val) => Math.min(parseInt(val || "10"), 100)).pipe(external_exports.number().min(1).max(100)),
  offset: external_exports.string().optional().transform((val) => parseInt(val || "0")).pipe(external_exports.number().min(0))
});
var ImageUploadSchema2 = external_exports.object({
  id: external_exports.string().uuid(),
  showId: external_exports.string().uuid().nullable(),
  episodeId: external_exports.string().uuid().nullable(),
  fileName: external_exports.string(),
  fileSize: external_exports.number(),
  mimeType: external_exports.string(),
  url: external_exports.string(),
  uploadedAt: external_exports.string().datetime()
});

// dist/episodes/routes.js
init_errors2();
async function signImageUrlInEpisode(episode, imageService) {
  if (!episode.imageUrl || !episode.imageUrl.startsWith("r2://") || !imageService) {
    return episode;
  }
  try {
    const r2Key = episode.imageUrl.replace("r2://", "");
    const signedUrl = await imageService.signImageUrl(episode.imageUrl);
    if (signedUrl) {
      return {
        ...episode,
        imageUrl: signedUrl
      };
    }
  } catch (error3) {
    console.warn("Failed to sign imageUrl for episode:", episode.id, error3);
  }
  return episode;
}
__name(signImageUrlInEpisode, "signImageUrlInEpisode");
async function signAudioUrlInEpisode(episode, audioService) {
  if (!episode.audioUrl || !episode.audioUrl.startsWith("r2://") || !audioService) {
    return episode;
  }
  try {
    const r2Key = episode.audioUrl.replace("r2://", "");
    const signedUrl = await audioService.generateSignedUrlFromKey(r2Key);
    if (signedUrl) {
      return {
        ...episode,
        audioUrl: signedUrl
      };
    }
  } catch (error3) {
    console.warn("Failed to sign audioUrl for episode:", episode.id, error3);
  }
  return episode;
}
__name(signAudioUrlInEpisode, "signAudioUrlInEpisode");
var getEpisodesRoute = createRoute({
  method: "get",
  path: "/shows/{show_id}/episodes",
  tags: ["episodes"],
  summary: "Get episodes",
  description: "Get all episodes for a show",
  request: {
    params: ShowParamsSchema2,
    query: PaginationSchema2
  },
  responses: {
    200: {
      description: "Episodes retrieved successfully",
      content: {
        "application/json": {
          schema: {
            type: "array",
            items: {
              type: "object",
              properties: {
                id: { type: "string" },
                showId: { type: "string" },
                title: { type: "string" },
                description: { type: "string" },
                audioUrl: { type: "string", nullable: true },
                transcriptUrl: { type: "string", nullable: true },
                published: { type: "boolean", nullable: true },
                publishedAt: { type: "string", nullable: true },
                createdAt: { type: "string" },
                updatedAt: { type: "string" }
              }
            }
          }
        }
      }
    },
    404: {
      description: "Show not found"
    }
  },
  security: [{ Bearer: [] }]
});
var getEpisodeRoute = createRoute({
  method: "get",
  path: "/shows/{show_id}/episodes/{episode_id}",
  tags: ["episodes"],
  summary: "Get episode",
  description: "Get a single episode by ID",
  request: {
    params: EpisodeParamsSchema
  },
  responses: {
    200: {
      description: "Episode retrieved successfully",
      content: {
        "application/json": {
          schema: EpisodeSchema
        }
      }
    },
    404: {
      description: "Episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
var createEpisodeRoute = createRoute({
  method: "post",
  path: "/shows/{show_id}/episodes",
  tags: ["episodes"],
  summary: "Create episode",
  description: "Create a new episode for a show",
  request: {
    params: ShowParamsSchema2,
    body: {
      content: {
        "application/json": {
          schema: CreateEpisodeSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Episode created successfully",
      content: {
        "application/json": {
          schema: EpisodeSchema
        }
      }
    },
    404: {
      description: "Show not found"
    }
  },
  security: [{ Bearer: [] }]
});
var updateEpisodeRoute = createRoute({
  method: "patch",
  path: "/shows/{show_id}/episodes/{episode_id}",
  tags: ["episodes"],
  summary: "Update episode",
  description: "Update an existing episode",
  request: {
    params: EpisodeParamsSchema,
    body: {
      content: {
        "application/json": {
          schema: UpdateEpisodeSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Episode updated successfully",
      content: {
        "application/json": {
          schema: EpisodeSchema
        }
      }
    },
    404: {
      description: "Episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
var publishEpisodeRoute = createRoute({
  method: "post",
  path: "/shows/{show_id}/episodes/{episode_id}/publish",
  tags: ["episodes"],
  summary: "Publish episode",
  description: "Publish an episode to make it publicly available",
  request: {
    params: EpisodeParamsSchema
  },
  responses: {
    200: {
      description: "Episode published successfully",
      content: {
        "application/json": {
          schema: EpisodeSchema
        }
      }
    },
    404: {
      description: "Episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
var deleteEpisodeRoute = createRoute({
  method: "delete",
  path: "/shows/{show_id}/episodes/{episode_id}",
  tags: ["episodes"],
  summary: "Delete episode",
  description: "Delete an episode",
  request: {
    params: EpisodeParamsSchema
  },
  responses: {
    204: {
      description: "Episode deleted successfully"
    },
    404: {
      description: "Episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
var uploadEpisodeImageRoute = createRoute({
  method: "post",
  path: "/shows/{show_id}/episodes/{episode_id}/image",
  tags: ["episodes"],
  summary: "Upload episode image",
  description: "Upload an image file for an episode",
  request: {
    params: EpisodeParamsSchema,
    body: {
      content: {
        "multipart/form-data": {
          schema: external_exports.object({
            image: external_exports.any().openapi({
              type: "string",
              format: "binary",
              description: "Image file to upload"
            })
          })
        }
      }
    }
  },
  responses: {
    200: {
      content: {
        "application/json": {
          schema: ImageUploadSchema2
        }
      },
      description: "Image uploaded successfully"
    },
    400: {
      description: "Invalid file or request"
    },
    404: {
      description: "Episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
var getEpisodeTranscriptRoute = createRoute({
  method: "get",
  path: "/shows/{show_id}/episodes/{episode_id}/transcript",
  tags: ["episodes"],
  summary: "Get episode transcript",
  description: "Get the transcript of an episode in markdown format",
  request: {
    params: EpisodeParamsSchema
  },
  responses: {
    200: {
      description: "Transcript retrieved successfully",
      content: {
        "text/markdown": {
          schema: {
            type: "string"
          }
        },
        "application/json": {
          schema: {
            type: "object",
            properties: {
              transcript: { type: "string" },
              episodeId: { type: "string" },
              title: { type: "string" },
              createdAt: { type: "string" }
            }
          }
        }
      }
    },
    404: {
      description: "Episode or transcript not found"
    },
    503: {
      description: "Transcript not available"
    }
  },
  security: [{ Bearer: [] }]
});
function registerEpisodeRoutes(app, episodeService, audioService, imageService, bucket) {
  app.openapi(getEpisodesRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    const hasReadScope = hasScopes(payload, ["podcast.read"]);
    if (!hasReadPermission && !hasReadScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read OR scopes: podcast.read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id } = c2.req.valid("param");
    const pagination = c2.req.valid("query");
    const episodes2 = await episodeService.getEpisodesByShowId(show_id, pagination);
    const signedEpisodes = await Promise.all(episodes2.map(async (episode) => {
      let signedEpisode = await signAudioUrlInEpisode(episode, audioService);
      signedEpisode = await signImageUrlInEpisode(signedEpisode, imageService);
      return signedEpisode;
    }));
    return c2.json(signedEpisodes);
  });
  app.openapi(getEpisodeRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    const hasReadScope = hasScopes(payload, ["podcast.read"]);
    if (!hasReadPermission && !hasReadScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read OR scopes: podcast.read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    const episode = await episodeService.getEpisodeById(show_id, episode_id);
    if (!episode) {
      const problem = {
        type: "not_found",
        title: "Not Found",
        status: 404,
        detail: "Episode not found",
        instance: c2.req.path
      };
      throw new HTTPException(404, { message: JSON.stringify(problem) });
    }
    let signedEpisode = await signAudioUrlInEpisode(episode, audioService);
    signedEpisode = await signImageUrlInEpisode(signedEpisode, imageService);
    return c2.json(signedEpisode);
  });
  app.openapi(createEpisodeRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id } = c2.req.valid("param");
    const episodeData = c2.req.valid("json");
    const organizationId = payload.org_id;
    if (!organizationId) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Organization context required. Please select an organization.",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    try {
      const episode = await episodeService.createEpisode(show_id, episodeData, organizationId);
      let signedEpisode = await signAudioUrlInEpisode(episode, audioService);
      signedEpisode = await signImageUrlInEpisode(signedEpisode, imageService);
      return c2.json(signedEpisode, 201);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Show not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(updateEpisodeRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    const updateData = c2.req.valid("json");
    try {
      const episode = await episodeService.updateEpisode(show_id, episode_id, updateData);
      let signedEpisode = await signAudioUrlInEpisode(episode, audioService);
      signedEpisode = await signImageUrlInEpisode(signedEpisode, imageService);
      return c2.json(signedEpisode);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Episode not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(publishEpisodeRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasPublishPermission = hasPermissions(payload, ["podcast:publish"]);
    const hasPublishScope = hasScopes(payload, ["podcast.publish"]);
    if (!hasPublishPermission && !hasPublishScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:publish or scope: podcast.publish",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    try {
      const episode = await episodeService.publishEpisode(show_id, episode_id);
      let signedEpisode = await signAudioUrlInEpisode(episode, audioService);
      signedEpisode = await signImageUrlInEpisode(signedEpisode, imageService);
      return c2.json(signedEpisode);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Episode not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(deleteEpisodeRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    try {
      await episodeService.deleteEpisode(show_id, episode_id);
      return c2.body(null, 204);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Episode not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(uploadEpisodeImageRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    if (!imageService) {
      const problem = {
        type: "internal_error",
        title: "Internal Server Error",
        status: 500,
        detail: "Image service not available",
        instance: c2.req.path
      };
      throw new HTTPException(500, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    try {
      const formData = await c2.req.formData();
      const imageFile = formData.get("image");
      if (!imageFile) {
        const problem = {
          type: "validation_error",
          title: "Bad Request",
          status: 400,
          detail: "Image file is required",
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem) });
      }
      const imageUpload = await imageService.uploadEpisodeImage(show_id, episode_id, imageFile);
      return c2.json(imageUpload);
    } catch (error3) {
      if (error3.message?.includes("not found")) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: error3.message,
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      if (error3.message?.includes("File must be an image")) {
        const problem = {
          type: "validation_error",
          title: "Bad Request",
          status: 400,
          detail: "File must be an image",
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem) });
      }
      throw error3;
    }
  });
  app.openapi(getEpisodeTranscriptRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    const hasReadScope = hasScopes(payload, ["podcast.read"]);
    if (!hasReadPermission && !hasReadScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read OR scopes: podcast.read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    if (!bucket) {
      const problem = {
        type: "service_unavailable",
        title: "Service Unavailable",
        status: 503,
        detail: "Transcript storage service is not available",
        instance: c2.req.path
      };
      throw new HTTPException(503, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    try {
      const episode = await episodeService.getEpisodeById(show_id, episode_id);
      if (!episode || episode.showId !== show_id) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Episode not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      if (!episode.transcriptUrl) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Transcript not available for this episode",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      let transcriptKey;
      if (episode.transcriptUrl.startsWith("r2://")) {
        transcriptKey = episode.transcriptUrl.replace("r2://", "");
      } else {
        const url = new URL(episode.transcriptUrl);
        const pathSegments = url.pathname.split("/");
        const transcriptsIndex = pathSegments.indexOf("transcripts");
        if (transcriptsIndex === -1) {
          throw new Error("Invalid transcript URL format");
        }
        transcriptKey = pathSegments.slice(transcriptsIndex).join("/");
      }
      const transcriptObject = await bucket.get(transcriptKey);
      if (!transcriptObject) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Transcript file not found in storage",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      const transcriptText = await transcriptObject.text();
      const acceptHeader = c2.req.header("Accept");
      const preferMarkdown = acceptHeader?.includes("text/markdown") || acceptHeader?.includes("text/plain");
      if (preferMarkdown) {
        const markdownContent = `# ${episode.title}

**Episode ID:** ${episode.id}
**Show:** ${episode.showId}
**Created:** ${new Date(episode.createdAt).toLocaleDateString()}

---

## Transcript

${transcriptText}`;
        return new Response(markdownContent, {
          headers: {
            "Content-Type": "text/markdown; charset=utf-8",
            "Cache-Control": "public, max-age=3600"
            // Cache for 1 hour
          }
        });
      } else {
        return c2.json({
          transcript: transcriptText,
          episodeId: episode.id,
          title: episode.title,
          createdAt: episode.createdAt,
          transcriptUrl: episode.transcriptUrl
        });
      }
    } catch (error3) {
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      console.error("Failed to fetch transcript:", error3);
      if (error3.message?.includes("not found")) {
        const problem2 = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Episode or transcript not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem2) });
      }
      const problem = {
        type: "internal_server_error",
        title: "Internal Server Error",
        status: 500,
        detail: "Failed to retrieve transcript",
        instance: c2.req.path
      };
      throw new HTTPException(500, { message: JSON.stringify(problem) });
    }
  });
}
__name(registerEpisodeRoutes, "registerEpisodeRoutes");

// dist/audio/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();

// dist/audio/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
var AudioUploadSchema = external_exports.object({
  id: external_exports.string().uuid(),
  episodeId: external_exports.string().uuid(),
  fileName: external_exports.string(),
  fileSize: external_exports.number().int().positive(),
  mimeType: external_exports.string(),
  url: external_exports.string().url(),
  uploadedAt: external_exports.string().datetime()
});
var AudioParamsSchema = external_exports.object({
  show_id: external_exports.string().uuid(),
  episode_id: external_exports.string().uuid()
});

// dist/audio/routes.js
init_errors2();
var uploadAudioRoute = createRoute({
  method: "post",
  path: "/shows/{show_id}/episodes/{episode_id}/audio",
  tags: ["audio"],
  summary: "Upload audio file",
  description: "Upload an audio file for an episode",
  request: {
    params: AudioParamsSchema,
    body: {
      content: {
        "multipart/form-data": {
          schema: {
            type: "object",
            properties: {
              audio: {
                type: "string",
                format: "binary",
                description: "Audio file to upload"
              }
            },
            required: ["audio"]
          }
        }
      }
    }
  },
  responses: {
    201: {
      content: {
        "application/json": {
          schema: AudioUploadSchema
        }
      },
      description: "Audio uploaded successfully"
    },
    404: {
      description: "Episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
var getAudioRoute = createRoute({
  method: "get",
  path: "/shows/{show_id}/episodes/{episode_id}/audio",
  tags: ["audio"],
  summary: "Get audio metadata",
  description: "Get metadata for an episode's audio file",
  request: {
    params: AudioParamsSchema
  },
  responses: {
    200: {
      content: {
        "application/json": {
          schema: AudioUploadSchema
        }
      },
      description: "Audio metadata"
    },
    404: {
      description: "Audio or episode not found"
    }
  },
  security: [{ Bearer: [] }]
});
function registerAudioRoutes(app, audioService) {
  app.openapi(uploadAudioRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasWritePermission = hasPermissions(payload, ["podcast:write"]);
    const hasWriteScope = hasScopes(payload, ["podcast.write"]);
    if (!hasWritePermission && !hasWriteScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:write or scope: podcast.write",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    try {
      const formData = await c2.req.formData();
      const audioFile = formData.get("audio");
      if (!audioFile) {
        const problem = {
          type: "validation_error",
          title: "Validation Error",
          status: 400,
          detail: "Audio file is required",
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem) });
      }
      const buffer = Buffer.from(await audioFile.arrayBuffer());
      const fileData = {
        fileName: audioFile.name,
        fileSize: audioFile.size,
        mimeType: audioFile.type,
        buffer
      };
      const upload = await audioService.uploadAudio(show_id, episode_id, fileData);
      return c2.json(upload, 201);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        const problem = {
          type: "not_found",
          title: "Not Found",
          status: 404,
          detail: "Episode not found",
          instance: c2.req.path
        };
        throw new HTTPException(404, { message: JSON.stringify(problem) });
      }
      console.error("Audio upload error:", error3);
      throw error3;
    }
  });
  app.openapi(getAudioRoute, async (c2) => {
    const payload = c2.get("jwtPayload");
    const hasReadPermission = hasPermissions(payload, ["podcast:read"]);
    const hasReadScope = hasScopes(payload, ["podcast.read"]);
    if (!hasReadPermission && !hasReadScope) {
      const problem = {
        type: "forbidden",
        title: "Forbidden",
        status: 403,
        detail: "Required permissions: podcast:read or scope: podcast.read",
        instance: c2.req.path
      };
      throw new HTTPException(403, { message: JSON.stringify(problem) });
    }
    const { show_id, episode_id } = c2.req.valid("param");
    const audio = await audioService.getAudioMetadata(show_id, episode_id);
    if (!audio) {
      const problem = {
        type: "not_found",
        title: "Not Found",
        status: 404,
        detail: "Audio not found",
        instance: c2.req.path
      };
      throw new HTTPException(404, { message: JSON.stringify(problem) });
    }
    return c2.json(audio);
  });
}
__name(registerAudioRoutes, "registerAudioRoutes");

// dist/feed/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
init_zod();
var FeedParamsSchema = external_exports.object({
  show_id: external_exports.string().uuid()
});
var getShowFeedRoute = createRoute({
  method: "get",
  path: "/feeds/{show_id}",
  tags: ["feeds"],
  summary: "Get RSS feed for show",
  description: "Generate RSS feed for the podcast show (no authentication required)",
  request: {
    params: FeedParamsSchema
  },
  responses: {
    200: {
      content: {
        "application/rss+xml": {
          schema: external_exports.string()
        }
      },
      description: "RSS feed"
    },
    404: {
      description: "Show not found"
    }
  }
});
function generateRSSFeed(show, episodes2, audioService) {
  const now = (/* @__PURE__ */ new Date()).toUTCString();
  let imageUrl = show.imageUrl;
  if (audioService && show.imageUrl && show.imageUrl.startsWith("r2://")) {
    imageUrl = show.imageUrl.replace("r2://", "https://podcast-service-assets.sesamy.dev/");
  }
  const episodeItems = episodes2.filter((episode) => episode.published).map((episode) => {
    let audioUrl = episode.audioUrl;
    if (audioService && episode.audioUrl && episode.audioUrl.startsWith("r2://")) {
      audioUrl = episode.audioUrl.replace("r2://", "https://podcast-service-assets.sesamy.dev/");
    }
    return `
    <item>
      <title><![CDATA[${episode.title || "Untitled Episode"}]]></title>
      <description><![CDATA[${episode.description || ""}]]></description>
      <pubDate>${new Date(episode.createdAt).toUTCString()}</pubDate>
      <guid isPermaLink="false">${episode.id}</guid>
      ${audioUrl ? `<enclosure url="${audioUrl}" type="audio/mpeg" length="0"/>` : ""}
    </item>`;
  }).join("");
  return `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd">
  <channel>
    <title><![CDATA[${show.title || "Untitled Show"}]]></title>
    <description><![CDATA[${show.description || ""}]]></description>
    <link>https://podcast-service.sesamy.dev/shows/${show.id}</link>
    <language>en-us</language>
    <pubDate>${now}</pubDate>
    <lastBuildDate>${now}</lastBuildDate>
    <generator>Sesamy Podcast Service</generator>
    ${imageUrl ? `<image><url>${imageUrl}</url><title><![CDATA[${show.title || "Untitled Show"}]]></title><link>https://podcast-service.sesamy.dev/shows/${show.id}</link></image>` : ""}
    ${imageUrl ? `<itunes:image href="${imageUrl}"/>` : ""}
    <itunes:category text="Technology"/>
    <itunes:explicit>false</itunes:explicit>
    ${episodeItems}
  </channel>
</rss>`;
}
__name(generateRSSFeed, "generateRSSFeed");
function registerFeedRoutes(app, showService, episodeRepository, audioService) {
  app.openapi(getShowFeedRoute, async (c2) => {
    const { show_id } = c2.req.valid("param");
    const show = await showService.getShowByIdPublic(show_id);
    if (!show) {
      const problem = {
        type: "not_found",
        title: "Not Found",
        status: 404,
        detail: "Show not found",
        instance: c2.req.path
      };
      throw new HTTPException(404, { message: JSON.stringify(problem) });
    }
    const episodes2 = await episodeRepository.findByShowId(show_id, {
      limit: 100,
      offset: 0
    });
    const rssFeed = generateRSSFeed(show, episodes2, audioService);
    c2.header("Content-Type", "application/rss+xml");
    return c2.text(rssFeed);
  });
}
__name(registerFeedRoutes, "registerFeedRoutes");

// dist/tasks/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
init_zod();
init_service2();
init_errors2();
var TaskStatusSchema = external_exports.enum(["pending", "processing", "done", "failed"]);
var TaskTypeSchema = external_exports.enum(["audio_processing"]);
var TaskSchema = external_exports.object({
  id: external_exports.number(),
  type: TaskTypeSchema,
  status: TaskStatusSchema,
  payload: external_exports.any().optional().nullable(),
  result: external_exports.any().optional().nullable(),
  error: external_exports.string().optional().nullable(),
  attempts: external_exports.number(),
  started_at: external_exports.string().optional().nullable(),
  progress: external_exports.number().optional().nullable(),
  created_at: external_exports.string(),
  updated_at: external_exports.string()
});
var CreateTaskSchema = external_exports.object({
  type: TaskTypeSchema,
  payload: external_exports.any().optional()
});
var TaskQuerySchema = external_exports.object({
  status: TaskStatusSchema.optional(),
  limit: external_exports.coerce.number().min(1).max(100).optional().default(10),
  offset: external_exports.coerce.number().min(0).optional().default(0),
  sortBy: external_exports.enum(["created_at", "updated_at", "type", "status"]).optional().default("created_at"),
  sortOrder: external_exports.enum(["asc", "desc"]).optional().default("desc")
});
var TaskParamsSchema = external_exports.object({
  task_id: external_exports.coerce.number()
});
var TestEncodeSchema = external_exports.object({
  audioUrl: external_exports.string().url().optional(),
  outputFormat: external_exports.enum(["mp3", "aac"]).optional().default("mp3"),
  bitrate: external_exports.coerce.number().min(64).max(320).optional().default(128)
});
var TestAudioPreprocessSchema = external_exports.object({
  audioUrl: external_exports.string().url().optional(),
  episodeId: external_exports.string().optional()
});
var createTaskRoute = createRoute({
  method: "post",
  path: "/tasks",
  tags: ["tasks"],
  summary: "Create a new task",
  description: "Create a new background processing task",
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: CreateTaskSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Task created successfully",
      content: {
        "application/json": {
          schema: TaskSchema
        }
      }
    },
    400: {
      description: "Invalid request"
    },
    401: {
      description: "Unauthorized"
    }
  }
});
var getTasksRoute = createRoute({
  method: "get",
  path: "/tasks",
  tags: ["tasks"],
  summary: "List tasks",
  description: "Get a list of tasks with optional status filtering and sorting. Default sort is by created_at in descending order (newest first).",
  security: [{ Bearer: [] }],
  request: {
    query: TaskQuerySchema
  },
  responses: {
    200: {
      description: "List of tasks",
      content: {
        "application/json": {
          schema: external_exports.array(TaskSchema)
        }
      }
    },
    401: {
      description: "Unauthorized"
    }
  }
});
var getTaskRoute = createRoute({
  method: "get",
  path: "/tasks/{task_id}",
  tags: ["tasks"],
  summary: "Get a specific task",
  description: "Get details of a specific task by ID",
  security: [{ Bearer: [] }],
  request: {
    params: TaskParamsSchema
  },
  responses: {
    200: {
      description: "Task details",
      content: {
        "application/json": {
          schema: TaskSchema
        }
      }
    },
    404: {
      description: "Task not found"
    },
    401: {
      description: "Unauthorized"
    }
  }
});
var retryTaskRoute = createRoute({
  method: "post",
  path: "/tasks/{task_id}/retry",
  tags: ["tasks"],
  summary: "Retry a failed task",
  description: "Reset a failed task to pending status and queue it for retry",
  security: [{ Bearer: [] }],
  request: {
    params: TaskParamsSchema
  },
  responses: {
    200: {
      description: "Task retried successfully",
      content: {
        "application/json": {
          schema: TaskSchema
        }
      }
    },
    404: {
      description: "Task not found"
    },
    401: {
      description: "Unauthorized"
    },
    400: {
      description: "Task cannot be retried"
    }
  }
});
var createTaskRoutes = /* @__PURE__ */ __name((database) => {
  const app = new OpenAPIHono();
  const taskService = new TaskService(database);
  const serializeTask = /* @__PURE__ */ __name((task) => ({
    ...task,
    payload: task.payload ? JSON.parse(task.payload) : null,
    result: task.result ? JSON.parse(task.result) : null
  }), "serializeTask");
  app.use("*", requireAuth(["podcast:read", "podcast:write"]));
  app.openapi(createTaskRoute, async (c2) => {
    const body = c2.req.valid("json");
    const organizationId = getOrgIdFromContext(c2);
    const task = await taskService.createTask(body.type, body.payload, organizationId);
    return c2.json(serializeTask(task), 201);
  });
  app.openapi(getTasksRoute, async (c2) => {
    const query = c2.req.valid("query");
    const organizationId = getOrgIdFromContext(c2);
    const tasks2 = await taskService.getTasks(query.status, query.limit, query.offset, query.sortBy, query.sortOrder, organizationId);
    return c2.json(tasks2.map(serializeTask));
  });
  app.openapi(getTaskRoute, async (c2) => {
    const { task_id } = c2.req.valid("param");
    const organizationId = getOrgIdFromContext(c2);
    const task = await taskService.getTask(task_id, organizationId);
    if (!task) {
      throw new NotFoundError(`Task with ID ${task_id} not found`);
    }
    return c2.json(serializeTask(task));
  });
  app.openapi(retryTaskRoute, async (c2) => {
    const { task_id } = c2.req.valid("param");
    const organizationId = getOrgIdFromContext(c2);
    try {
      const task = await taskService.retryTask(task_id, organizationId);
      return c2.json(serializeTask(task));
    } catch (error3) {
      if (error3 instanceof Error) {
        if (error3.message === "Task not found") {
          throw new NotFoundError(`Task with ID ${task_id} not found`);
        }
        throw new HTTPException(400, { message: error3.message });
      }
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  return app;
}, "createTaskRoutes");

// dist/workflows/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
init_zod();
var WorkflowStatusSchema = external_exports.enum([
  "queued",
  "running",
  "paused",
  "completed",
  "failed",
  "cancelled",
  "terminated"
]);
var WorkflowTypeSchema = external_exports.enum([
  "transcription",
  "audio-processing",
  "encoding",
  "custom"
]);
var workflowInstanceSchema = external_exports.object({
  id: external_exports.string(),
  workflowName: external_exports.string(),
  status: WorkflowStatusSchema,
  createdAt: external_exports.string(),
  updatedAt: external_exports.string(),
  completedAt: external_exports.string().optional(),
  episodeId: external_exports.string().optional(),
  metadata: external_exports.record(external_exports.any()).optional(),
  error: external_exports.string().optional(),
  progress: external_exports.record(external_exports.any()).optional(),
  estimatedProgress: external_exports.number().min(0).max(100).optional(),
  estimatedDuration: external_exports.string().optional(),
  actualDuration: external_exports.number().optional()
});
var WorkflowQuerySchema = external_exports.object({
  status: WorkflowStatusSchema.optional(),
  workflowType: WorkflowTypeSchema.optional(),
  episodeId: external_exports.string().optional(),
  limit: external_exports.coerce.number().int().min(1).max(100).default(20),
  offset: external_exports.coerce.number().int().min(0).default(0),
  sortBy: external_exports.enum(["createdAt", "updatedAt", "status"]).default("createdAt"),
  sortOrder: external_exports.enum(["asc", "desc"]).default("desc")
});
var WorkflowSearchSchema = external_exports.object({
  episodeId: external_exports.string().optional(),
  status: WorkflowStatusSchema.optional(),
  workflowType: external_exports.string().optional(),
  dateFrom: external_exports.string().optional(),
  dateTo: external_exports.string().optional()
});
var audioProcessingWorkflowSchema = external_exports.object({
  episodeId: external_exports.string().min(1),
  audioR2Key: external_exports.string().min(1),
  chunkDuration: external_exports.number().int().min(10).max(300).default(60),
  overlapDuration: external_exports.number().int().min(0).max(10).default(2),
  encodingFormats: external_exports.array(external_exports.string()).default(["mp3_128"]),
  transcriptionLanguage: external_exports.string().optional().default("en")
  // Force language to avoid mixed language issues
});
async function fetchWorkflowInstancesFromCloudflare(accountId, workflowName, apiToken) {
  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/workflows/${workflowName}/instances`;
  try {
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${apiToken}`,
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) {
      console.error(`Cloudflare API error: ${response.status} ${response.statusText}`);
      return [];
    }
    const data = await response.json();
    if (!data.success || !data.result) {
      console.error(`Cloudflare API error:`, data.errors);
      return [];
    }
    return data.result.map((instance) => ({
      id: instance.id,
      workflowName,
      status: mapCloudflareStatusToOurStatus(instance.status),
      createdAt: instance.created_on,
      updatedAt: instance.created_on,
      // Cloudflare doesn't provide updated_at
      completedAt: instance.ended_on,
      metadata: {
        version_id: instance.version_id,
        cloudflare_status: instance.status
      }
    }));
  } catch (error3) {
    console.error("Error fetching workflow instances from Cloudflare:", error3);
    return [];
  }
}
__name(fetchWorkflowInstancesFromCloudflare, "fetchWorkflowInstancesFromCloudflare");
function mapCloudflareStatusToOurStatus(cloudflareStatus) {
  const statusMap = {
    running: "running",
    complete: "completed",
    failed: "failed",
    paused: "paused",
    terminated: "terminated",
    queued: "queued"
  };
  return statusMap[cloudflareStatus] || "queued";
}
__name(mapCloudflareStatusToOurStatus, "mapCloudflareStatusToOurStatus");
var healthRoute = createRoute({
  method: "get",
  path: "/workflows/health",
  tags: ["workflows"],
  summary: "Workflow system health check",
  description: "Check if the workflow system is operational and get available workflows",
  responses: {
    200: {
      description: "Workflow system status",
      content: {
        "application/json": {
          schema: external_exports.object({
            success: external_exports.boolean(),
            status: external_exports.string(),
            workflows: external_exports.array(external_exports.object({
              name: external_exports.string(),
              type: external_exports.string(),
              available: external_exports.boolean()
            })),
            endpoints: external_exports.array(external_exports.string()),
            timestamp: external_exports.string()
          })
        }
      }
    }
  },
  security: [{ Bearer: [] }]
});
var listInstancesRoute = createRoute({
  method: "get",
  path: "/workflows/instances",
  tags: ["workflows"],
  summary: "List workflow instances",
  description: "Get a paginated list of workflow instances with optional filtering",
  request: {
    query: WorkflowQuerySchema
  },
  responses: {
    200: {
      description: "List of workflow instances",
      content: {
        "application/json": {
          schema: external_exports.object({
            success: external_exports.boolean(),
            workflows: external_exports.array(workflowInstanceSchema),
            pagination: external_exports.object({
              total: external_exports.number(),
              limit: external_exports.number(),
              offset: external_exports.number(),
              hasMore: external_exports.boolean()
            }),
            filters: WorkflowQuerySchema.partial()
          })
        }
      }
    }
  },
  security: [{ Bearer: [] }]
});
var statsRoute = createRoute({
  method: "get",
  path: "/workflows/instances/stats",
  tags: ["workflows"],
  summary: "Get workflow statistics",
  description: "Get aggregated statistics about workflow instances",
  responses: {
    200: {
      description: "Workflow statistics",
      content: {
        "application/json": {
          schema: external_exports.object({
            success: external_exports.boolean(),
            stats: external_exports.object({
              total: external_exports.number(),
              byStatus: external_exports.record(external_exports.string(), external_exports.number()),
              byType: external_exports.record(external_exports.string(), external_exports.number()),
              averageDuration: external_exports.number().optional(),
              recentActivity: external_exports.object({
                last24h: external_exports.number(),
                last7d: external_exports.number(),
                last30d: external_exports.number()
              }),
              successRate: external_exports.number().min(0).max(100)
            }),
            generatedAt: external_exports.string()
          })
        }
      }
    }
  },
  security: [{ Bearer: [] }]
});
var getInstanceRoute = createRoute({
  method: "get",
  path: "/workflows/instances/{workflowId}",
  tags: ["workflows"],
  summary: "Get workflow instance details",
  description: "Get detailed information about a specific workflow instance",
  request: {
    params: external_exports.object({
      workflowId: external_exports.string().min(1)
    })
  },
  responses: {
    200: {
      description: "Workflow instance details",
      content: {
        "application/json": {
          schema: external_exports.object({
            success: external_exports.boolean(),
            workflow: workflowInstanceSchema
          })
        }
      }
    },
    404: {
      description: "Workflow not found"
    }
  },
  security: [{ Bearer: [] }]
});
var audioProcessingRoute = createRoute({
  method: "post",
  path: "/workflows/audio-processing",
  tags: ["workflows"],
  summary: "Start audio processing workflow",
  description: "Starts a durable workflow that processes audio with encoding and transcription in parallel",
  request: {
    body: {
      content: {
        "application/json": {
          schema: audioProcessingWorkflowSchema
        }
      }
    }
  },
  responses: {
    202: {
      description: "Workflow started successfully",
      content: {
        "application/json": {
          schema: external_exports.object({
            success: external_exports.boolean(),
            message: external_exports.string(),
            workflowId: external_exports.string(),
            instanceId: external_exports.string(),
            status: external_exports.string(),
            episodeId: external_exports.string(),
            estimatedDuration: external_exports.string()
          })
        }
      }
    },
    400: {
      description: "Invalid request body"
    }
  },
  security: [{ Bearer: [] }]
});
function createWorkflowRoutes() {
  const app = new OpenAPIHono();
  app.use("*", authMiddleware);
  app.openapi(healthRoute, async (c2) => {
    const env2 = c2.env;
    return c2.json({
      success: true,
      status: "healthy",
      workflows: [
        {
          name: "audio-processing",
          type: "audio-processing",
          available: !!env2.AUDIO_PROCESSING_WORKFLOW
        }
      ],
      endpoints: [
        "GET /workflows/health",
        "GET /workflows/instances",
        "GET /workflows/instances/{workflowId}",
        "GET /workflows/instances/stats",
        "POST /workflows/transcription",
        "POST /workflows/audio-processing"
      ],
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
  app.openapi(listInstancesRoute, async (c2) => {
    try {
      const query = c2.req.valid("query");
      const env2 = c2.env;
      let allWorkflows = [];
      if (env2.CLOUDFLARE_ACCOUNT_ID && env2.CLOUDFLARE_API_TOKEN) {
        const cloudflareInstances = await fetchWorkflowInstancesFromCloudflare(
          env2.CLOUDFLARE_ACCOUNT_ID,
          "audio-processing-workflow",
          // This should match your workflow name in Cloudflare
          env2.CLOUDFLARE_API_TOKEN
        );
        allWorkflows = cloudflareInstances;
      } else {
        console.warn("Cloudflare API credentials not configured, returning empty list");
      }
      let filteredWorkflows = allWorkflows;
      if (query.status) {
        filteredWorkflows = filteredWorkflows.filter((w) => w.status === query.status);
      }
      if (query.episodeId) {
        filteredWorkflows = filteredWorkflows.filter((w) => w.metadata?.episodeId === query.episodeId);
      }
      filteredWorkflows.sort((a, b2) => {
        const aValue = a[query.sortBy] || "";
        const bValue = b2[query.sortBy] || "";
        if (query.sortOrder === "desc") {
          return bValue.localeCompare(aValue);
        } else {
          return aValue.localeCompare(bValue);
        }
      });
      const total = filteredWorkflows.length;
      const paginatedWorkflows = filteredWorkflows.slice(query.offset, query.offset + query.limit);
      return c2.json({
        success: true,
        workflows: paginatedWorkflows,
        pagination: {
          total,
          limit: query.limit,
          offset: query.offset,
          hasMore: total > query.offset + query.limit
        },
        filters: {
          status: query.status,
          workflowType: query.workflowType,
          episodeId: query.episodeId
        }
      });
    } catch (error3) {
      console.error("Failed to list workflow instances:", error3);
      throw new HTTPException(500, {
        message: error3 instanceof Error ? error3.message : "Unknown error"
      });
    }
  });
  app.openapi(statsRoute, async (c2) => {
    try {
      const stats = {
        total: 0,
        byStatus: {},
        byType: {},
        recentActivity: {
          last24h: 0,
          last7d: 0,
          last30d: 0
        },
        successRate: 0,
        averageDuration: void 0
      };
      return c2.json({
        success: true,
        stats,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error3) {
      console.error("Failed to get workflow stats:", error3);
      throw new HTTPException(500, {
        message: error3 instanceof Error ? error3.message : "Unknown error"
      });
    }
  });
  app.openapi(getInstanceRoute, async (c2) => {
    try {
      const { workflowId } = c2.req.valid("param");
      const problem = {
        type: "not_found",
        title: "Not Found",
        status: 404,
        detail: "Workflow not found",
        instance: c2.req.path
      };
      throw new HTTPException(404, { message: JSON.stringify(problem) });
    } catch (error3) {
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      console.error("Failed to get workflow instance:", error3);
      throw new HTTPException(500, {
        message: error3 instanceof Error ? error3.message : "Unknown error"
      });
    }
  });
  app.openapi(audioProcessingRoute, async (c2) => {
    try {
      const env2 = c2.env;
      const body = c2.req.valid("json");
      const instanceId = crypto.randomUUID();
      const instance = await env2.AUDIO_PROCESSING_WORKFLOW.create({
        id: instanceId,
        params: body
      });
      return c2.json({
        success: true,
        message: "Audio processing workflow started successfully",
        workflowId: "audio-processing",
        instanceId: instance.id,
        status: "queued",
        episodeId: body.episodeId,
        estimatedDuration: "5-15 minutes"
      }, 202);
    } catch (error3) {
      console.error("Failed to start audio processing workflow:", error3);
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      if (error3 instanceof Error && error3.message.includes("validation")) {
        const problem = {
          type: "bad_request",
          title: "Bad Request",
          status: 400,
          detail: error3.message,
          instance: c2.req.path
        };
        throw new HTTPException(400, { message: JSON.stringify(problem) });
      }
      throw new HTTPException(500, {
        message: error3 instanceof Error ? error3.message : "Unknown error"
      });
    }
  });
  return app;
}
__name(createWorkflowRoutes, "createWorkflowRoutes");

// dist/storage/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/utils/storage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var StorageService = class {
  static {
    __name(this, "StorageService");
  }
  env;
  constructor(env2) {
    this.env = env2;
  }
  /**
   * Generate a signed URL for internal use
   */
  async generateSignedUrl(options, baseUrl) {
    const { path, method, expiresIn = 3600, contentType } = options;
    const expires = Math.floor(Date.now() / 1e3) + expiresIn;
    const signature = await this.createSignature(method, path, expires);
    const params = new URLSearchParams({
      path,
      expire: expires.toString(),
      signature
    });
    if (contentType && method === "PUT") {
      params.set("contentType", contentType);
    }
    const relativePath = `/storage/file?${params.toString()}`;
    const fullUrl = baseUrl ? `${baseUrl}${relativePath}` : relativePath;
    return {
      url: fullUrl,
      expires: new Date(expires * 1e3),
      signature
    };
  }
  /**
   * Verify a signed URL request
   */
  async verifySignature(method, path, expire, signature) {
    const expireTime = parseInt(expire);
    const currentTime = Math.floor(Date.now() / 1e3);
    if (currentTime > expireTime) {
      return false;
    }
    const expectedSignature = await this.createSignature(method, path, expireTime);
    return expectedSignature === signature;
  }
  /**
   * Create HMAC signature for method + path + expire
   */
  async createSignature(method, path, expire) {
    const message2 = `${method}:${path}:${expire}`;
    const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(this.env.STORAGE_SIGNATURE_SECRET), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const signature = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(message2));
    return btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  /**
   * Upload a file to the specified path
   */
  async uploadFile(path, data, options) {
    const objectKey = path.startsWith("/") ? path.substring(1) : path;
    const uploadOptions = {};
    if (options?.contentType) {
      uploadOptions.httpMetadata = {
        contentType: options.contentType
      };
    }
    const result = await this.env.BUCKET.put(objectKey, data, uploadOptions);
    return {
      key: result.key,
      etag: result.etag,
      size: result.size,
      uploaded: result.uploaded
    };
  }
  /**
   * Download a file from the specified path
   */
  async downloadFile(path) {
    const objectKey = path.startsWith("/") ? path.substring(1) : path;
    const object = await this.env.BUCKET.get(objectKey);
    if (!object) {
      throw new Error(`Object not found: ${objectKey}`);
    }
    return {
      data: object.body,
      size: object.size,
      etag: object.etag,
      uploaded: object.uploaded,
      httpMetadata: object.httpMetadata
    };
  }
  /**
   * Delete a file at the specified path
   */
  async deleteFile(path) {
    const objectKey = path.startsWith("/") ? path.substring(1) : path;
    await this.env.BUCKET.delete(objectKey);
    return { deleted: objectKey };
  }
  /**
   * Check if a file exists at the specified path
   */
  async fileExists(path) {
    try {
      const objectKey = path.startsWith("/") ? path.substring(1) : path;
      const object = await this.env.BUCKET.head(objectKey);
      return object !== null;
    } catch {
      return false;
    }
  }
  /**
   * Get file metadata
   */
  async getFileInfo(path) {
    const objectKey = path.startsWith("/") ? path.substring(1) : path;
    return await this.env.BUCKET.head(objectKey);
  }
  /**
   * List objects with optional prefix
   */
  async listObjects(prefix, limit) {
    const options = {};
    if (prefix)
      options.prefix = prefix;
    if (limit)
      options.limit = limit;
    const result = await this.env.BUCKET.list(options);
    return {
      objects: result.objects.map((obj) => ({
        key: obj.key,
        size: obj.size,
        uploaded: obj.uploaded,
        etag: obj.etag
      })),
      truncated: result.truncated
    };
  }
};
async function generateSignedUploadUrl(env2, path, contentType, expiresIn) {
  const storage2 = new StorageService(env2);
  return storage2.generateSignedUrl({
    path,
    method: "PUT",
    contentType,
    expiresIn
  }, env2.SERVICE_BASE_URL);
}
__name(generateSignedUploadUrl, "generateSignedUploadUrl");
async function generateSignedDownloadUrl(env2, path, expiresIn) {
  const storage2 = new StorageService(env2);
  return storage2.generateSignedUrl({
    path,
    method: "GET",
    expiresIn
  }, env2.SERVICE_BASE_URL);
}
__name(generateSignedDownloadUrl, "generateSignedDownloadUrl");

// dist/storage/routes.js
var storage = new Hono2();
storage.all("/file", async (c2) => {
  const method = c2.req.method;
  const path = c2.req.query("path");
  const expire = c2.req.query("expire");
  const signature = c2.req.query("signature");
  const contentType = c2.req.query("contentType");
  if (!path || !expire || !signature) {
    return c2.json({ error: "Missing required parameters: path, expire, signature" }, 400);
  }
  const storageService = new StorageService(c2.env);
  const isValid2 = await storageService.verifySignature(method, path, expire, signature);
  if (!isValid2) {
    return c2.json({ error: "Invalid or expired signature" }, 403);
  }
  try {
    if (method === "GET") {
      const file = await storageService.downloadFile(path);
      const headers = {};
      if (file.httpMetadata?.contentType) {
        headers["Content-Type"] = file.httpMetadata.contentType;
      }
      if (file.httpMetadata?.cacheControl) {
        headers["Cache-Control"] = file.httpMetadata.cacheControl;
      }
      return new Response(file.data, {
        status: 200,
        headers
      });
    } else if (method === "PUT") {
      const body = await c2.req.arrayBuffer();
      const result = await storageService.uploadFile(path, body, {
        contentType: contentType || "application/octet-stream"
      });
      return c2.json({
        success: true,
        key: result.key,
        size: result.size,
        etag: result.etag,
        uploaded: result.uploaded
      });
    } else {
      return c2.json({ error: `Method ${method} not supported` }, 405);
    }
  } catch (error3) {
    console.error("Storage operation failed:", error3);
    if (error3 instanceof Error && error3.message.includes("not found")) {
      return c2.json({ error: "File not found" }, 404);
    }
    return c2.json({
      error: "Storage operation failed",
      details: error3 instanceof Error ? error3.message : String(error3)
    }, 500);
  }
});
storage.get("/health", async (c2) => {
  return c2.json({ status: "ok", service: "storage" });
});
var routes_default = storage;

// dist/campaigns/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
init_zod();

// dist/campaigns/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
var CampaignStatus = external_exports.enum(["draft", "active", "paused", "ended"]);
var PlacementType = external_exports.enum(["pre", "mid", "post", "any"]);
var CreativeType = external_exports.enum(["audio", "video", "display"]);
var CampaignSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  advertiser: external_exports.string().nullable(),
  startDate: external_exports.string().nullable(),
  endDate: external_exports.string().nullable(),
  targetImpressions: external_exports.number().nullable(),
  priority: external_exports.number(),
  status: CampaignStatus,
  createdAt: external_exports.string(),
  updatedAt: external_exports.string()
});
var CreateCampaignSchema = external_exports.object({
  name: external_exports.string().min(1, "Campaign name is required"),
  advertiser: external_exports.string().optional(),
  startDate: external_exports.string().refine((date) => !isNaN(Date.parse(date)), {
    message: "Invalid start date format"
  }).optional(),
  endDate: external_exports.string().refine((date) => !isNaN(Date.parse(date)), {
    message: "Invalid end date format"
  }).optional(),
  targetImpressions: external_exports.number().positive().optional(),
  priority: external_exports.number().min(1).max(10).default(5),
  status: CampaignStatus.default("draft"),
  showIds: external_exports.array(external_exports.string()).min(1, "At least one show must be selected").optional()
}).refine((data) => {
  if (data.status === "active") {
    return data.startDate && data.endDate && data.showIds;
  }
  return true;
}, {
  message: "startDate, endDate, and showIds are required when status is active"
}).refine((data) => {
  if (data.startDate && data.endDate) {
    return new Date(data.startDate) < new Date(data.endDate);
  }
  return true;
}, {
  message: "End date must be after start date",
  path: ["endDate"]
});
var UpdateCampaignBaseSchema = external_exports.object({
  name: external_exports.string().min(1, "Campaign name is required").optional(),
  advertiser: external_exports.string().optional(),
  startDate: external_exports.string().refine((date) => !isNaN(Date.parse(date)), {
    message: "Invalid start date format"
  }).optional(),
  endDate: external_exports.string().refine((date) => !isNaN(Date.parse(date)), {
    message: "Invalid end date format"
  }).optional(),
  targetImpressions: external_exports.number().positive().optional(),
  priority: external_exports.number().min(1).max(10).optional(),
  status: CampaignStatus.optional(),
  showIds: external_exports.array(external_exports.string()).optional()
});
var UpdateCampaignSchema = UpdateCampaignBaseSchema.refine((data) => {
  if (data.status === "active") {
    return data.startDate && data.endDate && data.showIds;
  }
  return true;
}, {
  message: "startDate, endDate, and showIds are required when status is active"
}).refine((data) => {
  if (data.startDate && data.endDate) {
    return new Date(data.startDate) < new Date(data.endDate);
  }
  return true;
}, {
  message: "End date must be after start date",
  path: ["endDate"]
});
var CreativeSchema = external_exports.object({
  id: external_exports.string(),
  campaignId: external_exports.string(),
  name: external_exports.string(),
  type: CreativeType,
  audioUrl: external_exports.string().nullable(),
  imageUrl: external_exports.string().nullable(),
  duration: external_exports.number().nullable(),
  placementType: PlacementType,
  language: external_exports.string().nullable(),
  createdAt: external_exports.string(),
  updatedAt: external_exports.string()
});
var CreateCreativeSchema = external_exports.object({
  campaignId: external_exports.string(),
  name: external_exports.string().min(1, "Creative name is required"),
  type: CreativeType.default("audio"),
  audioUrl: external_exports.string().url("Invalid audio URL").optional(),
  imageUrl: external_exports.string().url("Invalid image URL").optional(),
  duration: external_exports.number().positive("Duration must be positive").optional(),
  placementType: PlacementType.default("any"),
  language: external_exports.string().length(2).optional()
  // ISO 639-1 language code
});
var UpdateCreativeSchema = CreateCreativeSchema.partial().omit({
  campaignId: true
});
var CampaignWithDetailsSchema = CampaignSchema.extend({
  creatives: external_exports.array(CreativeSchema),
  shows: external_exports.array(external_exports.object({
    id: external_exports.string(),
    title: external_exports.string()
  }))
});
var PaginationSchema3 = external_exports.object({
  page: external_exports.coerce.number().min(1).default(1),
  limit: external_exports.coerce.number().min(1).max(100).default(20)
});
var CampaignParamsSchema = external_exports.object({
  campaign_id: external_exports.string()
});
var CreativeParamsSchema = external_exports.object({
  campaign_id: external_exports.string(),
  creative_id: external_exports.string()
});
var CreativeUploadSchema = external_exports.object({
  id: external_exports.string().uuid(),
  campaignId: external_exports.string().uuid(),
  creativeId: external_exports.string().uuid(),
  fileName: external_exports.string(),
  fileSize: external_exports.number().int().positive(),
  mimeType: external_exports.string(),
  url: external_exports.string().url(),
  uploadedAt: external_exports.string().datetime()
});
var AudioUploadSchema2 = external_exports.object({
  fileName: external_exports.string(),
  fileSize: external_exports.number(),
  mimeType: external_exports.string(),
  url: external_exports.string()
});

// dist/campaigns/routes.js
init_errors2();
async function signUrlsInCreative(creative, audioService) {
  const result = { ...creative };
  if (!audioService) {
    return result;
  }
  if (creative.audioUrl && creative.audioUrl.startsWith("r2://")) {
    try {
      const r2Key = creative.audioUrl.replace("r2://", "");
      const signedUrl = await audioService.generateSignedUrlFromKey(r2Key);
      if (signedUrl) {
        result.audioUrl = signedUrl;
      }
    } catch (error3) {
      console.warn("Failed to sign audioUrl for creative:", creative.id, error3);
    }
  }
  if (creative.imageUrl && creative.imageUrl.startsWith("r2://")) {
    try {
      const r2Key = creative.imageUrl.replace("r2://", "");
      const signedUrl = await audioService.generateSignedUrlFromKey(r2Key);
      if (signedUrl) {
        result.imageUrl = signedUrl;
      }
    } catch (error3) {
      console.warn("Failed to sign imageUrl for creative:", creative.id, error3);
    }
  }
  return result;
}
__name(signUrlsInCreative, "signUrlsInCreative");
function createCampaignRoutes(campaignService, audioService, creativeUploadService) {
  const app = new OpenAPIHono();
  app.use("*", requireAuth(["campaigns:read", "campaigns:write"]));
  app.openapi({
    method: "get",
    path: "/campaigns",
    tags: ["campaigns"],
    summary: "Get campaigns",
    description: "Get all campaigns with pagination",
    request: {
      query: PaginationSchema3
    },
    responses: {
      200: {
        description: "Campaigns retrieved successfully",
        content: {
          "application/json": {
            schema: external_exports.object({
              data: external_exports.array(CampaignSchema),
              pagination: external_exports.object({
                page: external_exports.number(),
                limit: external_exports.number(),
                total: external_exports.number(),
                totalPages: external_exports.number()
              })
            })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const query = c2.req.valid("query");
    try {
      const result = await campaignService.getAllCampaigns(query, organizationId);
      return c2.json(result, 200);
    } catch (error3) {
      console.error("Error getting campaigns:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "get",
    path: "/campaigns/{campaign_id}",
    tags: ["campaigns"],
    summary: "Get campaign by ID",
    description: "Get a single campaign with its creatives and shows",
    request: {
      params: CampaignParamsSchema
    },
    responses: {
      200: {
        description: "Campaign retrieved successfully",
        content: {
          "application/json": {
            schema: CampaignWithDetailsSchema
          }
        }
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    try {
      const campaign = await campaignService.getCampaignByIdWithDetails(campaign_id, organizationId);
      if (!campaign) {
        throw new HTTPException(404, { message: "Campaign not found" });
      }
      if (audioService && campaign.creatives) {
        campaign.creatives = await Promise.all(campaign.creatives.map((creative) => signUrlsInCreative(creative, audioService)));
      }
      return c2.json(campaign, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error getting campaign:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "post",
    path: "/campaigns",
    tags: ["campaigns"],
    summary: "Create campaign",
    description: "Create a new advertising campaign",
    request: {
      body: {
        content: {
          "application/json": {
            schema: CreateCampaignSchema
          }
        }
      }
    },
    responses: {
      201: {
        description: "Campaign created successfully",
        content: {
          "application/json": {
            schema: CampaignSchema
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const body = c2.req.valid("json");
    try {
      const campaign = await campaignService.createCampaign(body, organizationId);
      return c2.json(campaign, 201);
    } catch (error3) {
      console.error("Error creating campaign:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "put",
    path: "/campaigns/{campaign_id}",
    tags: ["campaigns"],
    summary: "Update campaign",
    description: "Update an existing campaign",
    request: {
      params: CampaignParamsSchema,
      body: {
        content: {
          "application/json": {
            schema: UpdateCampaignSchema
          }
        }
      }
    },
    responses: {
      200: {
        description: "Campaign updated successfully",
        content: {
          "application/json": {
            schema: CampaignSchema
          }
        }
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    const body = c2.req.valid("json");
    try {
      const campaign = await campaignService.updateCampaign(campaign_id, body, organizationId);
      return c2.json(campaign, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error updating campaign:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "patch",
    path: "/campaigns/{campaign_id}",
    tags: ["campaigns"],
    summary: "Patch campaign",
    description: "Partially update an existing campaign (only provided fields will be updated)",
    request: {
      params: CampaignParamsSchema,
      body: {
        content: {
          "application/json": {
            schema: UpdateCampaignSchema
          }
        }
      }
    },
    responses: {
      200: {
        description: "Campaign updated successfully",
        content: {
          "application/json": {
            schema: CampaignSchema
          }
        }
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    const body = c2.req.valid("json");
    try {
      const campaign = await campaignService.updateCampaign(campaign_id, body, organizationId);
      return c2.json(campaign, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error patching campaign:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "delete",
    path: "/campaigns/{campaign_id}",
    tags: ["campaigns"],
    summary: "Delete campaign",
    description: "Delete a campaign and all its creatives",
    request: {
      params: CampaignParamsSchema
    },
    responses: {
      204: {
        description: "Campaign deleted successfully"
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    try {
      const deleted = await campaignService.deleteCampaign(campaign_id, organizationId);
      if (!deleted) {
        throw new HTTPException(404, { message: "Campaign not found" });
      }
      return c2.body(null, 204);
    } catch (error3) {
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      console.error("Error deleting campaign:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "get",
    path: "/campaigns/{campaign_id}/creatives",
    tags: ["creatives"],
    summary: "Get campaign creatives",
    description: "Get all creatives for a campaign",
    request: {
      params: CampaignParamsSchema
    },
    responses: {
      200: {
        description: "Creatives retrieved successfully",
        content: {
          "application/json": {
            schema: external_exports.array(CreativeSchema)
          }
        }
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    try {
      const creatives2 = await campaignService.getCampaignCreatives(campaign_id, organizationId);
      const signedCreatives = audioService ? await Promise.all(creatives2.map((creative) => signUrlsInCreative(creative, audioService))) : creatives2;
      return c2.json(signedCreatives, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error getting campaign creatives:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "post",
    path: "/campaigns/{campaign_id}/creatives",
    tags: ["creatives"],
    summary: "Create creative",
    description: "Create a new creative for a campaign",
    request: {
      params: CampaignParamsSchema,
      body: {
        content: {
          "application/json": {
            schema: CreateCreativeSchema.omit({ campaignId: true })
          }
        }
      }
    },
    responses: {
      201: {
        description: "Creative created successfully",
        content: {
          "application/json": {
            schema: CreativeSchema
          }
        }
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    const body = c2.req.valid("json");
    try {
      const creative = await campaignService.createCreative(campaign_id, body, organizationId);
      const signedCreative = audioService ? await signUrlsInCreative(creative, audioService) : creative;
      return c2.json(signedCreative, 201);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error creating creative:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "get",
    path: "/campaigns/{campaign_id}/creatives/{creative_id}",
    tags: ["creatives"],
    summary: "Get creative by ID",
    description: "Get a single creative",
    request: {
      params: CreativeParamsSchema
    },
    responses: {
      200: {
        description: "Creative retrieved successfully",
        content: {
          "application/json": {
            schema: CreativeSchema
          }
        }
      },
      404: {
        description: "Creative not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id, creative_id } = c2.req.valid("param");
    try {
      const creative = await campaignService.getCreativeById(campaign_id, creative_id, organizationId);
      if (!creative) {
        throw new HTTPException(404, { message: "Creative not found" });
      }
      const signedCreative = audioService ? await signUrlsInCreative(creative, audioService) : creative;
      return c2.json(signedCreative, 200);
    } catch (error3) {
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      console.error("Error getting creative:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "put",
    path: "/campaigns/{campaign_id}/creatives/{creative_id}",
    tags: ["creatives"],
    summary: "Update creative",
    description: "Update an existing creative (full update)",
    request: {
      params: CreativeParamsSchema,
      body: {
        content: {
          "application/json": {
            schema: UpdateCreativeSchema
          }
        }
      }
    },
    responses: {
      200: {
        description: "Creative updated successfully",
        content: {
          "application/json": {
            schema: CreativeSchema
          }
        }
      },
      404: {
        description: "Creative not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id, creative_id } = c2.req.valid("param");
    const body = c2.req.valid("json");
    try {
      const creative = await campaignService.updateCreative(campaign_id, creative_id, body, organizationId);
      const signedCreative = audioService ? await signUrlsInCreative(creative, audioService) : creative;
      return c2.json(signedCreative, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error updating creative:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "patch",
    path: "/campaigns/{campaign_id}/creatives/{creative_id}",
    tags: ["creatives"],
    summary: "Patch creative",
    description: "Partially update an existing creative",
    request: {
      params: CreativeParamsSchema,
      body: {
        content: {
          "application/json": {
            schema: UpdateCreativeSchema
          }
        }
      }
    },
    responses: {
      200: {
        description: "Creative updated successfully",
        content: {
          "application/json": {
            schema: CreativeSchema
          }
        }
      },
      404: {
        description: "Creative not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id, creative_id } = c2.req.valid("param");
    const body = c2.req.valid("json");
    try {
      const creative = await campaignService.updateCreative(campaign_id, creative_id, body, organizationId);
      const signedCreative = audioService ? await signUrlsInCreative(creative, audioService) : creative;
      return c2.json(signedCreative, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error patching creative:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "delete",
    path: "/campaigns/{campaign_id}/creatives/{creative_id}",
    tags: ["creatives"],
    summary: "Delete creative",
    description: "Delete a creative",
    request: {
      params: CreativeParamsSchema
    },
    responses: {
      204: {
        description: "Creative deleted successfully"
      },
      404: {
        description: "Creative not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id, creative_id } = c2.req.valid("param");
    try {
      const deleted = await campaignService.deleteCreative(campaign_id, creative_id, organizationId);
      if (!deleted) {
        throw new HTTPException(404, { message: "Creative not found" });
      }
      return c2.body(null, 204);
    } catch (error3) {
      if (error3 instanceof HTTPException) {
        throw error3;
      }
      console.error("Error deleting creative:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  app.openapi({
    method: "get",
    path: "/campaigns/{campaign_id}/shows",
    tags: ["campaigns"],
    summary: "Get campaign shows",
    description: "Get all shows linked to a campaign",
    request: {
      params: CampaignParamsSchema
    },
    responses: {
      200: {
        description: "Shows retrieved successfully",
        content: {
          "application/json": {
            schema: external_exports.array(external_exports.object({
              id: external_exports.string(),
              title: external_exports.string(),
              description: external_exports.string(),
              imageUrl: external_exports.string().nullable(),
              createdAt: external_exports.string(),
              updatedAt: external_exports.string()
            }))
          }
        }
      },
      404: {
        description: "Campaign not found",
        content: {
          "application/json": {
            schema: external_exports.object({ message: external_exports.string() })
          }
        }
      }
    }
  }, async (c2) => {
    const organizationId = getOrgIdFromContext(c2);
    const { campaign_id } = c2.req.valid("param");
    try {
      const shows2 = await campaignService.getCampaignShows(campaign_id, organizationId);
      return c2.json(shows2, 200);
    } catch (error3) {
      if (error3 instanceof NotFoundError) {
        throw new HTTPException(404, { message: error3.message });
      }
      console.error("Error getting campaign shows:", error3);
      throw new HTTPException(500, { message: "Internal server error" });
    }
  });
  if (creativeUploadService) {
    app.openapi({
      method: "post",
      path: "/campaigns/{campaign_id}/creatives/{creative_id}/audio",
      tags: ["creatives"],
      summary: "Upload audio file for creative",
      description: "Upload an audio file for a creative",
      request: {
        params: CreativeParamsSchema,
        body: {
          content: {
            "multipart/form-data": {
              schema: {
                type: "object",
                properties: {
                  audio: {
                    type: "string",
                    format: "binary",
                    description: "Audio file to upload"
                  }
                },
                required: ["audio"]
              }
            }
          }
        }
      },
      responses: {
        201: {
          content: {
            "application/json": {
              schema: CreativeUploadSchema
            }
          },
          description: "Audio uploaded successfully"
        },
        404: {
          description: "Creative not found"
        }
      },
      security: [{ Bearer: [] }]
    }, async (c2) => {
      const payload = c2.get("jwtPayload");
      const hasWritePermission = hasPermissions(payload, ["campaigns:write"]);
      const hasWriteScope = hasScopes(payload, ["campaigns:write"]);
      if (!hasWritePermission && !hasWriteScope) {
        const problem = {
          type: "forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Required permissions: campaigns:write or scope: campaigns:write",
          instance: c2.req.path
        };
        throw new HTTPException(403, { message: JSON.stringify(problem) });
      }
      const { campaign_id, creative_id } = c2.req.valid("param");
      try {
        const formData = await c2.req.formData();
        const audioFile = formData.get("audio");
        if (!audioFile) {
          const problem = {
            type: "validation_error",
            title: "Validation Error",
            status: 400,
            detail: "Audio file is required",
            instance: c2.req.path
          };
          throw new HTTPException(400, { message: JSON.stringify(problem) });
        }
        const buffer = Buffer.from(await audioFile.arrayBuffer());
        const fileData = {
          fileName: audioFile.name,
          fileSize: audioFile.size,
          mimeType: audioFile.type,
          buffer
        };
        const upload = await creativeUploadService.uploadCreativeAudio(campaign_id, creative_id, fileData);
        return c2.json(upload, 201);
      } catch (error3) {
        if (error3 instanceof NotFoundError) {
          const problem = {
            type: "not_found",
            title: "Not Found",
            status: 404,
            detail: "Creative not found",
            instance: c2.req.path
          };
          throw new HTTPException(404, { message: JSON.stringify(problem) });
        }
        console.error("Creative audio upload error:", error3);
        throw error3;
      }
    });
    app.openapi({
      method: "post",
      path: "/campaigns/{campaign_id}/creatives/{creative_id}/video",
      tags: ["creatives"],
      summary: "Upload video file for creative",
      description: "Upload a video file for a creative",
      request: {
        params: CreativeParamsSchema,
        body: {
          content: {
            "multipart/form-data": {
              schema: {
                type: "object",
                properties: {
                  video: {
                    type: "string",
                    format: "binary",
                    description: "Video file to upload"
                  }
                },
                required: ["video"]
              }
            }
          }
        }
      },
      responses: {
        201: {
          content: {
            "application/json": {
              schema: CreativeUploadSchema
            }
          },
          description: "Video uploaded successfully"
        },
        404: {
          description: "Creative not found"
        }
      },
      security: [{ Bearer: [] }]
    }, async (c2) => {
      const payload = c2.get("jwtPayload");
      const hasWritePermission = hasPermissions(payload, ["campaigns:write"]);
      const hasWriteScope = hasScopes(payload, ["campaigns:write"]);
      if (!hasWritePermission && !hasWriteScope) {
        const problem = {
          type: "forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Required permissions: campaigns:write or scope: campaigns:write",
          instance: c2.req.path
        };
        throw new HTTPException(403, { message: JSON.stringify(problem) });
      }
      const { campaign_id, creative_id } = c2.req.valid("param");
      try {
        const formData = await c2.req.formData();
        const videoFile = formData.get("video");
        if (!videoFile) {
          const problem = {
            type: "validation_error",
            title: "Validation Error",
            status: 400,
            detail: "Video file is required",
            instance: c2.req.path
          };
          throw new HTTPException(400, { message: JSON.stringify(problem) });
        }
        const buffer = Buffer.from(await videoFile.arrayBuffer());
        const fileData = {
          fileName: videoFile.name,
          fileSize: videoFile.size,
          mimeType: videoFile.type,
          buffer
        };
        const upload = await creativeUploadService.uploadCreativeVideo(campaign_id, creative_id, fileData);
        return c2.json(upload, 201);
      } catch (error3) {
        if (error3 instanceof NotFoundError) {
          const problem = {
            type: "not_found",
            title: "Not Found",
            status: 404,
            detail: "Creative not found",
            instance: c2.req.path
          };
          throw new HTTPException(404, { message: JSON.stringify(problem) });
        }
        console.error("Creative video upload error:", error3);
        throw error3;
      }
    });
    app.openapi({
      method: "post",
      path: "/campaigns/{campaign_id}/creatives/{creative_id}/image",
      tags: ["creatives"],
      summary: "Upload image file for creative",
      description: "Upload an image file for a creative",
      request: {
        params: CreativeParamsSchema,
        body: {
          content: {
            "multipart/form-data": {
              schema: {
                type: "object",
                properties: {
                  image: {
                    type: "string",
                    format: "binary",
                    description: "Image file to upload"
                  }
                },
                required: ["image"]
              }
            }
          }
        }
      },
      responses: {
        201: {
          content: {
            "application/json": {
              schema: CreativeUploadSchema
            }
          },
          description: "Image uploaded successfully"
        },
        404: {
          description: "Creative not found"
        }
      },
      security: [{ Bearer: [] }]
    }, async (c2) => {
      const payload = c2.get("jwtPayload");
      const hasWritePermission = hasPermissions(payload, ["campaigns:write"]);
      const hasWriteScope = hasScopes(payload, ["campaigns:write"]);
      if (!hasWritePermission && !hasWriteScope) {
        const problem = {
          type: "forbidden",
          title: "Forbidden",
          status: 403,
          detail: "Required permissions: campaigns:write or scope: campaigns:write",
          instance: c2.req.path
        };
        throw new HTTPException(403, { message: JSON.stringify(problem) });
      }
      const { campaign_id, creative_id } = c2.req.valid("param");
      try {
        const formData = await c2.req.formData();
        const imageFile = formData.get("image");
        if (!imageFile) {
          const problem = {
            type: "validation_error",
            title: "Validation Error",
            status: 400,
            detail: "Image file is required",
            instance: c2.req.path
          };
          throw new HTTPException(400, { message: JSON.stringify(problem) });
        }
        const buffer = Buffer.from(await imageFile.arrayBuffer());
        const fileData = {
          fileName: imageFile.name,
          fileSize: imageFile.size,
          mimeType: imageFile.type,
          buffer
        };
        const upload = await creativeUploadService.uploadCreativeImage(campaign_id, creative_id, fileData);
        return c2.json(upload, 201);
      } catch (error3) {
        if (error3 instanceof NotFoundError) {
          const problem = {
            type: "not_found",
            title: "Not Found",
            status: 404,
            detail: "Creative not found",
            instance: c2.req.path
          };
          throw new HTTPException(404, { message: JSON.stringify(problem) });
        }
        console.error("Creative image upload error:", error3);
        throw error3;
      }
    });
  }
  return app;
}
__name(createCampaignRoutes, "createCampaignRoutes");

// dist/organizations/routes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();
var OrganizationSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  auth0_id: external_exports.string()
});
var CreateOrganizationSchema = external_exports.object({
  name: external_exports.string().min(1).max(100),
  display_name: external_exports.string().max(100).optional()
});
function registerOrganizationRoutes(app, organizationService) {
  app.openapi(createRoute({
    method: "get",
    path: "/organizations",
    tags: ["Organizations"],
    summary: "Get user's organizations",
    description: "Get all organizations that the authenticated user is a member of",
    responses: {
      200: {
        description: "User's organizations",
        content: {
          "application/json": {
            schema: external_exports.array(OrganizationSchema)
          }
        }
      },
      401: {
        description: "Unauthorized",
        content: {
          "application/json": {
            schema: external_exports.object({
              type: external_exports.string(),
              title: external_exports.string(),
              status: external_exports.number(),
              detail: external_exports.string()
            })
          }
        }
      }
    }
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    if (!payload.sub) {
      const problem = {
        type: "unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Invalid user ID in token",
        instance: c2.req.path
      };
      throw new HTTPException(401, { message: JSON.stringify(problem) });
    }
    try {
      const organizations2 = await organizationService.getUserOrganizations(payload.sub);
      return c2.json(organizations2, 200);
    } catch (error3) {
      console.error("Error getting user organizations:", error3);
      const problem = {
        type: "internal_error",
        title: "Internal Server Error",
        status: 500,
        detail: "Failed to fetch organizations",
        instance: c2.req.path
      };
      throw new HTTPException(500, { message: JSON.stringify(problem) });
    }
  });
  app.openapi(createRoute({
    method: "post",
    path: "/organizations",
    tags: ["Organizations"],
    summary: "Create a new organization",
    description: "Create a new organization and assign the user as admin",
    request: {
      body: {
        content: {
          "application/json": {
            schema: CreateOrganizationSchema
          }
        }
      }
    },
    responses: {
      201: {
        description: "Organization created successfully",
        content: {
          "application/json": {
            schema: external_exports.object({
              id: external_exports.string(),
              name: external_exports.string(),
              created_at: external_exports.string()
            })
          }
        }
      },
      400: {
        description: "Bad request",
        content: {
          "application/json": {
            schema: external_exports.object({
              type: external_exports.string(),
              title: external_exports.string(),
              status: external_exports.number(),
              detail: external_exports.string()
            })
          }
        }
      },
      401: {
        description: "Unauthorized",
        content: {
          "application/json": {
            schema: external_exports.object({
              type: external_exports.string(),
              title: external_exports.string(),
              status: external_exports.number(),
              detail: external_exports.string()
            })
          }
        }
      },
      403: {
        description: "Forbidden",
        content: {
          "application/json": {
            schema: external_exports.object({
              type: external_exports.string(),
              title: external_exports.string(),
              status: external_exports.number(),
              detail: external_exports.string()
            })
          }
        }
      },
      409: {
        description: "Conflict - Organization name already exists",
        content: {
          "application/json": {
            schema: external_exports.object({
              type: external_exports.string(),
              title: external_exports.string(),
              status: external_exports.number(),
              detail: external_exports.string()
            })
          }
        }
      },
      503: {
        description: "Service unavailable",
        content: {
          "application/json": {
            schema: external_exports.object({
              type: external_exports.string(),
              title: external_exports.string(),
              status: external_exports.number(),
              detail: external_exports.string()
            })
          }
        }
      }
    }
  }), async (c2) => {
    const payload = c2.get("jwtPayload");
    if (!payload.sub) {
      const problem = {
        type: "unauthorized",
        title: "Unauthorized",
        status: 401,
        detail: "Invalid user ID in token",
        instance: c2.req.path
      };
      throw new HTTPException(401, { message: JSON.stringify(problem) });
    }
    const orgData = c2.req.valid("json");
    try {
      const result = await organizationService.createOrganization(orgData.name, payload.sub, orgData.display_name);
      return c2.json({
        id: result.organization.id,
        name: result.organization.name,
        created_at: result.organization.createdAt
      }, 201);
    } catch (error3) {
      console.error("Error creating organization:", error3);
      const errorMessage = error3.message || "";
      if (errorMessage.includes("already exists")) {
        const problem = {
          type: "conflict",
          title: "Conflict",
          status: 409,
          detail: error3.message,
          instance: c2.req.path
        };
        throw new HTTPException(409, {
          message: JSON.stringify(problem)
        });
      } else if (errorMessage.includes("Invalid organization data")) {
        const problem = {
          type: "bad_request",
          title: "Bad Request",
          status: 400,
          detail: error3.message,
          instance: c2.req.path
        };
        throw new HTTPException(400, {
          message: JSON.stringify(problem)
        });
      } else if (errorMessage.includes("Insufficient permissions")) {
        const problem = {
          type: "forbidden",
          title: "Forbidden",
          status: 403,
          detail: error3.message,
          instance: c2.req.path
        };
        throw new HTTPException(403, {
          message: JSON.stringify(problem)
        });
      } else if (errorMessage.includes("Auth0 service not configured")) {
        const problem = {
          type: "service_unavailable",
          title: "Service Unavailable",
          status: 503,
          detail: "Organization service is not properly configured",
          instance: c2.req.path
        };
        throw new HTTPException(503, {
          message: JSON.stringify(problem)
        });
      } else {
        const problem = {
          type: "internal_error",
          title: "Internal Server Error",
          status: 500,
          detail: error3.message || "Failed to create organization",
          instance: c2.req.path
        };
        throw new HTTPException(500, {
          message: JSON.stringify(problem)
        });
      }
    }
  });
}
__name(registerOrganizationRoutes, "registerOrganizationRoutes");

// dist/events/publisher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
var EventPublisher = class {
  static {
    __name(this, "EventPublisher");
  }
  source;
  constructor() {
    this.source = process.env.SERVICE_NAME || "podcast-service";
  }
  async publish(eventType, data, subject) {
    const event = {
      specversion: "1.0",
      type: eventType,
      source: this.source,
      id: v4_default(),
      time: (/* @__PURE__ */ new Date()).toISOString(),
      data,
      subject
    };
  }
};

// dist/app.js
init_repository3();

// dist/shows/service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
var ShowService = class {
  static {
    __name(this, "ShowService");
  }
  showRepository;
  eventPublisher;
  constructor(showRepository, eventPublisher) {
    this.showRepository = showRepository;
    this.eventPublisher = eventPublisher;
  }
  async getAllShows(pagination, organizationId) {
    return await this.showRepository.findAll(pagination, organizationId);
  }
  async getShowById(id, organizationId) {
    return await this.showRepository.findById(id, organizationId);
  }
  // Public method for RSS feeds - gets show by ID without organization context
  async getShowByIdPublic(id) {
    return await this.showRepository.findByIdPublic(id);
  }
  async createShow(data, organizationId) {
    const id = v4_default();
    const show = await this.showRepository.create({
      ...data,
      id,
      organizationId
    });
    await this.eventPublisher.publish("show.created", show, show.id);
    return show;
  }
  async updateShow(id, data, organizationId) {
    const show = await this.showRepository.update(id, data, organizationId);
    await this.eventPublisher.publish("show.updated", show, show.id);
    return show;
  }
  async deleteShow(id, organizationId) {
    const show = await this.showRepository.findById(id, organizationId);
    if (!show) {
      return false;
    }
    await this.showRepository.delete(id, organizationId);
    await this.eventPublisher.publish("show.deleted", { id }, id);
    return true;
  }
};

// dist/episodes/repository.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_drizzle_orm();
init_client();
init_schema3();
init_errors2();
var EpisodeRepository = class {
  static {
    __name(this, "EpisodeRepository");
  }
  db;
  constructor(database) {
    this.db = getDatabase(database);
  }
  async findByShowId(showId, { limit, offset }) {
    return await this.db.select().from(episodes).where(eq(episodes.showId, showId)).limit(limit).offset(offset).orderBy(episodes.createdAt);
  }
  async findById(showId, episodeId) {
    const result = await this.db.select().from(episodes).where(and(eq(episodes.showId, showId), eq(episodes.id, episodeId))).limit(1);
    return result[0] || null;
  }
  async findByIdOnly(episodeId) {
    const result = await this.db.select().from(episodes).where(eq(episodes.id, episodeId)).limit(1);
    return result[0] || null;
  }
  async create(showId, data) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const newEpisode = {
      ...data,
      showId,
      published: false,
      publishedAt: null,
      createdAt: now,
      updatedAt: now
    };
    await this.db.insert(episodes).values(newEpisode);
    return newEpisode;
  }
  async update(showId, episodeId, data) {
    const existing = await this.findById(showId, episodeId);
    if (!existing) {
      throw new NotFoundError("Episode not found");
    }
    const updatedEpisode = {
      ...existing,
      ...data,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.db.update(episodes).set({
      ...data,
      updatedAt: updatedEpisode.updatedAt
    }).where(and(eq(episodes.showId, showId), eq(episodes.id, episodeId)));
    return updatedEpisode;
  }
  async updateByIdOnly(episodeId, data) {
    const existing = await this.findByIdOnly(episodeId);
    if (!existing) {
      throw new NotFoundError("Episode not found");
    }
    const updatedEpisode = {
      ...existing,
      ...data,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.db.update(episodes).set({
      ...data,
      updatedAt: updatedEpisode.updatedAt
    }).where(eq(episodes.id, episodeId));
    return updatedEpisode;
  }
  async publish(showId, episodeId) {
    const existing = await this.findById(showId, episodeId);
    if (!existing) {
      throw new NotFoundError("Episode not found");
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const updatedEpisode = {
      ...existing,
      published: true,
      publishedAt: now,
      updatedAt: now
    };
    await this.db.update(episodes).set({
      published: true,
      publishedAt: now,
      updatedAt: now
    }).where(and(eq(episodes.showId, showId), eq(episodes.id, episodeId)));
    return updatedEpisode;
  }
  async delete(showId, episodeId) {
    const existing = await this.findById(showId, episodeId);
    if (!existing) {
      throw new NotFoundError("Episode not found");
    }
    await this.db.delete(episodes).where(and(eq(episodes.showId, showId), eq(episodes.id, episodeId)));
    return true;
  }
};

// dist/episodes/service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
var EpisodeService = class {
  static {
    __name(this, "EpisodeService");
  }
  episodeRepository;
  eventPublisher;
  taskService;
  constructor(episodeRepository, eventPublisher, taskService) {
    this.episodeRepository = episodeRepository;
    this.eventPublisher = eventPublisher;
    this.taskService = taskService;
  }
  async getEpisodesByShowId(showId, pagination) {
    return await this.episodeRepository.findByShowId(showId, pagination);
  }
  async getEpisodeById(showId, episodeId) {
    return await this.episodeRepository.findById(showId, episodeId);
  }
  async createEpisode(showId, data, organizationId) {
    const id = v4_default();
    const episode = await this.episodeRepository.create(showId, {
      ...data,
      id,
      organizationId
    });
    await this.eventPublisher.publish("episode.created", episode, episode.id);
    return episode;
  }
  async updateEpisode(showId, episodeId, data) {
    const episode = await this.episodeRepository.update(showId, episodeId, data);
    await this.eventPublisher.publish("episode.updated", episode, episode.id);
    return episode;
  }
  async publishEpisode(showId, episodeId) {
    const episode = await this.episodeRepository.publish(showId, episodeId);
    await this.eventPublisher.publish("episode.published", episode, episode.id);
    return episode;
  }
  async deleteEpisode(showId, episodeId) {
    const episode = await this.episodeRepository.findById(showId, episodeId);
    if (!episode) {
      return false;
    }
    await this.episodeRepository.delete(showId, episodeId);
    await this.eventPublisher.publish("episode.deleted", { id: episodeId, showId }, episodeId);
    return true;
  }
};

// dist/audio/service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();

// dist/audio/repository.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_drizzle_orm();
init_client();
init_schema3();
init_errors2();
var AudioRepository = class {
  static {
    __name(this, "AudioRepository");
  }
  db;
  constructor(database) {
    this.db = getDatabase(database);
  }
  async findByEpisodeId(showId, episodeId) {
    const episodeCheck = await this.db.select().from(episodes).where(and(eq(episodes.showId, showId), eq(episodes.id, episodeId))).limit(1);
    if (!episodeCheck[0]) {
      throw new NotFoundError("Episode not found");
    }
    const result = await this.db.select().from(audioUploads).where(eq(audioUploads.episodeId, episodeId)).limit(1);
    return result[0] || null;
  }
  async create(data) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const newAudioUpload = {
      ...data,
      uploadedAt: now
    };
    await this.db.insert(audioUploads).values(newAudioUpload);
    return newAudioUpload;
  }
  async delete(episodeId) {
    await this.db.delete(audioUploads).where(eq(audioUploads.episodeId, episodeId));
    return true;
  }
};

// dist/audio/service.js
init_errors2();

// dist/utils/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/utils/r2-presigned-url.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/aws4fetch/dist/aws4fetch.esm.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var encoder = new TextEncoder();
var HOST_SERVICES = {
  appstream2: "appstream",
  cloudhsmv2: "cloudhsm",
  email: "ses",
  marketplace: "aws-marketplace",
  mobile: "AWSMobileHubService",
  pinpoint: "mobiletargeting",
  queue: "sqs",
  "git-codecommit": "codecommit",
  "mturk-requester-sandbox": "mturk-requester",
  "personalize-runtime": "personalize"
};
var UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([
  "authorization",
  "content-type",
  "content-length",
  "user-agent",
  "presigned-expires",
  "expect",
  "x-amzn-trace-id",
  "range",
  "connection"
]);
var AwsClient = class {
  static {
    __name(this, "AwsClient");
  }
  constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {
    if (accessKeyId == null) throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null) throw new TypeError("secretAccessKey is a required option");
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    this.service = service;
    this.region = region;
    this.cache = cache || /* @__PURE__ */ new Map();
    this.retries = retries != null ? retries : 10;
    this.initRetryMs = initRetryMs || 50;
  }
  async sign(input, init) {
    if (input instanceof Request) {
      const { method, url, headers, body } = input;
      init = Object.assign({ method, url, headers }, init);
      if (init.body == null && headers.has("Content-Type")) {
        init.body = body != null && headers.has("X-Amz-Content-Sha256") ? body : await input.clone().arrayBuffer();
      }
      input = url;
    }
    const signer = new AwsV4Signer(Object.assign({ url: input.toString() }, init, this, init && init.aws));
    const signed = Object.assign({}, init, await signer.sign());
    delete signed.aws;
    try {
      return new Request(signed.url.toString(), signed);
    } catch (e) {
      if (e instanceof TypeError) {
        return new Request(signed.url.toString(), Object.assign({ duplex: "half" }, signed));
      }
      throw e;
    }
  }
  async fetch(input, init) {
    for (let i = 0; i <= this.retries; i++) {
      const fetched = fetch(await this.sign(input, init));
      if (i === this.retries) {
        return fetched;
      }
      const res = await fetched;
      if (res.status < 500 && res.status !== 429) {
        return res;
      }
      await new Promise((resolve) => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));
    }
    throw new Error("An unknown error occurred, ensure retries is not negative");
  }
};
var AwsV4Signer = class {
  static {
    __name(this, "AwsV4Signer");
  }
  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
    if (url == null) throw new TypeError("url is a required option");
    if (accessKeyId == null) throw new TypeError("accessKeyId is a required option");
    if (secretAccessKey == null) throw new TypeError("secretAccessKey is a required option");
    this.method = method || (body ? "POST" : "GET");
    this.url = new URL(url);
    this.headers = new Headers(headers || {});
    this.body = body;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    let guessedService, guessedRegion;
    if (!service || !region) {
      [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
    }
    this.service = service || guessedService || "";
    this.region = region || guessedRegion || "us-east-1";
    this.cache = cache || /* @__PURE__ */ new Map();
    this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, "");
    this.signQuery = signQuery;
    this.appendSessionToken = appendSessionToken || this.service === "iotdevicegateway";
    this.headers.delete("Host");
    if (this.service === "s3" && !this.signQuery && !this.headers.has("X-Amz-Content-Sha256")) {
      this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
    }
    const params = this.signQuery ? this.url.searchParams : this.headers;
    params.set("X-Amz-Date", this.datetime);
    if (this.sessionToken && !this.appendSessionToken) {
      params.set("X-Amz-Security-Token", this.sessionToken);
    }
    this.signableHeaders = ["host", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();
    this.signedHeaders = this.signableHeaders.join(";");
    this.canonicalHeaders = this.signableHeaders.map((header) => header + ":" + (header === "host" ? this.url.host : (this.headers.get(header) || "").replace(/\s+/g, " "))).join("\n");
    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/");
    if (this.signQuery) {
      if (this.service === "s3" && !params.has("X-Amz-Expires")) {
        params.set("X-Amz-Expires", "86400");
      }
      params.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
      params.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString);
      params.set("X-Amz-SignedHeaders", this.signedHeaders);
    }
    if (this.service === "s3") {
      try {
        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
      } catch (e) {
        this.encodedPath = this.url.pathname;
      }
    } else {
      this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
    }
    if (!singleEncode) {
      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/");
    }
    this.encodedPath = encodeRfc3986(this.encodedPath);
    const seenKeys = /* @__PURE__ */ new Set();
    this.encodedSearch = [...this.url.searchParams].filter(([k]) => {
      if (!k) return false;
      if (this.service === "s3") {
        if (seenKeys.has(k)) return false;
        seenKeys.add(k);
      }
      return true;
    }).map((pair) => pair.map((p2) => encodeRfc3986(encodeURIComponent(p2)))).sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0).map((pair) => pair.join("=")).join("&");
  }
  async sign() {
    if (this.signQuery) {
      this.url.searchParams.set("X-Amz-Signature", await this.signature());
      if (this.sessionToken && this.appendSessionToken) {
        this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken);
      }
    } else {
      this.headers.set("Authorization", await this.authHeader());
    }
    return {
      method: this.method,
      url: this.url,
      headers: this.headers,
      body: this.body
    };
  }
  async authHeader() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString,
      "SignedHeaders=" + this.signedHeaders,
      "Signature=" + await this.signature()
    ].join(", ");
  }
  async signature() {
    const date = this.datetime.slice(0, 8);
    const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
    let kCredentials = this.cache.get(cacheKey);
    if (!kCredentials) {
      const kDate = await hmac("AWS4" + this.secretAccessKey, date);
      const kRegion = await hmac(kDate, this.region);
      const kService = await hmac(kRegion, this.service);
      kCredentials = await hmac(kService, "aws4_request");
      this.cache.set(cacheKey, kCredentials);
    }
    return buf2hex(await hmac(kCredentials, await this.stringToSign()));
  }
  async stringToSign() {
    return [
      "AWS4-HMAC-SHA256",
      this.datetime,
      this.credentialString,
      buf2hex(await hash(await this.canonicalString()))
    ].join("\n");
  }
  async canonicalString() {
    return [
      this.method.toUpperCase(),
      this.encodedPath,
      this.encodedSearch,
      this.canonicalHeaders + "\n",
      this.signedHeaders,
      await this.hexBodyHash()
    ].join("\n");
  }
  async hexBodyHash() {
    let hashHeader = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
    if (hashHeader == null) {
      if (this.body && typeof this.body !== "string" && !("byteLength" in this.body)) {
        throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
      }
      hashHeader = buf2hex(await hash(this.body || ""));
    }
    return hashHeader;
  }
};
async function hmac(key, string) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    typeof key === "string" ? encoder.encode(key) : key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return crypto.subtle.sign("HMAC", cryptoKey, encoder.encode(string));
}
__name(hmac, "hmac");
async function hash(content) {
  return crypto.subtle.digest("SHA-256", typeof content === "string" ? encoder.encode(content) : content);
}
__name(hash, "hash");
var HEX_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
function buf2hex(arrayBuffer) {
  const buffer = new Uint8Array(arrayBuffer);
  let out = "";
  for (let idx = 0; idx < buffer.length; idx++) {
    const n = buffer[idx];
    out += HEX_CHARS[n >>> 4 & 15];
    out += HEX_CHARS[n & 15];
  }
  return out;
}
__name(buf2hex, "buf2hex");
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, (c2) => "%" + c2.charCodeAt(0).toString(16).toUpperCase());
}
__name(encodeRfc3986, "encodeRfc3986");
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith(".on.aws")) {
    const match2 = hostname.match(/^[^.]{1,63}\.lambda-url\.([^.]{1,63})\.on\.aws$/);
    return match2 != null ? ["lambda", match2[1] || ""] : ["", ""];
  }
  if (hostname.endsWith(".r2.cloudflarestorage.com")) {
    return ["s3", "auto"];
  }
  if (hostname.endsWith(".backblazeb2.com")) {
    const match2 = hostname.match(/^(?:[^.]{1,63}\.)?s3\.([^.]{1,63})\.backblazeb2\.com$/);
    return match2 != null ? ["s3", match2[1] || ""] : ["", ""];
  }
  const match = hostname.replace("dualstack.", "").match(/([^.]{1,63})\.(?:([^.]{0,63})\.)?amazonaws\.com(?:\.cn)?$/);
  let service = match && match[1] || "";
  let region = match && match[2];
  if (region === "us-gov") {
    region = "us-gov-west-1";
  } else if (region === "s3" || region === "s3-accelerate") {
    region = "us-east-1";
    service = "s3";
  } else if (service === "iot") {
    if (hostname.startsWith("iot.")) {
      service = "execute-api";
    } else if (hostname.startsWith("data.jobs.iot.")) {
      service = "iot-jobs-data";
    } else {
      service = pathname === "/mqtt" ? "iotdevicegateway" : "iotdata";
    }
  } else if (service === "autoscaling") {
    const targetPrefix = (headers.get("X-Amz-Target") || "").split(".")[0];
    if (targetPrefix === "AnyScaleFrontendService") {
      service = "application-autoscaling";
    } else if (targetPrefix === "AnyScaleScalingPlannerFrontendService") {
      service = "autoscaling-plans";
    }
  } else if (region == null && service.startsWith("s3-")) {
    region = service.slice(3).replace(/^fips-|^external-1/, "");
    service = "s3";
  } else if (service.endsWith("-fips")) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
    [service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region || ""];
}
__name(guessServiceRegion, "guessServiceRegion");

// dist/utils/r2-presigned-url.js
var R2PreSignedUrlGenerator = class {
  static {
    __name(this, "R2PreSignedUrlGenerator");
  }
  client;
  customDomain;
  accessKeyId;
  secretAccessKey;
  region;
  constructor(accessKeyId, secretAccessKey, customDomain, region = "auto") {
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.region = region;
    this.client = new AwsClient({
      accessKeyId,
      secretAccessKey,
      region,
      service: "s3"
    });
    this.customDomain = customDomain;
  }
  async generatePresignedUrl(bucketName, key, expiresIn = 28800, method = "GET", contentType) {
    const baseUrl = this.customDomain ? `${this.customDomain}/${key}` : `https://${bucketName}.r2.cloudflarestorage.com/${key}`;
    if (this.customDomain && method === "GET") {
      return baseUrl;
    }
    const headers = {};
    if (contentType && method === "PUT") {
      headers["content-type"] = contentType;
    }
    try {
      const signedUrl = await this.client.sign(baseUrl, {
        method,
        headers,
        aws: {
          signQuery: true,
          allHeaders: false
        }
      });
      const finalUrl = new URL(signedUrl.url);
      finalUrl.searchParams.set("X-Amz-Expires", expiresIn.toString());
      return finalUrl.toString();
    } catch (error3) {
      console.error(`Failed to generate presigned URL for ${method} ${key}:`, error3);
      const errorMessage = error3 instanceof Error ? error3.message : String(error3);
      throw new Error(`Failed to generate presigned URL: ${errorMessage}`);
    }
  }
  /**
   * Generate a direct access URL using custom domain (no signature)
   * This only works if a custom domain is configured. If no custom domain is available,
   * returns null to avoid generating broken cloudflarestorage.com URLs.
   */
  generateDirectUrl(bucketName, key) {
    if (this.customDomain) {
      return `${this.customDomain}/${key}`;
    }
    return null;
  }
};

// dist/audio/service.js
var AudioService = class {
  static {
    __name(this, "AudioService");
  }
  audioRepo;
  eventPublisher;
  episodeRepo;
  audioProcessingWorkflow;
  bucket;
  presignedUrlGenerator = null;
  database;
  constructor(database, bucket, eventPublisher, r2AccessKeyId, r2SecretAccessKey, r2Endpoint, audioProcessingWorkflow) {
    this.database = database;
    this.audioRepo = new AudioRepository(database);
    this.episodeRepo = new EpisodeRepository(database);
    this.eventPublisher = eventPublisher || new EventPublisher();
    this.audioProcessingWorkflow = audioProcessingWorkflow;
    this.bucket = bucket;
    console.log(`AudioService initialized with workflow: ${!!audioProcessingWorkflow}`);
    if (r2AccessKeyId && r2SecretAccessKey) {
      console.log(`Initializing R2PreSignedUrlGenerator with endpoint: ${r2Endpoint}`);
      this.presignedUrlGenerator = new R2PreSignedUrlGenerator(r2AccessKeyId, r2SecretAccessKey, r2Endpoint);
    } else {
      console.log(`R2 credentials not available - r2AccessKeyId: ${!!r2AccessKeyId}, r2SecretAccessKey: ${!!r2SecretAccessKey}`);
    }
  }
  async uploadAudio(showId, episodeId, file) {
    const episode = await this.episodeRepo.findById(showId, episodeId);
    if (!episode) {
      throw new NotFoundError("Episode not found");
    }
    const audioId = v4_default();
    const fileName = file.fileName;
    const key = `audio/${showId}/${episodeId}/${audioId}/${fileName}`;
    let url;
    let signedUrl;
    if (this.bucket) {
      await this.bucket.put(key, file.buffer, {
        httpMetadata: {
          contentType: file.mimeType
        }
      });
      url = `r2://${key}`;
      if (this.presignedUrlGenerator) {
        try {
          const directUrl = this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", key);
          signedUrl = directUrl || url;
        } catch (error3) {
          console.warn("Failed to generate URL, using r2:// fallback:", error3);
          signedUrl = url;
        }
      } else {
        console.warn("No R2 credentials available for URL generation");
        signedUrl = url;
      }
    } else {
      url = `https://storage.example.com/audio/${audioId}/${fileName}`;
      signedUrl = url;
    }
    let audioUpload;
    try {
      console.log(`Creating audio record for episode ${episodeId}`);
      audioUpload = await this.audioRepo.create({
        id: audioId,
        episodeId,
        fileName: file.fileName,
        fileSize: file.fileSize,
        mimeType: file.mimeType,
        url
        // Store R2 key (r2://) for regenerating signed URLs
      });
      console.log(`Audio record created successfully: ${audioUpload.id}`);
    } catch (error3) {
      console.error("Failed to create audio record:", error3);
      throw new Error(`Database error: Failed to create audio record - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    try {
      console.log(`Updating episode ${episodeId} with audio URL`);
      await this.episodeRepo.update(showId, episodeId, {
        audioUrl: url
        // Store R2 key, sign on-demand when reading
      });
      console.log(`Episode updated successfully`);
    } catch (error3) {
      console.error("Failed to update episode:", error3);
      throw new Error(`Database error: Failed to update episode - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    try {
      console.log(`Publishing audio.uploaded event`);
      await this.eventPublisher.publish("audio.uploaded", {
        ...audioUpload,
        url: signedUrl
        // Include signed URL in event for immediate use
      }, audioUpload.id);
      console.log(`Event published successfully`);
    } catch (error3) {
      console.error("Failed to publish event:", error3);
      throw new Error(`Event error: Failed to publish audio.uploaded event - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    try {
      console.log(`Starting audio processing workflow`);
      await this.processUploadedAudio(episodeId, url, 600);
      console.log(`Audio processing workflow started successfully`);
    } catch (error3) {
      console.error("Failed to start audio processing:", error3);
      throw new Error(`Workflow error: Failed to start audio processing - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    return {
      ...audioUpload,
      url: signedUrl
    };
  }
  // Process uploaded audio by creating a task that will start the workflow
  async processUploadedAudio(episodeId, audioR2Key, chunkDuration = 600) {
    console.log(`Creating audio processing task for uploaded audio: episodeId=${episodeId}`);
    try {
      const episode = await this.episodeRepo.findByIdOnly(episodeId);
      if (!episode) {
        throw new Error(`Episode ${episodeId} not found`);
      }
      const { ShowRepository: ShowRepository2 } = await Promise.resolve().then(() => (init_repository3(), repository_exports2));
      const showRepo = new ShowRepository2(this.database);
      const show = await showRepo.findById(episode.showId, episode.organizationId);
      const transcriptionLanguage = show?.language || process.env.DEFAULT_TRANSCRIPTION_LANGUAGE || "en";
      console.log(`Using transcription language: ${transcriptionLanguage} for show ${episode.showId}`);
      const { TaskService: TaskService2 } = await Promise.resolve().then(() => (init_service2(), service_exports2));
      console.log(`Creating TaskService with workflow: ${!!this.audioProcessingWorkflow}`);
      const taskService = new TaskService2(this.database, this.audioProcessingWorkflow);
      const task = await taskService.createTask("audio_processing", {
        episodeId,
        audioR2Key,
        // Use R2 key instead of signed URL
        chunkDuration,
        encodingFormats: ["mp3_128"],
        // Use MP3 format with auto-adjusted bitrate based on mono/stereo
        transcriptionLanguage
      }, episode.organizationId);
      console.log(`Created audio processing task ${task.id} for episode ${episodeId}`);
      let eventSignedUrl = audioR2Key;
      if (this.presignedUrlGenerator && audioR2Key.startsWith("r2://")) {
        try {
          eventSignedUrl = await this.presignedUrlGenerator.generatePresignedUrl(
            audioR2Key.replace("r2://", ""),
            "get",
            3600
            // 1 hour
          );
        } catch (error3) {
          console.warn("Failed to generate signed URL for event payload:", error3);
        }
      }
      console.log(`Publishing workflow started event for episode ${episodeId}`);
      await this.eventPublisher.publish("episode.audio_processing_workflow_started", {
        episodeId,
        taskId: task.id,
        audioUrl: eventSignedUrl,
        audioR2Key,
        // Include R2 key for workflow consumers
        type: "task",
        message: "Audio processing task created and workflow started"
      }, episodeId);
      console.log(`Workflow started event published successfully`);
    } catch (error3) {
      console.error(`Failed to create audio processing task for episode ${episodeId}:`, error3);
      throw new Error(`Task creation failed: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
  }
  async getAudioMetadata(showId, episodeId) {
    const audioData = await this.audioRepo.findByEpisodeId(showId, episodeId);
    if (!audioData) {
      return null;
    }
    if (this.presignedUrlGenerator && audioData.url.startsWith("r2://")) {
      const key = audioData.url.replace("r2://", "");
      try {
        const signedUrl = await this.presignedUrlGenerator.generatePresignedUrl(
          "podcast-service-assets",
          key,
          28800
          // 8 hours
        );
        return {
          ...audioData,
          url: signedUrl
        };
      } catch (error3) {
        console.warn("Failed to generate fresh pre-signed URL:", error3);
      }
    }
    return audioData;
  }
  async getR2Object(key) {
    if (!this.bucket) {
      throw new Error("R2 bucket not available");
    }
    try {
      const object = await this.bucket.get(key);
      return object;
    } catch (error3) {
      console.error("Error getting R2 object:", error3);
      return null;
    }
  }
  // Utility method to generate signed URL from R2 key
  async generateSignedUrlFromKey(r2Key) {
    if (!this.presignedUrlGenerator) {
      return null;
    }
    try {
      return this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", r2Key);
    } catch (error3) {
      console.warn("Failed to generate URL for key:", r2Key, error3);
      return null;
    }
  }
  async generatePresignedUrlFromKey(r2Key) {
    if (!this.presignedUrlGenerator) {
      return null;
    }
    try {
      return await this.presignedUrlGenerator.generatePresignedUrl(
        "podcast-service-assets",
        r2Key,
        28800
        // 8 hours
      );
    } catch (error3) {
      console.warn("Failed to generate presigned URL for key:", r2Key, error3);
      return null;
    }
  }
  /**
   * Creates an audio processing task that will start a workflow
   * This is the new recommended way to process audio
   */
  async createAudioProcessingTask(episodeId, audioR2Key, options) {
    const episode = await this.episodeRepo.findByIdOnly(episodeId);
    if (!episode) {
      throw new Error(`Episode ${episodeId} not found`);
    }
    const { ShowRepository: ShowRepository2 } = await Promise.resolve().then(() => (init_repository3(), repository_exports2));
    const showRepo = new ShowRepository2(this.database);
    const show = await showRepo.findById(episode.showId, episode.organizationId);
    const transcriptionLanguage = show?.language || process.env.DEFAULT_TRANSCRIPTION_LANGUAGE || "en";
    console.log(`Using transcription language: ${transcriptionLanguage} for show ${episode.showId}`);
    const { TaskService: TaskService2 } = await Promise.resolve().then(() => (init_service2(), service_exports2));
    const taskService = new TaskService2(this.database, this.audioProcessingWorkflow);
    const transcriptionModel = process.env.DEFAULT_TRANSCRIPTION_MODEL || "@cf/deepgram/nova-3";
    const defaultChunkDuration = transcriptionModel.includes("whisper") ? 30 : 600;
    const payload = {
      episodeId,
      audioR2Key,
      chunkDuration: defaultChunkDuration,
      encodingFormats: options?.encodingFormats || ["mp3_128"],
      transcriptionModel,
      useNova3Features: transcriptionModel.includes("nova"),
      transcriptionLanguage
    };
    const task = await taskService.createTask("audio_processing", payload, episode.organizationId);
    console.log(`Created audio processing task ${task.id} for episode ${episodeId} using ${transcriptionModel} (${payload.chunkDuration}s chunks) with language ${transcriptionLanguage}`);
    return task;
  }
};

// dist/images/service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
init_schema3();
init_drizzle_orm();
init_client();
var ImageService = class {
  static {
    __name(this, "ImageService");
  }
  r2PreSignedUrlGenerator = null;
  db;
  bucket;
  constructor(bucket, r2AccessKeyId, r2SecretAccessKey, r2Endpoint, database) {
    this.bucket = bucket;
    this.db = getDatabase(database);
    if (r2AccessKeyId && r2SecretAccessKey) {
      console.log(`[ImageService] Initializing R2PreSignedUrlGenerator with endpoint: ${r2Endpoint}`);
      this.r2PreSignedUrlGenerator = new R2PreSignedUrlGenerator(r2AccessKeyId, r2SecretAccessKey, r2Endpoint);
    } else {
      console.log(`[ImageService] R2 credentials not available - r2AccessKeyId: ${!!r2AccessKeyId}, r2SecretAccessKey: ${!!r2SecretAccessKey}`);
    }
  }
  /**
   * Upload image for a show
   */
  async uploadShowImage(showId, file) {
    console.log(`[ImageService] Uploading show image for show ${showId}`);
    console.log(`[ImageService] File details: name="${file.name}", size=${file.size}, type="${file.type}"`);
    if (!this.bucket) {
      console.error(`[ImageService] R2 bucket is not configured`);
      throw new Error("R2 bucket is not configured");
    }
    console.log(`[ImageService] R2 bucket is available`);
    console.log(`[ImageService] Checking if show exists: ${showId}`);
    const show = await this.db.select().from(shows).where(eq(shows.id, showId)).get();
    if (!show) {
      console.error(`[ImageService] Show not found: ${showId}`);
      throw new Error(`Show with id ${showId} not found`);
    }
    console.log(`[ImageService] Show found: ${show.title}`);
    if (!file.type.startsWith("image/")) {
      console.error(`[ImageService] Invalid file type: ${file.type}`);
      throw new Error("File must be an image");
    }
    console.log(`[ImageService] File type validated: ${file.type}`);
    const fileId = v4_default();
    const filename = file.name || `image-${fileId}`;
    const key = `images/shows/${showId}/${fileId}/${filename}`;
    console.log(`[ImageService] Generated upload key: ${key}`);
    try {
      console.log(`[ImageService] Converting file to arrayBuffer...`);
      const arrayBuffer = await file.arrayBuffer();
      console.log(`[ImageService] ArrayBuffer created, size: ${arrayBuffer.byteLength}`);
      console.log(`[ImageService] Attempting R2 upload...`);
      await this.bucket.put(key, arrayBuffer, {
        httpMetadata: {
          contentType: file.type
        }
      });
      console.log(`[ImageService] R2 upload successful`);
      const r2Url = `r2://${key}`;
      console.log(`[ImageService] Stored as R2 URL: ${r2Url}`);
      console.log(`[ImageService] Saving metadata to database...`);
      const imageUpload = {
        id: fileId,
        showId,
        episodeId: null,
        fileName: filename,
        fileSize: file.size,
        mimeType: file.type,
        url: r2Url,
        uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const result = await this.db.insert(imageUploads).values(imageUpload).returning().get();
      console.log(`[ImageService] Image upload saved to database with id: ${result.id}`);
      await this.db.update(shows).set({
        imageUrl: r2Url,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      }).where(eq(shows.id, showId));
      console.log(`[ImageService] Updated show ${showId} with new image URL`);
      if (typeof globalThis.TASK_QUEUE !== "undefined") {
        await globalThis.TASK_QUEUE.send({
          type: "encode",
          payload: {
            imageId: fileId,
            showId,
            url: r2Url
          }
        });
      }
      return result;
    } catch (error3) {
      console.error(`[ImageService] Error uploading image for show ${showId}:`, {
        message: error3.message,
        name: error3.name,
        stack: error3.stack,
        cause: error3.cause,
        errorString: String(error3),
        errorType: typeof error3
      });
      if (error3.message?.includes("bucket")) {
        console.error(`[ImageService] R2 bucket error detected`);
        throw new Error("Image storage service is not available");
      }
      if (error3.message?.includes("database") || error3.message?.includes("UNIQUE")) {
        console.error(`[ImageService] Database error detected`);
        throw new Error("Database error occurred while saving image metadata");
      }
      console.error(`[ImageService] Rethrowing unhandled error`);
      throw error3;
    }
  }
  /**
   * Upload image for an episode
   */
  async uploadEpisodeImage(showId, episodeId, file) {
    console.log(`[ImageService] Uploading episode image for episode ${episodeId}`);
    const episode = await this.db.select().from(episodes).where(eq(episodes.id, episodeId)).get();
    if (!episode || episode.showId !== showId) {
      throw new Error(`Episode with id ${episodeId} not found in show ${showId}`);
    }
    if (!file.type.startsWith("image/")) {
      throw new Error("File must be an image");
    }
    const fileId = v4_default();
    const filename = file.name || `image-${fileId}`;
    const key = `images/episodes/${showId}/${episodeId}/${fileId}/${filename}`;
    console.log(`[ImageService] Uploading to R2 key: ${key}`);
    const arrayBuffer = await file.arrayBuffer();
    await this.bucket.put(key, arrayBuffer, {
      httpMetadata: {
        contentType: file.type
      }
    });
    const r2Url = `r2://${key}`;
    console.log(`[ImageService] Stored as R2 URL: ${r2Url}`);
    const imageUpload = {
      id: fileId,
      showId: null,
      episodeId,
      fileName: filename,
      fileSize: file.size,
      mimeType: file.type,
      url: r2Url,
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const result = await this.db.insert(imageUploads).values(imageUpload).returning().get();
    console.log(`[ImageService] Image upload saved to database with id: ${result.id}`);
    await this.db.update(episodes).set({
      imageUrl: r2Url,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    }).where(eq(episodes.id, episodeId));
    if (typeof globalThis.TASK_QUEUE !== "undefined") {
      await globalThis.TASK_QUEUE.send({
        type: "encode",
        payload: {
          imageId: fileId,
          episodeId,
          showId,
          url: r2Url
        }
      });
    }
    console.log(`[ImageService] Updated episode ${episodeId} with new image URL`);
    return result;
  }
  /**
   * Sign an R2 URL to make it accessible
   */
  async signImageUrl(url) {
    if (!url || !url.startsWith("r2://")) {
      return url;
    }
    if (!this.r2PreSignedUrlGenerator) {
      console.warn("[ImageService] No pre-signed URL generator available");
      return url;
    }
    const key = url.replace("r2://", "");
    return await this.r2PreSignedUrlGenerator.generatePresignedUrl("podcast-assets", key);
  }
};

// dist/app.js
init_service2();

// dist/campaigns/repository.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_drizzle_orm();
init_client();
init_schema3();
init_errors2();
var CampaignRepository = class {
  static {
    __name(this, "CampaignRepository");
  }
  db;
  constructor(database) {
    this.db = getDatabase(database);
  }
  async findAll(pagination, organizationId) {
    const offset = (pagination.page - 1) * pagination.limit;
    const [campaignsData, totalCount] = await Promise.all([
      this.db.select().from(campaigns).where(eq(campaigns.organizationId, organizationId)).orderBy(desc(campaigns.createdAt)).limit(pagination.limit).offset(offset),
      this.db.select({ count: count3() }).from(campaigns).where(eq(campaigns.organizationId, organizationId)).then((result) => result[0].count)
    ]);
    return {
      data: campaignsData,
      pagination: {
        page: pagination.page,
        limit: pagination.limit,
        total: totalCount,
        totalPages: Math.ceil(totalCount / pagination.limit)
      }
    };
  }
  async findById(id, organizationId) {
    const campaign = await this.db.select().from(campaigns).where(and(eq(campaigns.id, id), eq(campaigns.organizationId, organizationId))).limit(1);
    return campaign[0] || null;
  }
  async findByIdWithDetails(id, organizationId) {
    const campaign = await this.findById(id, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    const campaignCreatives = await this.db.select().from(creatives).where(eq(creatives.campaignId, id)).orderBy(asc(creatives.createdAt));
    const campaignShowsData = await this.db.select({
      id: shows.id,
      title: shows.title
    }).from(campaignShows).innerJoin(shows, eq(campaignShows.showId, shows.id)).where(eq(campaignShows.campaignId, id)).orderBy(asc(shows.title));
    return {
      ...campaign,
      creatives: campaignCreatives,
      shows: campaignShowsData
    };
  }
  async create(data) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const campaignData = {
      ...data,
      createdAt: now,
      updatedAt: now
    };
    const result = await this.db.insert(campaigns).values(campaignData).returning();
    return result[0];
  }
  async update(id, data, organizationId) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const updateData = {
      ...data,
      updatedAt: now
    };
    const result = await this.db.update(campaigns).set(updateData).where(and(eq(campaigns.id, id), eq(campaigns.organizationId, organizationId))).returning();
    if (result.length === 0) {
      throw new NotFoundError("Campaign not found");
    }
    return result[0];
  }
  async delete(id, organizationId) {
    const result = await this.db.delete(campaigns).where(and(eq(campaigns.id, id), eq(campaigns.organizationId, organizationId))).returning();
    return result.length > 0;
  }
  // Creative methods
  async findCreativesByCampaign(campaignId) {
    return await this.db.select().from(creatives).where(eq(creatives.campaignId, campaignId)).orderBy(asc(creatives.createdAt));
  }
  async findCreativeById(campaignId, creativeId) {
    const creative = await this.db.select().from(creatives).where(and(eq(creatives.id, creativeId), eq(creatives.campaignId, campaignId))).limit(1);
    return creative[0] || null;
  }
  async createCreative(data) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const creativeData = {
      ...data,
      createdAt: now,
      updatedAt: now
    };
    const result = await this.db.insert(creatives).values(creativeData).returning();
    return result[0];
  }
  async updateCreative(campaignId, creativeId, data) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const updateData = {
      ...data,
      updatedAt: now
    };
    const result = await this.db.update(creatives).set(updateData).where(and(eq(creatives.id, creativeId), eq(creatives.campaignId, campaignId))).returning();
    if (result.length === 0) {
      throw new NotFoundError("Creative not found");
    }
    return result[0];
  }
  async deleteCreative(campaignId, creativeId) {
    const result = await this.db.delete(creatives).where(and(eq(creatives.id, creativeId), eq(creatives.campaignId, campaignId))).returning();
    return result.length > 0;
  }
  // Campaign-Show relationship methods
  async addShowToCampaign(campaignId, showId) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    await this.db.insert(campaignShows).values({
      campaignId,
      showId,
      createdAt: now
    }).onConflictDoNothing();
  }
  async removeShowFromCampaign(campaignId, showId) {
    const result = await this.db.delete(campaignShows).where(and(eq(campaignShows.campaignId, campaignId), eq(campaignShows.showId, showId))).returning();
    return result.length > 0;
  }
  async updateCampaignShows(campaignId, showIds) {
    await this.db.delete(campaignShows).where(eq(campaignShows.campaignId, campaignId));
    if (showIds.length > 0) {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const values = showIds.map((showId) => ({
        campaignId,
        showId,
        createdAt: now
      }));
      await this.db.insert(campaignShows).values(values);
    }
  }
  async findShowsByCampaign(campaignId) {
    return await this.db.select({
      id: shows.id,
      title: shows.title,
      description: shows.description,
      imageUrl: shows.imageUrl,
      createdAt: shows.createdAt,
      updatedAt: shows.updatedAt
    }).from(campaignShows).innerJoin(shows, eq(campaignShows.showId, shows.id)).where(eq(campaignShows.campaignId, campaignId)).orderBy(asc(shows.title));
  }
};

// dist/campaigns/service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
init_errors2();
var CampaignService = class {
  static {
    __name(this, "CampaignService");
  }
  campaignRepository;
  eventPublisher;
  constructor(campaignRepository, eventPublisher) {
    this.campaignRepository = campaignRepository;
    this.eventPublisher = eventPublisher;
  }
  async getAllCampaigns(pagination, organizationId) {
    return await this.campaignRepository.findAll(pagination, organizationId);
  }
  async getCampaignById(id, organizationId) {
    return await this.campaignRepository.findById(id, organizationId);
  }
  async getCampaignByIdWithDetails(id, organizationId) {
    return await this.campaignRepository.findByIdWithDetails(id, organizationId);
  }
  async createCampaign(data, organizationId) {
    const id = v4_default();
    const { showIds, ...campaignData } = data;
    const campaign = await this.campaignRepository.create({
      id,
      organizationId,
      name: campaignData.name,
      startDate: campaignData.startDate,
      endDate: campaignData.endDate,
      priority: campaignData.priority ?? 5,
      status: campaignData.status ?? "draft",
      advertiser: campaignData.advertiser ?? null,
      targetImpressions: campaignData.targetImpressions ?? null
    });
    if (showIds && showIds.length > 0) {
      await this.campaignRepository.updateCampaignShows(id, showIds);
    }
    await this.eventPublisher.publish("campaign.created", campaign, campaign.id);
    return campaign;
  }
  async updateCampaign(id, data, organizationId) {
    const { showIds, ...campaignData } = data;
    const campaign = await this.campaignRepository.update(id, campaignData, organizationId);
    if (showIds !== void 0) {
      await this.campaignRepository.updateCampaignShows(id, showIds);
    }
    await this.eventPublisher.publish("campaign.updated", campaign, campaign.id);
    return campaign;
  }
  async deleteCampaign(id, organizationId) {
    const campaign = await this.campaignRepository.findById(id, organizationId);
    if (!campaign) {
      return false;
    }
    const deleted = await this.campaignRepository.delete(id, organizationId);
    if (deleted) {
      await this.eventPublisher.publish("campaign.deleted", { id }, id);
    }
    return deleted;
  }
  // Creative management methods
  async getCampaignCreatives(campaignId, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    return await this.campaignRepository.findCreativesByCampaign(campaignId);
  }
  async getCreativeById(campaignId, creativeId, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    return await this.campaignRepository.findCreativeById(campaignId, creativeId);
  }
  async createCreative(campaignId, data, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    const id = v4_default();
    const creative = await this.campaignRepository.createCreative({
      id,
      campaignId,
      name: data.name,
      type: data.type ?? "audio",
      duration: data.duration,
      placementType: data.placementType ?? "any",
      language: data.language ?? null
    });
    await this.eventPublisher.publish("creative.created", creative, creative.id);
    return creative;
  }
  async updateCreative(campaignId, creativeId, data, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    const creative = await this.campaignRepository.updateCreative(campaignId, creativeId, data);
    await this.eventPublisher.publish("creative.updated", creative, creative.id);
    return creative;
  }
  async deleteCreative(campaignId, creativeId, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    const creative = await this.campaignRepository.findCreativeById(campaignId, creativeId);
    if (!creative) {
      return false;
    }
    const deleted = await this.campaignRepository.deleteCreative(campaignId, creativeId);
    if (deleted) {
      await this.eventPublisher.publish("creative.deleted", { id: creativeId, campaignId }, creativeId);
    }
    return deleted;
  }
  // Campaign-Show relationship methods
  async getCampaignShows(campaignId, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    return await this.campaignRepository.findShowsByCampaign(campaignId);
  }
  async addShowToCampaign(campaignId, showId, organizationId) {
    const campaign = await this.campaignRepository.findById(campaignId, organizationId);
    if (!campaign) {
      throw new NotFoundError("Campaign not found");
    }
    await this.campaignRepository.addShowToCampaign(campaignId, showId);
    await this.eventPublisher.publish("campaign.show.added", { campaignId, showId }, campaignId);
    return true;
  }
  async removeShowFromCampaign(campaignId, showId) {
    const removed = await this.campaignRepository.removeShowFromCampaign(campaignId, showId);
    if (removed) {
      await this.eventPublisher.publish("campaign.show.removed", { campaignId, showId }, campaignId);
    }
    return removed;
  }
};

// dist/campaigns/creative-upload-service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
init_errors2();
var CreativeUploadService = class {
  static {
    __name(this, "CreativeUploadService");
  }
  campaignRepo;
  eventPublisher;
  bucket;
  presignedUrlGenerator = null;
  database;
  constructor(database, bucket, eventPublisher, r2AccessKeyId, r2SecretAccessKey, r2Endpoint) {
    this.database = database;
    this.campaignRepo = new CampaignRepository(database);
    this.eventPublisher = eventPublisher || new EventPublisher();
    this.bucket = bucket;
    if (r2AccessKeyId && r2SecretAccessKey && r2Endpoint) {
      try {
        this.presignedUrlGenerator = new R2PreSignedUrlGenerator(r2AccessKeyId, r2SecretAccessKey, r2Endpoint);
        console.log("R2PreSignedUrlGenerator initialized successfully");
      } catch (error3) {
        console.warn("Failed to initialize R2PreSignedUrlGenerator:", error3);
        this.presignedUrlGenerator = null;
      }
    } else {
      console.warn("R2 credentials not provided, signed URL generation will be limited");
    }
  }
  async uploadCreativeAudio(campaignId, creativeId, file) {
    const creative = await this.campaignRepo.findCreativeById(campaignId, creativeId);
    if (!creative) {
      throw new NotFoundError("Creative not found");
    }
    if (!file.mimeType.startsWith("audio/")) {
      throw new Error("File must be an audio file");
    }
    const uploadId = v4_default();
    const fileName = file.fileName;
    const key = `creatives/audio/${campaignId}/${creativeId}/${uploadId}/${fileName}`;
    let url;
    let signedUrl;
    if (this.bucket) {
      await this.bucket.put(key, file.buffer, {
        httpMetadata: {
          contentType: file.mimeType
        }
      });
      url = `r2://${key}`;
      if (this.presignedUrlGenerator) {
        try {
          const directUrl = this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", key);
          signedUrl = directUrl || url;
        } catch (error3) {
          console.warn("Failed to generate URL, using r2:// fallback:", error3);
          signedUrl = url;
        }
      } else {
        console.warn("No R2 credentials available for URL generation");
        signedUrl = url;
      }
    } else {
      url = `https://storage.example.com/creatives/audio/${campaignId}/${creativeId}/${uploadId}/${fileName}`;
      signedUrl = url;
    }
    try {
      console.log(`Updating creative ${creativeId} with audio URL`);
      await this.campaignRepo.updateCreative(campaignId, creativeId, {
        audioUrl: url,
        // Store R2 key for audio files
        type: "audio"
        // Ensure type is set to audio
      });
      console.log(`Creative updated successfully`);
    } catch (error3) {
      console.error("Failed to update creative:", error3);
      throw new Error(`Database error: Failed to update creative - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    const creativeUpload = {
      id: uploadId,
      campaignId,
      creativeId,
      fileName: file.fileName,
      fileSize: file.fileSize,
      mimeType: file.mimeType,
      url,
      // Store R2 key (r2://) for regenerating signed URLs
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    try {
      console.log(`Publishing creative.audio.uploaded event`);
      await this.eventPublisher.publish("creative.audio.uploaded", {
        ...creativeUpload,
        url: signedUrl
        // Include signed URL in event for immediate use
      }, creativeUpload.id);
      console.log(`Event published successfully`);
    } catch (error3) {
      console.error("Failed to publish event:", error3);
      throw new Error(`Event error: Failed to publish creative.audio.uploaded event - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    return {
      ...creativeUpload,
      url: signedUrl
    };
  }
  async uploadCreativeVideo(campaignId, creativeId, file) {
    const creative = await this.campaignRepo.findCreativeById(campaignId, creativeId);
    if (!creative) {
      throw new NotFoundError("Creative not found");
    }
    if (!file.mimeType.startsWith("video/")) {
      throw new Error("File must be a video file");
    }
    const uploadId = v4_default();
    const fileName = file.fileName;
    const key = `creatives/video/${campaignId}/${creativeId}/${uploadId}/${fileName}`;
    let url;
    let signedUrl;
    if (this.bucket) {
      await this.bucket.put(key, file.buffer, {
        httpMetadata: {
          contentType: file.mimeType
        }
      });
      url = `r2://${key}`;
      if (this.presignedUrlGenerator) {
        try {
          const directUrl = this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", key);
          signedUrl = directUrl || url;
        } catch (error3) {
          console.warn("Failed to generate URL, using r2:// fallback:", error3);
          signedUrl = url;
        }
      } else {
        console.warn("No R2 credentials available for URL generation");
        signedUrl = url;
      }
    } else {
      url = `https://storage.example.com/creatives/video/${campaignId}/${creativeId}/${uploadId}/${fileName}`;
      signedUrl = url;
    }
    try {
      console.log(`Updating creative ${creativeId} with video URL`);
      await this.campaignRepo.updateCreative(campaignId, creativeId, {
        audioUrl: url,
        // Store R2 key for video files (treating video as audio content)
        type: "video"
        // Ensure type is set to video
      });
      console.log(`Creative updated successfully`);
    } catch (error3) {
      console.error("Failed to update creative:", error3);
      throw new Error(`Database error: Failed to update creative - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    const creativeUpload = {
      id: uploadId,
      campaignId,
      creativeId,
      fileName: file.fileName,
      fileSize: file.fileSize,
      mimeType: file.mimeType,
      url,
      // Store R2 key (r2://) for regenerating signed URLs
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    try {
      console.log(`Publishing creative.video.uploaded event`);
      await this.eventPublisher.publish("creative.video.uploaded", {
        ...creativeUpload,
        url: signedUrl
        // Include signed URL in event for immediate use
      }, creativeUpload.id);
      console.log(`Event published successfully`);
    } catch (error3) {
      console.error("Failed to publish event:", error3);
      throw new Error(`Event error: Failed to publish creative.video.uploaded event - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    return {
      ...creativeUpload,
      url: signedUrl
    };
  }
  async uploadCreativeImage(campaignId, creativeId, file) {
    const creative = await this.campaignRepo.findCreativeById(campaignId, creativeId);
    if (!creative) {
      throw new NotFoundError("Creative not found");
    }
    if (!file.mimeType.startsWith("image/")) {
      throw new Error("File must be an image file");
    }
    const uploadId = v4_default();
    const fileName = file.fileName;
    const key = `creatives/image/${campaignId}/${creativeId}/${uploadId}/${fileName}`;
    let url;
    let signedUrl;
    if (this.bucket) {
      await this.bucket.put(key, file.buffer, {
        httpMetadata: {
          contentType: file.mimeType
        }
      });
      url = `r2://${key}`;
      if (this.presignedUrlGenerator) {
        try {
          const directUrl = this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", key);
          signedUrl = directUrl || url;
        } catch (error3) {
          console.warn("Failed to generate URL, using r2:// fallback:", error3);
          signedUrl = url;
        }
      } else {
        console.warn("No R2 credentials available for URL generation");
        signedUrl = url;
      }
    } else {
      url = `https://storage.example.com/creatives/image/${campaignId}/${creativeId}/${uploadId}/${fileName}`;
      signedUrl = url;
    }
    try {
      console.log(`Updating creative ${creativeId} with image URL`);
      await this.campaignRepo.updateCreative(campaignId, creativeId, {
        imageUrl: url
        // Store R2 key for image files
      });
      console.log(`Creative updated successfully`);
    } catch (error3) {
      console.error("Failed to update creative:", error3);
      throw new Error(`Database error: Failed to update creative - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    const creativeUpload = {
      id: uploadId,
      campaignId,
      creativeId,
      fileName: file.fileName,
      fileSize: file.fileSize,
      mimeType: file.mimeType,
      url,
      // Store R2 key (r2://) for regenerating signed URLs
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    try {
      console.log(`Publishing creative.image.uploaded event`);
      await this.eventPublisher.publish("creative.image.uploaded", {
        ...creativeUpload,
        url: signedUrl
        // Include signed URL in event for immediate use
      }, creativeUpload.id);
      console.log(`Event published successfully`);
    } catch (error3) {
      console.error("Failed to publish event:", error3);
      throw new Error(`Event error: Failed to publish creative.image.uploaded event - ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
    return {
      ...creativeUpload,
      url: signedUrl
    };
  }
  async getCreativeMetadata(campaignId, creativeId) {
    const creative = await this.campaignRepo.findCreativeById(campaignId, creativeId);
    if (!creative) {
      throw new NotFoundError("Creative not found");
    }
    let signedAudioUrl = creative.audioUrl;
    let signedImageUrl = creative.imageUrl;
    if (this.presignedUrlGenerator && creative.audioUrl && creative.audioUrl.startsWith("r2://")) {
      try {
        const directUrl = this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", creative.audioUrl.replace("r2://", ""));
        signedAudioUrl = directUrl || creative.audioUrl;
      } catch (error3) {
        console.warn("Failed to generate signed audio URL:", error3);
      }
    }
    if (this.presignedUrlGenerator && creative.imageUrl && creative.imageUrl.startsWith("r2://")) {
      try {
        const directUrl = this.presignedUrlGenerator.generateDirectUrl("podcast-service-assets", creative.imageUrl.replace("r2://", ""));
        signedImageUrl = directUrl || creative.imageUrl;
      } catch (error3) {
        console.warn("Failed to generate signed image URL:", error3);
      }
    }
    return {
      ...creative,
      audioUrl: signedAudioUrl,
      imageUrl: signedImageUrl
    };
  }
};

// dist/organizations/service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_drizzle_orm();
init_schema3();
var PODCAST_ADMIN_ROLE_ID = "Qh3bDMuHe_xDJPPXMa-WG";
var OrganizationService = class {
  static {
    __name(this, "OrganizationService");
  }
  db;
  auth0Service;
  constructor(db2, auth0Service) {
    this.db = db2;
    this.auth0Service = auth0Service;
  }
  /**
   * Get organization by ID
   */
  async getOrganization(id) {
    if (!this.db) {
      throw new Error("Database not available");
    }
    const result = await this.db.select().from(organizations).where(eq(organizations.id, id)).limit(1);
    return result[0] || null;
  }
  /**
   * Get organization by ID (which is the Auth0 organization ID)
   */
  async getOrganizationById(id) {
    if (!this.db) {
      throw new Error("Database not available");
    }
    const result = await this.db.select().from(organizations).where(eq(organizations.id, id)).limit(1);
    return result[0] || null;
  }
  /**
   * Get user's organizations from Auth0
   */
  async getUserOrganizations(userId) {
    if (!this.auth0Service) {
      throw new Error("Auth0 service not configured");
    }
    try {
      const auth0Orgs = await this.auth0Service.getUserOrganizations(userId);
      return auth0Orgs.map((org) => ({
        id: org.id,
        name: org.display_name || org.name,
        auth0_id: org.id
      }));
    } catch (error3) {
      console.error("Failed to get user organizations:", error3);
      throw new Error("Failed to fetch user organizations");
    }
  }
  /**
   * Create a new organization both in Auth0 and locally
   */
  async createOrganization(name, userId, displayName) {
    if (!this.auth0Service) {
      throw new Error("Auth0 service not configured");
    }
    if (!this.db) {
      throw new Error("Database not available");
    }
    try {
      const auth0Org = await this.auth0Service.createOrganization(name, displayName);
      console.log(`Created organization in Auth0 with ID: ${auth0Org.id}`);
      await this.auth0Service.addUserToOrganization(auth0Org.id, userId, [
        PODCAST_ADMIN_ROLE_ID
      ]);
      console.log(`User ${userId} added to organization ${auth0Org.id}`);
      let localOrg = await this.getOrganizationById(auth0Org.id);
      if (!localOrg) {
        const newOrg = {
          id: auth0Org.id,
          // Use Auth0 ID directly
          name: auth0Org.display_name || auth0Org.name,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const result = await this.db.insert(organizations).values(newOrg).returning();
        localOrg = result[0];
      }
      return {
        organization: localOrg,
        auth0_org: auth0Org
      };
    } catch (error3) {
      if (error3.message && error3.message.includes("already exists")) {
        console.log(`Organization '${name}' already exists in Auth0, attempting to find it...`);
        const existingOrg = await this.auth0Service.findOrganizationByName(name);
        if (existingOrg) {
          console.log(`Found existing organization with ID: ${existingOrg.id}`);
          const userOrganizations = await this.auth0Service.getUserOrganizations(userId);
          const isMember = userOrganizations.some((org) => org.id === existingOrg.id);
          if (!isMember) {
            throw new Error("You are not authorized to access this organization");
          }
          let localOrg = await this.getOrganizationById(existingOrg.id);
          if (!localOrg) {
            const newOrg = {
              id: existingOrg.id,
              // Use Auth0 ID directly
              name: existingOrg.display_name || existingOrg.name,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              updatedAt: (/* @__PURE__ */ new Date()).toISOString()
            };
            const result = await this.db.insert(organizations).values(newOrg).returning();
            localOrg = result[0];
          }
          return {
            organization: localOrg,
            auth0_org: existingOrg
          };
        } else {
          console.error(`Could not find existing organization with name '${name}'`);
          throw error3;
        }
      }
      console.error("Failed to create organization:", error3);
      const errorMessage = error3.message || "Failed to create organization";
      throw new Error(errorMessage);
    }
  }
  /**
   * Sync an Auth0 organization to local database if it doesn't exist
   */
  async syncOrganization(auth0OrgId) {
    let org = await this.getOrganizationById(auth0OrgId);
    if (org) {
      return org;
    }
    if (!this.db) {
      throw new Error("Database not available");
    }
    if (!this.auth0Service) {
      throw new Error("Auth0 service not configured");
    }
    try {
      const auth0Org = await this.auth0Service.getOrganization(auth0OrgId);
      if (!auth0Org) {
        throw new Error(`Organization with ID ${auth0OrgId} not found in Auth0`);
      }
      const newOrg = {
        id: auth0Org.id,
        // Use Auth0 ID directly
        name: auth0Org.display_name || auth0Org.name,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const result = await this.db.insert(organizations).values(newOrg).returning();
      return result[0];
    } catch (error3) {
      console.error("Error syncing organization:", error3);
      throw new Error("Failed to sync organization");
    }
  }
};

// dist/auth/auth0-service.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/management/management-client.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/management/__generated/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/management/__generated/managers/actions-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/lib/runtime.js
var runtime_exports = {};
__export(runtime_exports, {
  BaseAPI: () => BaseAPI,
  COLLECTION_FORMATS: () => COLLECTION_FORMATS,
  CustomDomainHeader: () => CustomDomainHeader,
  JSONApiResponse: () => JSONApiResponse,
  TextApiResponse: () => TextApiResponse,
  VoidApiResponse: () => VoidApiResponse,
  applyQueryParams: () => applyQueryParams,
  parseFormParam: () => parseFormParam,
  validateRequiredRequestParams: () => validateRequiredRequestParams
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/lib/retry.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MAX_REQUEST_RETRY_JITTER = 250;
var MAX_REQUEST_RETRY_DELAY = 1e4;
var DEFAULT_NUMBER_RETRIES = 3;
var MAX_NUMBER_RETRIES = 10;
var BASE_DELAY = 500;
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min) + min);
}
__name(getRandomInt, "getRandomInt");
async function pause(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
__name(pause, "pause");
function retry(action, { maxRetries, retryWhen }) {
  const nrOfTriesToAttempt = Math.min(MAX_NUMBER_RETRIES, maxRetries !== null && maxRetries !== void 0 ? maxRetries : DEFAULT_NUMBER_RETRIES);
  let nrOfTries = 0;
  const retryAndWait = /* @__PURE__ */ __name(async () => {
    let result;
    result = await action();
    if ((retryWhen || [429]).includes(result.status) && nrOfTries < nrOfTriesToAttempt) {
      nrOfTries++;
      let wait = BASE_DELAY * Math.pow(2, nrOfTries - 1);
      wait = getRandomInt(wait + 1, wait + MAX_REQUEST_RETRY_JITTER);
      wait = Math.min(wait, MAX_REQUEST_RETRY_DELAY);
      await pause(wait);
      result = await retryAndWait();
    }
    return result;
  }, "retryAndWait");
  return retryAndWait();
}
__name(retry, "retry");

// node_modules/auth0/dist/esm/lib/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ResponseError = class extends Error {
  static {
    __name(this, "ResponseError");
  }
  constructor(statusCode, body, headers, msg) {
    super(msg);
    this.statusCode = statusCode;
    this.body = body;
    this.headers = headers;
    this.name = "ResponseError";
  }
};
var TimeoutError = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor() {
    super("The request was timed out.");
    this.name = "TimeoutError";
  }
};
var FetchError = class extends Error {
  static {
    __name(this, "FetchError");
  }
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  static {
    __name(this, "RequiredError");
  }
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// node_modules/auth0/dist/esm/lib/models.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSONApiResponse = class _JSONApiResponse {
  static {
    __name(this, "JSONApiResponse");
  }
  constructor(data, headers, status, statusText) {
    this.data = data;
    this.headers = headers;
    this.status = status;
    this.statusText = statusText;
  }
  static async fromResponse(raw2) {
    const value = await raw2.json();
    return new _JSONApiResponse(value, raw2.headers, raw2.status, raw2.statusText);
  }
};
var VoidApiResponse = class _VoidApiResponse {
  static {
    __name(this, "VoidApiResponse");
  }
  constructor(headers, status, statusText) {
    this.headers = headers;
    this.status = status;
    this.statusText = statusText;
  }
  static async fromResponse(raw2) {
    return new _VoidApiResponse(raw2.headers, raw2.status, raw2.statusText);
  }
};
var TextApiResponse = class _TextApiResponse {
  static {
    __name(this, "TextApiResponse");
  }
  constructor(data, headers, status, statusText) {
    this.data = data;
    this.headers = headers;
    this.status = status;
    this.statusText = statusText;
  }
  static async fromResponse(raw2) {
    const value = await raw2.text();
    return new _TextApiResponse(value, raw2.headers, raw2.status, raw2.statusText);
  }
};

// node_modules/auth0/dist/esm/lib/runtime.js
var BaseAPI = class {
  static {
    __name(this, "BaseAPI");
  }
  constructor(configuration) {
    this.configuration = configuration;
    this.fetchWithTimeout = async (url, init) => {
      const controller = new AbortController();
      const timeout = setTimeout(() => {
        controller.abort();
      }, this.timeoutDuration);
      try {
        return await this.fetchApi(url, { signal: controller.signal, ...init });
      } catch (e) {
        if (e.name === "AbortError") {
          throw new TimeoutError();
        }
        throw e;
      } finally {
        clearTimeout(timeout);
      }
    };
    this.fetch = async (url, init) => {
      var _a2, _b;
      let fetchParams = { url, init };
      for (const middleware2 of this.middleware) {
        if (middleware2.pre) {
          fetchParams = await middleware2.pre({
            fetch: this.fetchWithTimeout,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      let error3 = void 0;
      try {
        response = ((_a2 = this.configuration.retry) === null || _a2 === void 0 ? void 0 : _a2.enabled) !== false ? await retry(() => this.fetchWithTimeout(fetchParams.url, fetchParams.init), {
          ...this.configuration.retry
        }) : await this.fetchWithTimeout(fetchParams.url, fetchParams.init);
      } catch (e) {
        error3 = e;
      }
      if (error3 || !response.ok) {
        for (const middleware2 of this.middleware) {
          if (middleware2.onError) {
            response = await middleware2.onError({
              fetch: this.fetchWithTimeout,
              ...fetchParams,
              error: error3,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          throw new FetchError(error3, (_b = error3 === null || error3 === void 0 ? void 0 : error3.message) !== null && _b !== void 0 ? _b : "The request failed and the interceptors did not return an alternative response");
        }
      } else {
        for (const middleware2 of this.middleware) {
          if (middleware2.post) {
            response = await middleware2.post({
              fetch: this.fetchApi,
              ...fetchParams,
              response: response.clone()
            }) || response;
          }
        }
      }
      return response;
    };
    if (configuration.baseUrl === null || configuration.baseUrl === void 0) {
      throw new Error("Must provide a base URL for the API");
    }
    if ("string" !== typeof configuration.baseUrl || configuration.baseUrl.length === 0) {
      throw new Error("The provided base URL is invalid");
    }
    this.middleware = configuration.middleware || [];
    this.fetchApi = configuration.fetch || globalThis.fetch.bind(globalThis);
    this.parseError = configuration.parseError;
    this.timeoutDuration = typeof configuration.timeoutDuration === "number" ? configuration.timeoutDuration : 1e4;
  }
  async request(context2, initOverrides) {
    const { url, init } = await this.createFetchParams(context2, initOverrides);
    const response = await this.fetch(url, init);
    if (response && response.status >= 200 && response.status < 300) {
      return response;
    }
    const error3 = await this.parseError(response);
    throw error3;
  }
  async createFetchParams(context2, initOverrides) {
    let url = this.configuration.baseUrl + context2.path;
    if (context2.query !== void 0 && Object.keys(context2.query).length !== 0) {
      url += `?${querystring(context2.query)}`;
    }
    const headers = Object.assign({}, this.configuration.headers, context2.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context2.method,
      headers,
      body: context2.body,
      dispatcher: this.configuration.agent
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context: context2
      })
    };
    const init = {
      ...overriddenInit,
      body: overriddenInit.body instanceof FormData || overriddenInit.body instanceof URLSearchParams || overriddenInit.body instanceof Blob ? overriddenInit.body : JSON.stringify(overriddenInit.body)
    };
    return { url, init };
  }
};
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
function querystring(params) {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key])).filter((part) => part.length > 0).join("&");
}
__name(querystring, "querystring");
function querystringSingleKey(key, value) {
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(key)}=`);
    return `${encodeURIComponent(key)}=${multiValue}`;
  }
  return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
}
__name(querystringSingleKey, "querystringSingleKey");
function validateRequiredRequestParams(requestParameters, keys) {
  keys.forEach((key) => {
    if (requestParameters[key] === null || requestParameters[key] === void 0) {
      throw new RequiredError(key, `Required parameter requestParameters.${key} was null or undefined.`);
    }
  });
}
__name(validateRequiredRequestParams, "validateRequiredRequestParams");
function applyQueryParams(requestParameters, keys) {
  return keys.reduce((acc, { key, config: config2 }) => {
    let value;
    if (config2.isArray) {
      if (config2.isCollectionFormatMulti) {
        value = requestParameters[key];
      } else {
        value = requestParameters[key].join(COLLECTION_FORMATS[config2.collectionFormat]);
      }
    } else {
      if (requestParameters[key] !== void 0) {
        value = requestParameters[key];
      }
    }
    return value !== void 0 ? { ...acc, [key]: value } : acc;
  }, {});
}
__name(applyQueryParams, "applyQueryParams");
var compiledWhitelistedPathRegexes = compileWhitelistedPathPatterns();
function compileWhitelistedPathPatterns() {
  const patterns = [
    "^/api/v2/jobs/verification-email$",
    "^/api/v2/tickets/email-verification$",
    "^/api/v2/tickets/password-change$",
    "^/api/v2/organizations/[^/]+/invitations$",
    "^/api/v2/users$",
    "^/api/v2/users/[^/]+$",
    "^/api/v2/guardian/enrollments/ticket$"
  ];
  return patterns.map((pattern) => new RegExp(pattern));
}
__name(compileWhitelistedPathPatterns, "compileWhitelistedPathPatterns");
function isCustomDomainPathWhitelisted(path) {
  return compiledWhitelistedPathRegexes.some((regex) => regex.test(path));
}
__name(isCustomDomainPathWhitelisted, "isCustomDomainPathWhitelisted");
function CustomDomainHeader(domain2) {
  return async ({ init, context: context2 }) => {
    const headers = { ...init.headers };
    const formattedPath = context2.path.startsWith("/api/v2/") ? context2.path : `/api/v2${context2.path}`;
    if (isCustomDomainPathWhitelisted(formattedPath)) {
      headers["auth0-custom-domain"] = domain2;
    }
    return { ...init, headers };
  };
}
__name(CustomDomainHeader, "CustomDomainHeader");
async function parseFormParam(originalValue) {
  let value = originalValue;
  value = typeof value == "number" || typeof value == "boolean" ? "" + value : value;
  return value;
}
__name(parseFormParam, "parseFormParam");

// node_modules/auth0/dist/esm/management/__generated/managers/actions-manager.js
var { BaseAPI: BaseAPI2 } = runtime_exports;
var ActionsManager = class extends BaseAPI2 {
  static {
    __name(this, "ActionsManager");
  }
  /**
   * Deletes an action and all of its associated versions. An action must be unbound from all triggers
   * before it can be deleted.
   *
   * Delete an action
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "force",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/actions/actions/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      query: queryParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve an action by its ID.
   *
   * Get an action
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/actions/actions/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a specific version of an action. An action version is created whenever
   * an action is deployed. An action version is immutable, once created.
   *
   * Get a specific version of an action
   *
   * @throws {RequiredError}
   */
  async getVersion(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["actionId", "id"]);
    const response = await this.request({
      path: `/actions/actions/{actionId}/versions/{id}`.replace("{actionId}", encodeURIComponent(String(requestParameters.actionId))).replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve all of an action's versions. An action version is created whenever
   * an action is deployed. An action version is immutable, once created.
   *
   * Get an action's versions
   *
   * @throws {RequiredError}
   */
  async getVersions(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["actionId"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/actions/actions/{actionId}/versions`.replace("{actionId}", encodeURIComponent(String(requestParameters.actionId))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve all actions.
   *
   * Get actions
   *
   * @throws {RequiredError}
   */
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "triggerId",
        config: {}
      },
      {
        key: "actionName",
        config: {}
      },
      {
        key: "deployed",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "installed",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/actions/actions`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the actions that are bound to a trigger. Once an action is created and deployed, it must be
   * attached (i.e. bound) to a trigger so that it will be executed as part of a flow. The list of actions returned
   * reflects the order in which they will be executed during the appropriate flow.
   *
   * Get trigger bindings
   *
   * @throws {RequiredError}
   */
  async getTriggerBindings(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["triggerId"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/actions/triggers/{triggerId}/bindings`.replace("{triggerId}", encodeURIComponent(String(requestParameters.triggerId))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve information about a specific execution of a trigger. Relevant execution IDs will be included in tenant logs
   * generated as part of that authentication flow. Executions will only be stored for 10 days after their creation.
   *
   * Get an execution
   *
   * @throws {RequiredError}
   */
  async getExecution(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/actions/executions/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the set of triggers currently available within actions. A trigger is an extensibility point to which actions
   * can be bound.
   *
   * Get triggers
   *
   * @throws {RequiredError}
   */
  async getAllTriggers(initOverrides) {
    const response = await this.request({
      path: `/actions/triggers`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update an existing action. If this action is currently bound to a trigger, updating it will <strong>not</strong> affect
   * any user flows until the action is deployed.
   *
   * Update an action
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/actions/actions/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update the actions that are bound (i.e. attached) to a trigger. Once an action is created and deployed, it must be
   * attached (i.e. bound) to a trigger so that it will be executed as part of a flow. The order in which the actions are
   * provided will determine the order in which they are executed.
   *
   * Update trigger bindings
   *
   * @throws {RequiredError}
   */
  async updateTriggerBindings(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["triggerId"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/actions/triggers/{triggerId}/bindings`.replace("{triggerId}", encodeURIComponent(String(requestParameters.triggerId))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create an action. Once an action is created, it must be deployed, and then
   * bound to a trigger before it will be executed as part of a flow.
   *
   * Create an action
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/actions/actions`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Deploy an action. Deploying an action will create a new immutable version of the action. If the action is
   * currently bound to a trigger, then the system will begin executing the newly deployed version of the action immediately. Otherwise, the action will only be executed as a part of a flow once it is bound to that flow.
   *
   * Deploy an action
   *
   * @throws {RequiredError}
   */
  async deploy(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/actions/actions/{id}/deploy`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Performs the equivalent of a roll-back of an action to an earlier, specified version. Creates a new, deployed
   * action version that is identical to the specified version. If this action is currently bound to a trigger, the
   * system will begin executing the newly-created version immediately.
   *
   * Roll back to a previous action version
   *
   * @throws {RequiredError}
   */
  async deployVersion(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "actionId"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/actions/actions/{actionId}/versions/{id}/deploy`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{actionId}", encodeURIComponent(String(requestParameters.actionId))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Test an action. After updating an action, it can be tested prior to being deployed to ensure it behaves as expected.
   *
   * Test an Action
   *
   * @throws {RequiredError}
   */
  async test(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/actions/actions/{id}/test`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/anomaly-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI3 } = runtime_exports;
var AnomalyManager = class extends BaseAPI3 {
  static {
    __name(this, "AnomalyManager");
  }
  /**
   * Unblock an IP address currently blocked by the <a href="https://auth0.com/docs/configure/attack-protection/suspicious-ip-throttling">Suspicious IP Throttling</a> due to multiple suspicious attempts.
   * Remove the blocked IP address
   *
   * @throws {RequiredError}
   */
  async deleteBlockedIp(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/anomaly/blocks/ips/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Check if a given IP address is blocked via the <a href="https://auth0.com/docs/configure/attack-protection/suspicious-ip-throttling">Suspicious IP Throttling</a> due to multiple suspicious attempts.
   * Check if an IP address is blocked
   *
   * @throws {RequiredError}
   */
  async checkIfIpIsBlocked(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/anomaly/blocks/ips/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/attack-protection-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI4 } = runtime_exports;
var AttackProtectionManager = class extends BaseAPI4 {
  static {
    __name(this, "AttackProtectionManager");
  }
  /**
   * Retrieve details of the Breached Password Detection configuration of your tenant.
   * Get Breached Password Detection settings
   *
   * @throws {RequiredError}
   */
  async getBreachedPasswordDetectionConfig(initOverrides) {
    const response = await this.request({
      path: `/attack-protection/breached-password-detection`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get the brute force configuration
   *
   * @throws {RequiredError}
   */
  async getBruteForceConfig(initOverrides) {
    const response = await this.request({
      path: `/attack-protection/brute-force-protection`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get the suspicious IP throttling configuration
   *
   * @throws {RequiredError}
   */
  async getSuspiciousIpThrottlingConfig(initOverrides) {
    const response = await this.request({
      path: `/attack-protection/suspicious-ip-throttling`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update details of the Breached Password Detection configuration of your tenant.
   * Update Breached Password Detection settings
   *
   * @throws {RequiredError}
   */
  async updateBreachedPasswordDetectionConfig(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/attack-protection/breached-password-detection`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update the brute force configuration
   *
   * @throws {RequiredError}
   */
  async updateBruteForceConfig(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/attack-protection/brute-force-protection`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update the suspicious IP throttling configuration
   *
   * @throws {RequiredError}
   */
  async updateSuspiciousIpThrottlingConfig(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/attack-protection/suspicious-ip-throttling`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/blacklists-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI5 } = runtime_exports;
var BlacklistsManager = class extends BaseAPI5 {
  static {
    __name(this, "BlacklistsManager");
  }
  /**
   * Retrieve the `jti` and `aud` of all tokens that are blacklisted.
   *
   * Note: The <a href="https://auth0.com/docs/jwt">JWT specification</a> states that the `jti` field can be used to prevent replay attacks. Though Auth0 tokens do not include a `jti`, you can nevertheless blacklist a `jti` to prevent a token being used more than a predetermined number of times. This behavior is similar to implementing a nonce (where the token's signature can be thought of as the nonce). If a token gets stolen, it (or the tokens issued after it) should be blacklisted and let expire.
   *
   * Get blacklisted tokens
   *
   * @throws {RequiredError}
   */
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "aud",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/blacklists/tokens`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Add the token identified by the `jti` to a blacklist for the tenant.
   *
   * Blacklist a token
   *
   * @throws {RequiredError}
   */
  async add(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/blacklists/tokens`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/branding-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI6 } = runtime_exports;
var BrandingManager = class extends BaseAPI6 {
  static {
    __name(this, "BrandingManager");
  }
  /**
   * Create a <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone provider</a>.
   * The <code>credentials</code> object requires different properties depending on the phone provider (which is specified using the <code>name</code> property).
   *
   * Configure the phone provider
   *
   * @throws {RequiredError}
   */
  async configurePhoneProvider(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/phone/providers`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a phone notification template
   *
   * @throws {RequiredError}
   */
  async createPhoneTemplate(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/phone/templates`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Delete branding theme.
   * Delete branding theme
   *
   * @throws {RequiredError}
   */
  async deleteTheme(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["themeId"]);
    const response = await this.request({
      path: `/branding/themes/{themeId}`.replace("{themeId}", encodeURIComponent(String(requestParameters.themeId))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete the configured phone provider.
   *
   * Deletes a Phone Provider
   *
   * @throws {RequiredError}
   */
  async deletePhoneProvider(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/branding/phone/providers/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a phone notification template
   *
   * @throws {RequiredError}
   */
  async deletePhoneTemplate(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/branding/phone/templates/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete template for New Universal Login Experience
   *
   * @throws {RequiredError}
   */
  async deleteUniversalLoginTemplate(initOverrides) {
    const response = await this.request({
      path: `/branding/templates/universal-login`,
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve branding settings.
   * Get branding settings
   *
   * @throws {RequiredError}
   */
  async getSettings(initOverrides) {
    const response = await this.request({
      path: `/branding`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a list of <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone providers</a> details set for a Tenant. A list of fields to include or exclude may also be specified.
   *
   * Get a list of phone providers
   *
   * @throws {RequiredError}
   */
  async getAllPhoneProviders(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "disabled",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/branding/phone/providers`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve branding theme.
   * Get branding theme
   *
   * @throws {RequiredError}
   */
  async getTheme(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["themeId"]);
    const response = await this.request({
      path: `/branding/themes/{themeId}`.replace("{themeId}", encodeURIComponent(String(requestParameters.themeId))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve default branding theme.
   * Get default branding theme
   *
   * @throws {RequiredError}
   */
  async getDefaultTheme(initOverrides) {
    const response = await this.request({
      path: `/branding/themes/default`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone provider</a> details. A list of fields to include or exclude may also be specified.
   *
   * Get a phone provider
   *
   * @throws {RequiredError}
   */
  async getPhoneProvider(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/branding/phone/providers/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a phone notification template
   *
   * @throws {RequiredError}
   */
  async getPhoneTemplate(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/branding/phone/templates/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a list of phone notification templates
   *
   * @throws {RequiredError}
   */
  async getAllPhoneTemplates(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "disabled",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/branding/phone/templates`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get template for New Universal Login Experience
   *
   * @throws {RequiredError}
   */
  async getUniversalLoginTemplate(initOverrides) {
    const response = await this.request({
      path: `/branding/templates/universal-login`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update branding settings.
   * Update branding settings
   *
   * @throws {RequiredError}
   */
  async updateSettings(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update branding theme.
   * Update branding theme
   *
   * @throws {RequiredError}
   */
  async updateTheme(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["themeId"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/themes/{themeId}`.replace("{themeId}", encodeURIComponent(String(requestParameters.themeId))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create branding theme.
   * Create branding theme
   *
   * @throws {RequiredError}
   */
  async createTheme(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/themes`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update the Universal Login branding template.
   *
   * <p>When <code>content-type</code> header is set to <code>application/json</code>, the expected body must be JSON:</p>
   * <pre>
   * {
   *   "template": "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;{%- auth0:head -%}&lt;/head&gt;&lt;body&gt;{%- auth0:widget -%}&lt;/body&gt;&lt;/html&gt;"
   * }
   * </pre>
   *
   * <p>
   *   When <code>content-type</code> header is set to <code>text/html</code>, the expected body must be the HTML template:
   * </p>
   * <pre>
   * &lt!DOCTYPE html&gt;
   * &lt;code&gt;
   *   &lt;html&gt;
   *     &lt;head&gt;
   *      {%- auth0:head -%}
   *     &lt;/head&gt;
   *     &lt;body&gt;
   *       {%- auth0:widget -%}
   *     &lt;/body&gt;
   *   &lt;/html&gt;
   * &lt;/code&gt;
   * </pre>
   *
   * Set template for New Universal Login Experience
   *
   * @throws {RequiredError}
   */
  async setUniversalLoginTemplate(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/templates/universal-login`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Resets a phone notification template values
   *
   * @throws {RequiredError}
   */
  async resetTemplate(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/phone/templates/{id}/reset`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a <a href="https://auth0.com/docs/customize/phone-messages/configure-phone-messaging-providers">phone provider</a>.
   * The <code>credentials</code> object requires different properties depending on the phone provider (which is specified using the <code>name</code> property).
   *
   * Update the phone provider
   *
   * @throws {RequiredError}
   */
  async updatePhoneProvider(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/phone/providers/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a phone notification template
   *
   * @throws {RequiredError}
   */
  async updatePhoneTemplate(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/branding/phone/templates/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/client-grants-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI7 } = runtime_exports;
var ClientGrantsManager = class extends BaseAPI7 {
  static {
    __name(this, "ClientGrantsManager");
  }
  /**
   * Delete a client grant.
   * Delete client grant
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/client-grants/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAllOrganizations(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/client-grants/{id}/organizations`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "audience",
        config: {}
      },
      {
        key: "client_id",
        config: {}
      },
      {
        key: "allow_any_organization",
        config: {}
      },
      {
        key: "subject_type",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/client-grants`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a client grant.
   * Update client grant
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/client-grants/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a client grant.
   * Create client grant
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/client-grants`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/clients-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI8 } = runtime_exports;
var ClientsManager = class extends BaseAPI8 {
  static {
    __name(this, "ClientsManager");
  }
  /**
   * Delete a client and related configuration (rules, connections, etc).
   * Delete a client
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const response = await this.request({
      path: `/clients/{client_id}`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a client credential you previously created. May be enabled or disabled. For more information, read <a href="https://www.auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow">Client Credential Flow</a>.
   * Delete a client credential
   *
   * @throws {RequiredError}
   */
  async deleteCredential(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id", "credential_id"]);
    const response = await this.request({
      path: `/clients/{client_id}/credentials/{credential_id}`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))).replace("{credential_id}", encodeURIComponent(String(requestParameters.credential_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve all connections that are enabled for the specified <a href="https://www.auth0.com/docs/get-started/applications"> Application</a>, using checkpoint pagination. A list of fields to include or exclude for each connection may also be specified.
   * <ul>
   *   <li>
   *     This endpoint requires the <code>read:connections</code> scope and any one of <code>read:clients</code> or <code>read:client_summary</code>.
   *   </li>
   *   <li>
   *     <b>Note</b>: The first time you call this endpoint, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no further results are remaining.
   *   </li>
   * </ul>
   *
   * Get enabled connections for a client
   *
   * @throws {RequiredError}
   */
  async getEnabledConnections(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "strategy",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/clients/{client_id}/connections`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "is_global",
        config: {}
      },
      {
        key: "is_first_party",
        config: {}
      },
      {
        key: "app_type",
        config: {}
      },
      {
        key: "client_ids",
        config: {}
      },
      {
        key: "q",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/clients`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve client details by ID. Clients are SSO connections or Applications linked with your Auth0 tenant. A list of fields to include or exclude may also be specified.
   * For more information, read <a href="https://www.auth0.com/docs/get-started/applications"> Applications in Auth0</a> and <a href="https://www.auth0.com/docs/authenticate/single-sign-on"> Single Sign-On</a>.
   * <ul>
   *   <li>
   *     The following properties can be retrieved with any of the scopes:
   *     <code>client_id</code>, <code>app_type</code>, <code>name</code>, and <code>description</code>.
   *   </li>
   *   <li>
   *     The following properties can only be retrieved with the <code>read:clients</code> or
   *     <code>read:client_keys</code> scopes:
   *     <code>callbacks</code>, <code>oidc_logout</code>, <code>allowed_origins</code>,
   *     <code>web_origins</code>, <code>tenant</code>, <code>global</code>, <code>config_route</code>,
   *     <code>callback_url_template</code>, <code>jwt_configuration</code>,
   *     <code>jwt_configuration.lifetime_in_seconds</code>, <code>jwt_configuration.secret_encoded</code>,
   *     <code>jwt_configuration.scopes</code>, <code>jwt_configuration.alg</code>, <code>api_type</code>,
   *     <code>logo_uri</code>, <code>allowed_clients</code>, <code>owners</code>, <code>custom_login_page</code>,
   *     <code>custom_login_page_off</code>, <code>sso</code>, <code>addons</code>, <code>form_template</code>,
   *     <code>custom_login_page_codeview</code>, <code>resource_servers</code>, <code>client_metadata</code>,
   *     <code>mobile</code>, <code>mobile.android</code>, <code>mobile.ios</code>, <code>allowed_logout_urls</code>,
   *     <code>token_endpoint_auth_method</code>, <code>is_first_party</code>, <code>oidc_conformant</code>,
   *     <code>is_token_endpoint_ip_header_trusted</code>, <code>initiate_login_uri</code>, <code>grant_types</code>,
   *     <code>refresh_token</code>, <code>refresh_token.rotation_type</code>, <code>refresh_token.expiration_type</code>,
   *     <code>refresh_token.leeway</code>, <code>refresh_token.token_lifetime</code>, <code>refresh_token.policies</code>, <code>organization_usage</code>,
   *     <code>organization_require_behavior</code>.
   *   </li>
   *   <li>
   *     The following properties can only be retrieved with the <code>read:client_keys</code> or <code>read:client_credentials</code> scopes:
   *     <code>encryption_key</code>, <code>encryption_key.pub</code>, <code>encryption_key.cert</code>,
   *     <code>client_secret</code>, <code>client_authentication_methods</code> and <code>signing_key</code>.
   *   </li>
   * </ul>
   *
   * Get client by ID
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/clients/{client_id}`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get the details of a client credential.
   *
   * <b>Important</b>: To enable credentials to be used for Private Key JWT authentication method, set the <code>client_authentication_methods</code> property on the client.
   * Get client credentials
   *
   * @throws {RequiredError}
   */
  async getCredentials(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const response = await this.request({
      path: `/clients/{client_id}/credentials`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get the details of a client credential.
   *
   * <b>Important</b>: To enable credentials to be used for Private Key JWT authentication method, set the <code>client_authentication_methods</code> property on the client.
   * Get client credential details
   *
   * @throws {RequiredError}
   */
  async getCredential(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id", "credential_id"]);
    const response = await this.request({
      path: `/clients/{client_id}/credentials/{credential_id}`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))).replace("{credential_id}", encodeURIComponent(String(requestParameters.credential_id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates a client's settings. For more information, read <a href="https://www.auth0.com/docs/get-started/applications"> Applications in Auth0</a> and <a href="https://www.auth0.com/docs/authenticate/single-sign-on"> Single Sign-On</a>.
   *
   * Notes:
   * - The `client_secret` and `signing_key` attributes can only be updated with the `update:client_keys` scope.
   * - The <code>client_authentication_methods</code> and <code>token_endpoint_auth_method</code> properties are mutually exclusive. Use
   * <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method. Otherwise, use <code>token_endpoint_auth_method</code>
   * to configure the client with client secret (basic or post) or with no authentication method (none).
   * - When using <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method, only specify the credential IDs
   * that were generated when creating the credentials on the client.
   * - To configure <code>client_authentication_methods</code>, the <code>update:client_credentials</code> scope is required.
   * - To configure <code>client_authentication_methods</code>, the property <code>jwt_configuration.alg</code> must be set to RS256.
   * Update a client
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/clients/{client_id}`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Change a client credential you previously created. May be enabled or disabled. For more information, read <a href="https://www.auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow">Client Credential Flow</a>.
   * Update a client credential
   *
   * @throws {RequiredError}
   */
  async updateCredential(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id", "credential_id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/clients/{client_id}/credentials/{credential_id}`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))).replace("{credential_id}", encodeURIComponent(String(requestParameters.credential_id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a new client (application or SSO integration). For more information, read <a href="https://www.auth0.com/docs/get-started/auth0-overview/create-applications">Create Applications</a>
   * <a href="https://www.auth0.com/docs/authenticate/single-sign-on/api-endpoints-for-single-sign-on>">API Endpoints for Single Sign-On</a>.
   *
   * Notes:
   * - We recommend leaving the `client_secret` parameter unspecified to allow the generation of a safe secret.
   * - The <code>client_authentication_methods</code> and <code>token_endpoint_auth_method</code> properties are mutually exclusive. Use
   * <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method. Otherwise, use <code>token_endpoint_auth_method</code>
   * to configure the client with client secret (basic or post) or with no authentication method (none).
   * - When using <code>client_authentication_methods</code> to configure the client with Private Key JWT authentication method, specify fully defined credentials.
   * These credentials will be automatically enabled for Private Key JWT authentication on the client.
   * - To configure <code>client_authentication_methods</code>, the <code>create:client_credentials</code> scope is required.
   * - To configure <code>client_authentication_methods</code>, the property <code>jwt_configuration.alg</code> must be set to RS256.
   *
   * <div class="alert alert-warning">SSO Integrations created via this endpoint will accept login requests and share user profile information.</div>
   *
   * Create a client
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/clients`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a client credential associated to your application. The credential will be created but not yet enabled for use with Private Key JWT authentication method. To enable the credential, set the <code>client_authentication_methods</code> property on the client.
   * For more information, read <a href="https://www.auth0.com//docs/get-started/applications/configure-private-key-jwt">Configure Private Key JWT Authentication</a>.
   * Create a client credential
   *
   * @throws {RequiredError}
   */
  async createCredential(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/clients/{client_id}/credentials`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Rotate a client secret.
   *
   * This endpoint cannot be used with clients configured with Private Key JWT authentication method (client_authentication_methods configured with private_key_jwt).
   *
   * Note: The generated secret is NOT base64 encoded.
   *
   * Rotate a client secret
   *
   * @throws {RequiredError}
   */
  async rotateClientSecret(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["client_id"]);
    const response = await this.request({
      path: `/clients/{client_id}/rotate-secret`.replace("{client_id}", encodeURIComponent(String(requestParameters.client_id))),
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/connections-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI9 } = runtime_exports;
var ConnectionsManager = class extends BaseAPI9 {
  static {
    __name(this, "ConnectionsManager");
  }
  /**
   * Deletes a connection and all its users.
   *
   * Delete a connection
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Deletes a scim configuration by its <code>connectionId</code>.
   *
   * Delete a connection's SCIM configuration
   *
   * @throws {RequiredError}
   */
  async deleteScimConfiguration(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/scim-configuration`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Deletes a scim token by its connection <code>id</code> and <code>tokenId</code>.
   *
   * Delete a connection's SCIM token
   *
   * @throws {RequiredError}
   */
  async deleteScimToken(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "tokenId"]);
    const response = await this.request({
      path: `/connections/{id}/scim-configuration/tokens/{tokenId}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{tokenId}", encodeURIComponent(String(requestParameters.tokenId))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Deletes a specified connection user by its email (you cannot delete all users from specific connection). Currently, only Database Connections are supported.
   *
   * Delete a connection user
   *
   * @throws {RequiredError}
   */
  async deleteUserByEmail(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "email"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "email",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/connections/{id}/users`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      query: queryParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve all clients that have the specified <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a> enabled.
   *
   * <b>Note</b>: The first time you call this endpoint, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no further results are remaining.
   *
   * Get enabled clients for a connection
   *
   * @throws {RequiredError}
   */
  async getEnabledClients(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "take",
        config: {}
      },
      {
        key: "from",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/connections/{id}/clients`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "strategy",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      },
      {
        key: "domain_alias",
        config: {}
      },
      {
        key: "name",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/connections`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details for a specified <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a> along with options that can be used for identity provider configuration.
   * Get a connection
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/connections/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieves a scim configuration's default mapping by its <code>connectionId</code>.
   *
   * Get a connection's default SCIM mapping
   *
   * @throws {RequiredError}
   */
  async getDefaultScimMapping(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/scim-configuration/default-mapping`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Gets the connection keys for the Okta or OIDC connection strategy.
   *
   * Get connection keys
   *
   * @throws {RequiredError}
   */
  async getKeys(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/keys`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieves a scim configuration by its <code>connectionId</code>.
   *
   * Get a connection's SCIM configuration
   *
   * @throws {RequiredError}
   */
  async getScimConfiguration(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/scim-configuration`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieves all scim tokens by its connection <code>id</code>.
   *
   * Get a connection's SCIM tokens
   *
   * @throws {RequiredError}
   */
  async getScimTokens(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/scim-configuration/tokens`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieves the status of an ad/ldap connection referenced by its <code>ID</code>. <code>200 OK</code> http status code response is returned  when the connection is online, otherwise a <code>404</code> status code is returned along with an error message
   * Check connection status
   *
   * @throws {RequiredError}
   */
  async checkStatus(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/status`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Update enabled clients for a connection
   *
   * @throws {RequiredError}
   */
  async updateEnabledClients(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connections/{id}/clients`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Update details for a specific <a href="https://auth0.com/docs/authenticate/identity-providers">connection</a>, including option properties for identity provider configuration.
   *
   * <b>Note</b>: If you use the <code>options</code> parameter, the entire <code>options</code> object is overriden. To avoid partial data or other issues, ensure all parameters are present when using this option.
   * Update a connection
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connections/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a scim configuration by its <code>connectionId</code>.
   *
   * Patch a connection's SCIM configuration
   *
   * @throws {RequiredError}
   */
  async updateScimConfiguration(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connections/{id}/scim-configuration`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Creates a new connection according to the JSON object received in <code>body</code>.
   *
   * Create a connection
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connections`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Rotates the connection keys for the Okta or OIDC connection strategies.
   *
   * Rotate connection keys
   *
   * @throws {RequiredError}
   */
  async rotateKeys(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/connections/{id}/keys/rotate`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a scim configuration for a connection.
   *
   * Create a SCIM configuration
   *
   * @throws {RequiredError}
   */
  async createScimConfiguration(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connections/{id}/scim-configuration`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a scim token for a scim client.
   *
   * Create a SCIM Token
   *
   * @throws {RequiredError}
   */
  async createScimToken(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connections/{id}/scim-configuration/tokens`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/custom-domains-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI10 } = runtime_exports;
var CustomDomainsManager = class extends BaseAPI10 {
  static {
    __name(this, "CustomDomainsManager");
  }
  /**
   * Delete a custom domain and stop serving requests for it.
   * Delete custom domain configuration
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/custom-domains/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details on <a href="https://auth0.com/docs/custom-domains">custom domains</a>.
   * Get custom domains configurations
   *
   * @throws {RequiredError}
   */
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "take",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "domain_metadata_filter",
        config: {}
      },
      {
        key: "domain_name_filter",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/custom-domains`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a custom domain configuration and status.
   * Get custom domain configuration
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/custom-domains/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a custom domain.
   *
   * These are the attributes that can be updated:
   *
   * - custom_client_ip_header
   * - tls_policy
   *
   * <h5>Updating CUSTOM_CLIENT_IP_HEADER for a custom domain</h5>To update the <code>custom_client_ip_header</code> for a domain, the body to
   * send should be:
   * <pre><code>{ "custom_client_ip_header": "cf-connecting-ip" }</code></pre>
   *
   * <h5>Updating TLS_POLICY for a custom domain</h5>To update the <code>tls_policy</code> for a domain, the body to send should be:
   * <pre><code>{ "tls_policy": "recommended" }</code></pre>
   *
   *
   * TLS Policies:
   *
   * - recommended - for modern usage this includes TLS 1.2 only
   *
   *
   * Some considerations:
   *
   * - The TLS ciphers and protocols available in each TLS policy follow industry recommendations, and may be updated occasionally.
   * - The <code>compatible</code> TLS policy is no longer supported.
   *
   * Update custom domain configuration
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/custom-domains/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a new custom domain.
   *
   * Note: The custom domain will need to be verified before it will accept
   * requests.
   *
   * Optional attributes that can be updated:
   *
   * - custom_client_ip_header
   * - tls_policy
   *
   *
   * TLS Policies:
   *
   * - recommended - for modern usage this includes TLS 1.2 only
   * - compatible - compatible with older browsers this policy includes TLS 1.0, 1.1, 1.2
   *
   *
   * Some considerations:
   *
   * - The TLS ciphers and protocols available in each TLS policy follow industry recommendations, and may be updated occasionally.
   * - Do not use the <code>compatible</code> TLS policy unless you have clients that require TLS 1.0.
   *
   * Configure a new custom domain
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/custom-domains`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Run the verification process on a custom domain.
   *
   * Note: Check the <code>status</code> field to see its verification status. Once verification is complete, it may take up to 10 minutes before the custom domain can start accepting requests.
   *
   * For <code>self_managed_certs</code>, when the custom domain is verified for the first time, the response will also include the <code>cname_api_key</code> which you will need to configure your proxy. This key must be kept secret, and is used to validate the proxy requests.
   *
   * <a href="https://auth0.com/docs/custom-domains#step-2-verify-ownership">Learn more</a> about verifying custom domains that use Auth0 Managed certificates.
   * <a href="https://auth0.com/docs/custom-domains/self-managed-certificates#step-2-verify-ownership">Learn more</a> about verifying custom domains that use Self Managed certificates.
   *
   * Verify a custom domain
   *
   * @throws {RequiredError}
   */
  async verify(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/custom-domains/{id}/verify`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/device-credentials-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI11 } = runtime_exports;
var DeviceCredentialsManager = class extends BaseAPI11 {
  static {
    __name(this, "DeviceCredentialsManager");
  }
  /**
   * Delete a device credential.
   * Delete a device credential
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/device-credentials/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "user_id",
        config: {}
      },
      {
        key: "client_id",
        config: {}
      },
      {
        key: "type",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/device-credentials`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Device Credentials relate to refresh tokens and rotating refresh tokens for a given user_id.
   *
   * Note: Device Credentials APIs are designed for ad-hoc administrative use only, and paging is by default enabled for GET requests.
   * Note: When Refresh Token Rotation is enabled, the endpoint becomes eventual consistent.
   *
   * Create a device public key credential
   *
   * @throws {RequiredError}
   */
  async createPublicKey(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/device-credentials`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/email-templates-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI12 } = runtime_exports;
var EmailTemplatesManager = class extends BaseAPI12 {
  static {
    __name(this, "EmailTemplatesManager");
  }
  /**
   * Retrieve an email template by pre-defined name. These names are `verify_email`, `verify_email_by_code`, `reset_email`, `reset_email_by_code`, `welcome_email`, `blocked_account`, `stolen_credentials`, `enrollment_email`, `mfa_oob_code`, and `user_invitation`. The names `change_password`, and `password_reset` are also supported for legacy scenarios.
   * Get an email template
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["templateName"]);
    const response = await this.request({
      path: `/email-templates/{templateName}`.replace("{templateName}", encodeURIComponent(String(requestParameters.templateName))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Modify an email template.
   * Patch an email template
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["templateName"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/email-templates/{templateName}`.replace("{templateName}", encodeURIComponent(String(requestParameters.templateName))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create an email template.
   * Create an email template
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/email-templates`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update an email template.
   * Update an email template
   *
   * @throws {RequiredError}
   */
  async put(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["templateName"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/email-templates/{templateName}`.replace("{templateName}", encodeURIComponent(String(requestParameters.templateName))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/emails-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI13 } = runtime_exports;
var EmailsManager = class extends BaseAPI13 {
  static {
    __name(this, "EmailsManager");
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/email/providers">email provider</a> details. A list of fields to include or exclude may also be specified.
   *
   * Get the email provider
   *
   * @throws {RequiredError}
   */
  async get(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/emails/provider`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update an <a href="https://auth0.com/docs/email/providers">email provider</a>.
   * The <code>credentials</code> object requires different properties depending on the email provider (which is specified using the <code>name</code> property):
   * <ul><li><code>mandrill</code> requires <code>api_key</code></li><li><code>sendgrid</code> requires <code>api_key</code></li><li><code>sparkpost</code> requires <code>api_key</code>. Optionally, set <code>region</code> to <code>eu</code> to use the SparkPost service hosted in Western Europe; set to <code>null</code> to use the SparkPost service hosted in North America. <code>eu</code> or <code>null</code> are the only valid values for <code>region</code>.</li><li><code>mailgun</code> requires <code>api_key</code> and <code>domain</code>. Optionally, set <code>region</code> to <code>eu</code> to use the Mailgun service hosted in Europe; set to <code>null</code> otherwise. <code>eu</code> or <code>null</code> are the only valid values for <code>region</code>.</li><li><code>ses</code> requires <code>accessKeyId</code>, <code>secretAccessKey</code>, and <code>region</code></li><li><code>smtp</code> requires <code>smtp_host</code>, <code>smtp_port</code>, <code>smtp_user</code>, and <code>smtp_pass</code></li></ul>Depending on the type of provider it is possible to specify <code>settings</code> object with different configuration options, which will be used when sending an email:
   * <ul><li><code>smtp</code> provider, <code>settings</code> may contain <code>headers</code> object. When using AWS SES SMTP host, you may provide a name of configuration set in <code>X-SES-Configuration-Set</code> header. Value must be a string.</li><li>for <code>ses</code> provider, <code>settings</code> may contain <code>message</code> object, where you can provide a name of configuration set in <code>configuration_set_name</code> property. Value must be a string.</li></ul>
   *
   * Update the email provider
   *
   * @throws {RequiredError}
   */
  async update(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/emails/provider`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create an <a href="https://auth0.com/docs/email/providers">email provider</a>.
   * The <code>credentials</code> object requires different properties depending on the email provider (which is specified using the <code>name</code> property):
   * <ul><li><code>mandrill</code> requires <code>api_key</code></li><li><code>sendgrid</code> requires <code>api_key</code></li><li><code>sparkpost</code> requires <code>api_key</code>. Optionally, set <code>region</code> to <code>eu</code> to use the SparkPost service hosted in Western Europe; set to <code>null</code> to use the SparkPost service hosted in North America. <code>eu</code> or <code>null</code> are the only valid values for <code>region</code>.</li><li><code>mailgun</code> requires <code>api_key</code> and <code>domain</code>. Optionally, set <code>region</code> to <code>eu</code> to use the Mailgun service hosted in Europe; set to <code>null</code> otherwise. <code>eu</code> or <code>null</code> are the only valid values for <code>region</code>.</li><li><code>ses</code> requires <code>accessKeyId</code>, <code>secretAccessKey</code>, and <code>region</code></li><li><code>smtp</code> requires <code>smtp_host</code>, <code>smtp_port</code>, <code>smtp_user</code>, and <code>smtp_pass</code></li></ul>Depending on the type of provider it is possible to specify <code>settings</code> object with different configuration options, which will be used when sending an email:
   * <ul><li><code>smtp</code> provider, <code>settings</code> may contain <code>headers</code> object. When using AWS SES SMTP host, you may provide a name of configuration set in <code>X-SES-Configuration-Set</code> header. Value must be a string.</li><li>for <code>ses</code> provider, <code>settings</code> may contain <code>message</code> object, where you can provide a name of configuration set in <code>configuration_set_name</code> property. Value must be a string.</li></ul>
   *
   * Configure the email provider
   *
   * @throws {RequiredError}
   */
  async configure(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/emails/provider`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/flows-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI14 } = runtime_exports;
var FlowsManager = class extends BaseAPI14 {
  static {
    __name(this, "FlowsManager");
  }
  /**
   * Delete a flow
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/flows/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a flow execution
   *
   * @throws {RequiredError}
   */
  async deleteExecution(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["flow_id", "execution_id"]);
    const response = await this.request({
      path: `/flows/{flow_id}/executions/{execution_id}`.replace("{flow_id}", encodeURIComponent(String(requestParameters.flow_id))).replace("{execution_id}", encodeURIComponent(String(requestParameters.execution_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a Flows Vault connection
   *
   * @throws {RequiredError}
   */
  async deleteConnection(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/flows/vault/connections/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "hydrate",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      },
      {
        key: "synchronous",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/flows`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a flow
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "hydrate",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      }
    ]);
    const response = await this.request({
      path: `/flows/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAllExecutions(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["flow_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/flows/{flow_id}/executions`.replace("{flow_id}", encodeURIComponent(String(requestParameters.flow_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a flow execution
   *
   * @throws {RequiredError}
   */
  async getExecution(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["flow_id", "execution_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "hydrate",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      }
    ]);
    const response = await this.request({
      path: `/flows/{flow_id}/executions/{execution_id}`.replace("{flow_id}", encodeURIComponent(String(requestParameters.flow_id))).replace("{execution_id}", encodeURIComponent(String(requestParameters.execution_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAllConnections(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/flows/vault/connections`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a Flows Vault connection
   *
   * @throws {RequiredError}
   */
  async getConnection(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/flows/vault/connections/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a flow
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/flows/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a Flows Vault connection
   *
   * @throws {RequiredError}
   */
  async updateConnection(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/flows/vault/connections/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a flow
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/flows`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a Flows Vault connection
   *
   * @throws {RequiredError}
   */
  async createConnection(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/flows/vault/connections`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/forms-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI15 } = runtime_exports;
var FormsManager = class extends BaseAPI15 {
  static {
    __name(this, "FormsManager");
  }
  /**
   * Delete a form
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/forms/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "hydrate",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      }
    ]);
    const response = await this.request({
      path: `/forms`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a form
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "hydrate",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      }
    ]);
    const response = await this.request({
      path: `/forms/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a form
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/forms/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a form
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/forms`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/grants-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI16 } = runtime_exports;
var GrantsManager = class extends BaseAPI16 {
  static {
    __name(this, "GrantsManager");
  }
  /**
   * Delete a grant associated with your account.
   * Delete a grant by id
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/grants/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a grant associated with your account.
   * Delete a grant by user_id
   *
   * @throws {RequiredError}
   */
  async deleteByUserId(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["user_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "user_id",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/grants`,
      method: "DELETE",
      query: queryParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "user_id",
        config: {}
      },
      {
        key: "client_id",
        config: {}
      },
      {
        key: "audience",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/grants`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/guardian-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI17 } = runtime_exports;
var GuardianManager = class extends BaseAPI17 {
  static {
    __name(this, "GuardianManager");
  }
  /**
   * Delete an enrollment to allow the user to enroll with multi-factor authentication again.
   * Delete a multi-factor authentication enrollment
   *
   * @throws {RequiredError}
   */
  async deleteGuardianEnrollment(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/guardian/enrollments/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve APNS push notification configuration
   *
   * @throws {RequiredError}
   */
  async getPushNotificationProviderAPNS(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/apns`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve an enrollment (including its status and type).
   *
   * Note: Phone numbers are partially obfuscated.
   * Retrieve a multi-factor authentication enrollment
   *
   * @throws {RequiredError}
   */
  async getGuardianEnrollment(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/guardian/enrollments/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve phone enrollment and verification templates (subscription required).
   * Retrieve Enrollment and Verification Phone Templates
   *
   * @throws {RequiredError}
   */
  async getPhoneFactorTemplates(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/phone/templates`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve SMS enrollment and verification templates (subscription required).
   *
   *     A new endpoint is available to retrieve enrollment and verification templates related to phone factors (<a href='https://manage.local.dev.auth0.com/docs/api/management/v2/#!/Guardian/get_templates'>phone templates</a>). It has the same payload as this one. Please use it instead.
   * Retrieve SMS Enrollment and Verification Templates
   *
   * @throws {RequiredError}
   */
  async getSmsFactorTemplates(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/sms/templates`,
      method: "GET"
    }, initOverrides);
    return response.status === 204 ? VoidApiResponse.fromResponse(response) : JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve all <a href="https://auth0.com/docs/multifactor-authentication">multi-factor authentication</a> configurations.
   * Retrieve Factors and their Status
   *
   * @throws {RequiredError}
   */
  async getFactors(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the Enabled Phone Factors
   *
   * @throws {RequiredError}
   */
  async getPhoneFactorMessageTypes(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/phone/message-types`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve phone configuration (one of auth0|twilio|phone-message-hook)
   *
   * @throws {RequiredError}
   */
  async getPhoneFactorSelectedProvider(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/phone/selected-provider`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the <a href="https://auth0.com/docs/multifactor-authentication/twilio-configuration">Twilio phone provider configuration</a> (subscription required).
   * Retrieve Twilio phone configuration
   *
   * @throws {RequiredError}
   */
  async getPhoneFactorProviderTwilio(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/phone/providers/twilio`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve push notification provider
   *
   * @throws {RequiredError}
   */
  async getPushNotificationSelectedProvider(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/push-notification/selected-provider`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Gets the MFA policies for the tenant.
   *
   * The following policies are supported: <ul><li><code>all-applications</code> policy - will prompt with MFA for all logins.</li><li><code>confidence-score</code> policy - will prompt with MFA only for low confidence logins.</li></ul>
   * Use of the Adaptive MFA feature requires an add-on for the Enterprise plan. Please contact sales with any questions. For more information about Adaptive MFA, read our <a href="https://auth0.com/docs/mfa/adaptive-mfa">full documentation</a>.
   *
   * Get the Multi-factor Authentication policies
   *
   * @throws {RequiredError}
   */
  async getPolicies(initOverrides) {
    const response = await this.request({
      path: `/guardian/policies`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * A new endpoint is available to retrieve the configuration related to phone factors (<a href='https://manage.local.dev.auth0.com/docs/api/management/v2/#!/Guardian/get_selected_provider'>phone configuration</a>). It has the same payload as this one. Please use it instead.
   * Retrieve SMS configuration (one of auth0|twilio|phone-message-hook)
   *
   * @throws {RequiredError}
   */
  async getSmsSelectedProvider(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/sms/selected-provider`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the <a href="https://auth0.com/docs/multifactor-authentication/twilio-configuration">Twilio SMS provider configuration</a> (subscription required).
   *
   *     A new endpoint is available to retrieve the Twilio configuration related to phone factors (<a href='https://manage.local.dev.auth0.com/docs/api/management/v2/#!/Guardian/get_twilio'>phone Twilio configuration</a>). It has the same payload as this one. Please use it instead.
   * Retrieve Twilio SMS configuration
   *
   * @throws {RequiredError}
   */
  async getSmsFactorProviderTwilio(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/sms/providers/twilio`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the <a href="https://auth0.com/docs/multifactor-authentication/developer/sns-configuration">AWS SNS push notification provider configuration</a> (subscription required).
   * Retrieve AWS SNS push notification configuration
   *
   * @throws {RequiredError}
   */
  async getPushNotificationProviderSNS(initOverrides) {
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/sns`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates APNs provider configuration
   *
   * @throws {RequiredError}
   */
  async updatePushNotificationProviderAPNS(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/apns`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates FCM provider configuration
   *
   * @throws {RequiredError}
   */
  async updatePushNotificationProviderFCM(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/fcm`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Configure the <a href="https://auth0.com/docs/multifactor-authentication/developer/sns-configuration">AWS SNS push notification provider configuration</a> (subscription required).
   * Update SNS configuration for push notifications
   *
   * @throws {RequiredError}
   */
  async updatePushNotificationProviderSNS(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/sns`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Generate an email with a link to start the multi-factor authentication enrollment process (subscription required).
   * Create a multi-factor authentication enrollment ticket
   *
   * @throws {RequiredError}
   */
  async createEnrollmentTicket(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/enrollments/ticket`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates APNs provider configuration
   *
   * @throws {RequiredError}
   */
  async setPushNotificationProviderAPNS(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/apns`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Customize the messages sent to complete phone enrollment and verification (subscription required).
   * Update Enrollment and Verification Phone Templates
   *
   * @throws {RequiredError}
   */
  async setPhoneFactorTemplates(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/phone/templates`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Customize the messages sent to complete SMS enrollment and verification (subscription required).
   *
   *     A new endpoint is available to update enrollment and verification templates related to phone factors (<a href='https://manage.local.dev.auth0.com/docs/api/management/v2/#!/Guardian/put_templates'>phone templates</a>). It has the same payload as this one. Please use it instead.
   * Update SMS Enrollment and Verification Templates
   *
   * @throws {RequiredError}
   */
  async setSmsFactorTemplates(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/sms/templates`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a multi-factor authentication factor (subscription required).
   * Update a Multi-factor Authentication Factor
   *
   * @throws {RequiredError}
   */
  async updateFactor(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["name"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/{name}`.replace("{name}", encodeURIComponent(String(requestParameters.name))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates FCM provider configuration
   *
   * @throws {RequiredError}
   */
  async setPushNotificationProviderFCM(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/fcm`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update enabled phone factors for multi-factor authentication
   * Update the Enabled Phone Factors
   *
   * @throws {RequiredError}
   */
  async updatePhoneFactorMessageTypes(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/phone/message-types`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update phone configuration (one of auth0|twilio|phone-message-hook)
   *
   * @throws {RequiredError}
   */
  async updatePhoneFactorSelectedProvider(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/phone/selected-provider`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update Push Notification configuration (one of direct|sns|guardian)
   *
   * @throws {RequiredError}
   */
  async setPushNotificationSelectedProvider(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/selected-provider`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Sets the MFA policies for the tenant.
   *
   * The following policies are supported: <ul><li><code>all-applications</code> policy - will prompt with MFA for all logins.</li><li><code>confidence-score</code> policy - will prompt with MFA only for low confidence logins.</li></ul> Pass an empty array to remove all MFA policies.
   * Use of the Adaptive MFA feature requires an add-on for the Enterprise plan. Please contact sales with any questions. For more information about Adaptive MFA, read our <a href="https://auth0.com/docs/mfa/adaptive-mfa">full documentation</a>.
   *
   *
   * Set the Multi-factor Authentication policies
   *
   * @throws {RequiredError}
   */
  async updatePolicies(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/policies`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * A new endpoint is available to update the configuration related to phone factors (<a href='https://manage.local.dev.auth0.com/docs/api/management/v2/#!/Guardian/put_selected_provider'>phone configuration</a>). It has the same payload as this one. Please use it instead.
   * Update SMS configuration (one of auth0|twilio|phone-message-hook)
   *
   * @throws {RequiredError}
   */
  async setSmsSelectedProvider(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/sms/selected-provider`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Configure the <a href="https://auth0.com/docs/multifactor-authentication/twilio-configuration">Twilio SMS provider configuration</a> (subscription required).
   *
   *     A new endpoint is available to update the Twilio configuration related to phone factors (<a href='https://manage.local.dev.auth0.com/docs/api/management/v2/#!/Guardian/put_twilio'>phone Twilio configuration</a>). It has the same payload as this one. Please use it instead.
   * Update Twilio SMS configuration
   *
   * @throws {RequiredError}
   */
  async setSmsFactorProviderTwilio(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/sms/providers/twilio`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Configure the <a href="https://auth0.com/docs/multifactor-authentication/developer/sns-configuration">AWS SNS push notification provider configuration</a> (subscription required).
   * Update AWS SNS push notification configuration
   *
   * @throws {RequiredError}
   */
  async setPushNotificationProviderSNS(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/push-notification/providers/sns`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Configure the <a href="https://auth0.com/docs/multifactor-authentication/twilio-configuration">Twilio phone provider configuration</a> (subscription required).
   * Update Twilio phone configuration
   *
   * @throws {RequiredError}
   */
  async updatePhoneFactorProviderTwilio(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/guardian/factors/phone/providers/twilio`,
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/hooks-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI18 } = runtime_exports;
var HooksManager = class extends BaseAPI18 {
  static {
    __name(this, "HooksManager");
  }
  /**
   * Delete a hook.
   *
   * Delete a hook
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/hooks/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete one or more existing secrets for a given hook. Accepts an array of secret names to delete.
   * Delete hook secrets
   *
   * @throws {RequiredError}
   */
  async deleteSecrets(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/hooks/{id}/secrets`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "enabled",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "triggerId",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/hooks`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/hooks">a hook</a> by its ID. Accepts a list of fields to include in the result.
   *
   * Get a hook
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/hooks/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a hook's secrets by the ID of the hook.
   *
   * Get hook secrets
   *
   * @throws {RequiredError}
   */
  async getSecrets(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/hooks/{id}/secrets`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update an existing hook.
   *
   * Update a hook
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/hooks/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update one or more existing secrets for an existing hook. Accepts an object of key-value pairs, where the key is the name of the existing secret.
   *
   * Update hook secrets
   *
   * @throws {RequiredError}
   */
  async updateSecrets(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/hooks/{id}/secrets`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Create a new hook.
   *
   * Create a hook
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/hooks`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Add one or more secrets to an existing hook. Accepts an object of key-value pairs, where the key is the name of the secret. A hook can have a maximum of 20 secrets.
   *
   * Add hook secrets
   *
   * @throws {RequiredError}
   */
  async addSecrets(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/hooks/{id}/secrets`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/jobs-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI19 } = runtime_exports;
var JobsManager = class extends BaseAPI19 {
  static {
    __name(this, "JobsManager");
  }
  /**
   * Retrieve error details of a failed job.
   * Get job error details
   *
   * @throws {RequiredError}
   */
  async getErrors(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/jobs/{id}/errors`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return response.status === 204 ? VoidApiResponse.fromResponse(response) : JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieves a job. Useful to check its status.
   * Get a job
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/jobs/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Export all users to a file via a long-running job.
   * Create export users job
   *
   * @throws {RequiredError}
   */
  async exportUsers(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/jobs/users-exports`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Import users from a <a href="https://manage.local.dev.auth0.com/docs/users/references/bulk-import-database-schema-examples">formatted file</a> into a connection via a long-running job.
   * Create import users job
   *
   * @throws {RequiredError}
   */
  async importUsers(bodyParameters, initOverrides) {
    const formParams = new FormData();
    if (bodyParameters.users !== void 0) {
      formParams.append("users", await parseFormParam(bodyParameters.users));
    }
    if (bodyParameters.connection_id !== void 0) {
      formParams.append("connection_id", await parseFormParam(bodyParameters.connection_id));
    }
    if (bodyParameters.upsert !== void 0) {
      formParams.append("upsert", await parseFormParam(bodyParameters.upsert));
    }
    if (bodyParameters.external_id !== void 0) {
      formParams.append("external_id", await parseFormParam(bodyParameters.external_id));
    }
    if (bodyParameters.send_completion_email !== void 0) {
      formParams.append("send_completion_email", await parseFormParam(bodyParameters.send_completion_email));
    }
    const response = await this.request({
      path: `/jobs/users-imports`,
      method: "POST",
      body: formParams
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Send an email to the specified user that asks them to click a link to <a href="https://auth0.com/docs/email/custom#verification-email">verify their email address</a>.
   *
   * Note: You must have the `Status` toggle enabled for the verification email template for the email to be sent.
   * Send an email address verification email
   *
   * @throws {RequiredError}
   */
  async verifyEmail(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/jobs/verification-email`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/keys-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI20 } = runtime_exports;
var KeysManager = class extends BaseAPI20 {
  static {
    __name(this, "KeysManager");
  }
  /**
   * Delete the custom provided encryption key with the given ID and move back to using native encryption key.
   * Delete the encryption key by its key id
   *
   * @throws {RequiredError}
   */
  async deleteEncryptionKey(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["kid"]);
    const response = await this.request({
      path: `/keys/encryption/{kid}`.replace("{kid}", encodeURIComponent(String(requestParameters.kid))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details of the encryption key with the given ID.
   * Get the encryption key by its key id
   *
   * @throws {RequiredError}
   */
  async getEncryptionKey(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["kid"]);
    const response = await this.request({
      path: `/keys/encryption/{kid}`.replace("{kid}", encodeURIComponent(String(requestParameters.kid))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAllEncryptionKeys(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/keys/encryption`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get an Application Signing Key by its key id
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["kid"]);
    const response = await this.request({
      path: `/keys/signing/{kid}`.replace("{kid}", encodeURIComponent(String(requestParameters.kid))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get all Application Signing Keys
   *
   * @throws {RequiredError}
   */
  async getAll(initOverrides) {
    const response = await this.request({
      path: `/keys/signing`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create the new, pre-activated encryption key, without the key material.
   * Create the new encryption key
   *
   * @throws {RequiredError}
   */
  async createEncryptionKey(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/keys/encryption`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Import wrapped key material and activate encryption key.
   * Import the encryption key
   *
   * @throws {RequiredError}
   */
  async importEncryptionKey(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["kid"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/keys/encryption/{kid}`.replace("{kid}", encodeURIComponent(String(requestParameters.kid))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Perform rekeying operation on the key hierarchy.
   * Rekey the key hierarchy
   *
   * @throws {RequiredError}
   */
  async postEncryptionRekey(initOverrides) {
    const response = await this.request({
      path: `/keys/encryption/rekey`,
      method: "POST"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Create the public wrapping key to wrap your own encryption key material.
   * Create the public wrapping key
   *
   * @throws {RequiredError}
   */
  async createPublicWrappingKey(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["kid"]);
    const response = await this.request({
      path: `/keys/encryption/{kid}/wrapping-key`.replace("{kid}", encodeURIComponent(String(requestParameters.kid))),
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Rotate the Application Signing Key
   *
   * @throws {RequiredError}
   */
  async rotate(initOverrides) {
    const response = await this.request({
      path: `/keys/signing/rotate`,
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Revoke an Application Signing Key by its key id
   *
   * @throws {RequiredError}
   */
  async revoke(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["kid"]);
    const response = await this.request({
      path: `/keys/signing/{kid}/revoke`.replace("{kid}", encodeURIComponent(String(requestParameters.kid))),
      method: "PUT"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/log-streams-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI21 } = runtime_exports;
var LogStreamsManager = class extends BaseAPI21 {
  static {
    __name(this, "LogStreamsManager");
  }
  /**
   * Delete a log stream.
   *
   * Delete log stream
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/log-streams/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details on <a href="https://auth0.com/docs/logs/streams">log streams</a>.
   * <h5>Sample Response</h5><pre><code>[{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"awsAccountId": "string",
   * 		"awsRegion": "string",
   * 		"awsPartnerEventSource": "string"
   * 	}
   * }, {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpContentType": "string",
   * 		"httpEndpoint": "string",
   * 		"httpAuthorization": "string"
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventgrid",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"azureSubscriptionId": "string",
   * 		"azureResourceGroup": "string",
   * 		"azureRegion": "string",
   * 		"azurePartnerTopic": "string"
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * },
   * {
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }]</code></pre>
   *
   * Get log streams
   *
   * @throws {RequiredError}
   */
  async getAll(initOverrides) {
    const response = await this.request({
      path: `/log-streams`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a log stream configuration and status.
   * <h5>Sample responses</h5><h5>Amazon EventBridge Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"awsAccountId": "string",
   * 		"awsRegion": "string",
   * 		"awsPartnerEventSource": "string"
   * 	}
   * }</code></pre> <h5>HTTP Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpContentType": "string",
   * 		"httpEndpoint": "string",
   * 		"httpAuthorization": "string"
   * 	}
   * }</code></pre> <h5>Datadog Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }</code></pre> <h5>Splunk Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * }</code></pre> <h5>Sumo Logic Log Stream</h5><pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"status": "active|paused|suspended",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * }</code></pre> <h5>Status</h5> The <code>status</code> of a log stream maybe any of the following:
   * 1. <code>active</code> - Stream is currently enabled.
   * 2. <code>paused</code> - Stream is currently user disabled and will not attempt log delivery.
   * 3. <code>suspended</code> - Stream is currently disabled because of errors and will not attempt log delivery.
   *
   * Get log stream by ID
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/log-streams/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a log stream.
   * <h4>Examples of how to use the PATCH endpoint.</h4> The following fields may be updated in a PATCH operation: <ul><li>name</li><li>status</li><li>sink</li></ul> Note: For log streams of type <code>eventbridge</code> and <code>eventgrid</code>, updating the <code>sink</code> is not permitted.
   * <h5>Update the status of a log stream</h5><pre><code>{
   * 	"status": "active|paused"
   * }</code></pre>
   * <h5>Update the name of a log stream</h5><pre><code>{
   * 	"name": "string"
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>http</code></h5><pre><code>{
   *   "sink": {
   *     "httpEndpoint": "string",
   *     "httpContentType": "string",
   *     "httpContentFormat": "JSONARRAY|JSONLINES",
   *     "httpAuthorization": "string"
   *   }
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>datadog</code></h5><pre><code>{
   *   "sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   *   }
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>splunk</code></h5><pre><code>{
   *   "sink": {
   *     "splunkDomain": "string",
   *     "splunkToken": "string",
   *     "splunkPort": "string",
   *     "splunkSecure": "boolean"
   *   }
   * }</code></pre>
   * <h5>Update the sink properties of a stream of type <code>sumo</code></h5><pre><code>{
   *   "sink": {
   *     "sumoSourceAddress": "string"
   *   }
   * }</code></pre>
   * Update a log stream
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/log-streams/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a log stream.
   * <h5>Log Stream Types</h5> The <code>type</code> of log stream being created determines the properties required in the <code>sink</code> payload.
   * <h5>HTTP Stream</h5> For an <code>http</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "http",
   * 	"sink": {
   * 		"httpEndpoint": "string",
   * 		"httpContentType": "string",
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpAuthorization": "string"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active",
   * 	"sink": {
   * 		"httpEndpoint": "string",
   * 		"httpContentType": "string",
   * 		"httpContentFormat": "JSONLINES|JSONARRAY",
   * 		"httpAuthorization": "string"
   * 	}
   * }</code></pre>
   * <h5>Amazon EventBridge Stream</h5> For an <code>eventbridge</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"sink": {
   * 		"awsRegion": "string",
   * 		"awsAccountId": "string"
   * 	}
   * }</code></pre>
   * The response will include an additional field <code>awsPartnerEventSource</code> in the <code>sink</code>: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "eventbridge",
   * 	"status": "active",
   * 	"sink": {
   * 		"awsAccountId": "string",
   * 		"awsRegion": "string",
   * 		"awsPartnerEventSource": "string"
   * 	}
   * }</code></pre>
   * <h5>Azure Event Grid Stream</h5> For an <code>Azure Event Grid</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "eventgrid",
   * 	"sink": {
   * 		"azureSubscriptionId": "string",
   * 		"azureResourceGroup": "string",
   * 		"azureRegion": "string"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "http",
   * 	"status": "active",
   * 	"sink": {
   * 		"azureSubscriptionId": "string",
   * 		"azureResourceGroup": "string",
   * 		"azureRegion": "string",
   * 		"azurePartnerTopic": "string"
   * 	}
   * }</code></pre>
   * <h5>Datadog Stream</h5> For a <code>Datadog</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "datadog",
   * 	"status": "active",
   * 	"sink": {
   * 		"datadogRegion": "string",
   * 		"datadogApiKey": "string"
   * 	}
   * }</code></pre>
   * <h5>Splunk Stream</h5> For a <code>Splunk</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "splunk",
   * 	"status": "active",
   * 	"sink": {
   * 		"splunkDomain": "string",
   * 		"splunkToken": "string",
   * 		"splunkPort": "string",
   * 		"splunkSecure": "boolean"
   * 	}
   * }</code></pre>
   * <h5>Sumo Logic Stream</h5> For a <code>Sumo Logic</code> Stream, the <code>sink</code> properties are listed in the payload below
   * Request: <pre><code>{
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * }</code></pre>
   * Response: <pre><code>{
   * 	"id": "string",
   * 	"name": "string",
   * 	"type": "sumo",
   * 	"status": "active",
   * 	"sink": {
   * 		"sumoSourceAddress": "string",
   * 	}
   * }</code></pre>
   *
   * Create a log stream
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/log-streams`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/logs-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI22 } = runtime_exports;
var LogsManager = class extends BaseAPI22 {
  static {
    __name(this, "LogsManager");
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "sort",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "q",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/logs`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve an individual log event.
   * Get a log event by id
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/logs/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/network-acls-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI23 } = runtime_exports;
var NetworkAclsManager = class extends BaseAPI23 {
  static {
    __name(this, "NetworkAclsManager");
  }
  /**
   * Delete existing access control list for your client.
   * Delete Access Control List
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/network-acls/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/network-acls`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get a specific access control list entry for your client.
   * Get a specific access control list entry for a tenant
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/network-acls/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update existing access control list for your client.
   * Partial Update for an Access Control List
   *
   * @throws {RequiredError}
   */
  async patch(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/network-acls/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a new access control list for your client.
   * Create Access Control List
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/network-acls`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update existing access control list for your client.
   * Update Access Control List
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/network-acls/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/organizations-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI24 } = runtime_exports;
var OrganizationsManager = class extends BaseAPI24 {
  static {
    __name(this, "OrganizationsManager");
  }
  /**
   * Remove a client grant from an organization
   *
   * @throws {RequiredError}
   */
  async deleteClientGrantsByGrantId(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "grant_id"]);
    const response = await this.request({
      path: `/organizations/{id}/client-grants/{grant_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{grant_id}", encodeURIComponent(String(requestParameters.grant_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete connections from an organization
   *
   * @throws {RequiredError}
   */
  async deleteEnabledConnection(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "connectionId"]);
    const response = await this.request({
      path: `/organizations/{id}/enabled_connections/{connectionId}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{connectionId}", encodeURIComponent(String(requestParameters.connectionId))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete an invitation to organization
   *
   * @throws {RequiredError}
   */
  async deleteInvitation(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "invitation_id"]);
    const response = await this.request({
      path: `/organizations/{id}/invitations/{invitation_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{invitation_id}", encodeURIComponent(String(requestParameters.invitation_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete members from an organization
   *
   * @throws {RequiredError}
   */
  async deleteMembers(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/members`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Remove one or more roles from a given user in the context of the provided organization
   *
   * @throws {RequiredError}
   */
  async deleteMemberRoles(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "user_id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/members/{user_id}/roles`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "DELETE",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a specific organization
   *
   * Delete organization
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/organizations/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getEnabledConnections(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations/{id}/enabled_connections`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get an enabled connection for an organization
   *
   * @throws {RequiredError}
   */
  async getEnabledConnection(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "connectionId"]);
    const response = await this.request({
      path: `/organizations/{id}/enabled_connections/{connectionId}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{connectionId}", encodeURIComponent(String(requestParameters.connectionId))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getInvitations(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "sort",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations/{id}/invitations`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get an invitation to organization
   *
   * @throws {RequiredError}
   */
  async getInvitation(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "invitation_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations/{id}/invitations/{invitation_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{invitation_id}", encodeURIComponent(String(requestParameters.invitation_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getMembers(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations/{id}/members`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details about a single Organization specified by name.
   *
   * Get organization by name
   *
   * @throws {RequiredError}
   */
  async getByName(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["name"]);
    const response = await this.request({
      path: `/organizations/name/{name}`.replace("{name}", encodeURIComponent(String(requestParameters.name))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getOrganizationClientGrants(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "audience",
        config: {}
      },
      {
        key: "client_id",
        config: {}
      },
      {
        key: "grant_ids",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations/{id}/client-grants`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getMemberRoles(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "user_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations/{id}/members/{user_id}/roles`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      },
      {
        key: "sort",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/organizations`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details about a single Organization specified by ID.
   *
   * Get organization
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/organizations/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Modify an enabled_connection belonging to an Organization.
   *
   * Modify an Organizations Connection
   *
   * @throws {RequiredError}
   */
  async updateEnabledConnection(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "connectionId"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/enabled_connections/{connectionId}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{connectionId}", encodeURIComponent(String(requestParameters.connectionId))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update the details of a specific <a href="https://auth0.com/docs/manage-users/organizations/configure-organizations/create-organizations">Organization</a>, such as name and display name, branding options, and metadata.
   *
   * Modify an Organization
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Add connections to an organization
   *
   * @throws {RequiredError}
   */
  async addEnabledConnection(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/enabled_connections`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create invitations to organization
   *
   * @throws {RequiredError}
   */
  async createInvitation(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/invitations`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Add members to an organization
   *
   * @throws {RequiredError}
   */
  async addMembers(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/members`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Associate a client grant with an organization
   *
   * @throws {RequiredError}
   */
  async postOrganizationClientGrants(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/client-grants`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Assign one or more roles to a given user that will be applied in the context of the provided organization
   *
   * @throws {RequiredError}
   */
  async addMemberRoles(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "user_id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations/{id}/members/{user_id}/roles`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Create a new Organization within your tenant.  To learn more about Organization settings, behavior, and configuration options, review <a href="https://auth0.com/docs/manage-users/organizations/create-first-organization">Create Your First Organization</a>.
   *
   * Create an Organization
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/organizations`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/prompts-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI25 } = runtime_exports;
var PromptsManager = class extends BaseAPI25 {
  static {
    __name(this, "PromptsManager");
  }
  async getAllRenderingSettings(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "prompt",
        config: {}
      },
      {
        key: "screen",
        config: {}
      },
      {
        key: "rendering_mode",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/prompts/rendering`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve custom text for a specific prompt and language.
   * Get custom text for a prompt
   *
   * @throws {RequiredError}
   */
  async getCustomTextByLanguage(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["prompt", "language"]);
    const response = await this.request({
      path: `/prompts/{prompt}/custom-text/{language}`.replace("{prompt}", encodeURIComponent(String(requestParameters.prompt))).replace("{language}", encodeURIComponent(String(requestParameters.language))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get template partials for a prompt
   * Get partials for a prompt
   *
   * @throws {RequiredError}
   */
  async getPartials(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["prompt"]);
    const response = await this.request({
      path: `/prompts/{prompt}/partials`.replace("{prompt}", encodeURIComponent(String(requestParameters.prompt))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details of the Universal Login configuration of your tenant. This includes the <a href="https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first">Identifier First Authentication</a> and <a href="https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa">WebAuthn with Device Biometrics for MFA</a> features.
   * Get prompt settings
   *
   * @throws {RequiredError}
   */
  async get(initOverrides) {
    const response = await this.request({
      path: `/prompts`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Get render settings for a screen.
   * Get render settings for a screen
   *
   * @throws {RequiredError}
   */
  async getRendering(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["prompt", "screen"]);
    const response = await this.request({
      path: `/prompts/{prompt}/screen/{screen}/rendering`.replace("{prompt}", encodeURIComponent(String(requestParameters.prompt))).replace("{screen}", encodeURIComponent(String(requestParameters.screen))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update the Universal Login configuration of your tenant. This includes the <a href="https://auth0.com/docs/authenticate/login/auth0-universal-login/identifier-first">Identifier First Authentication</a> and <a href="https://auth0.com/docs/secure/multi-factor-authentication/fido-authentication-with-webauthn/configure-webauthn-device-biometrics-for-mfa">WebAuthn with Device Biometrics for MFA</a> features.
   * Update prompt settings
   *
   * @throws {RequiredError}
   */
  async update(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/prompts`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Learn more about <a href='https://auth0.com/docs/customize/login-pages/advanced-customizations/getting-started/configure-acul-screens'>configuring render settings</a> for advanced customization.
   *
   * <p>
   *   Example <code>head_tags</code> array. See our <a href='https://auth0.com/docs/customize/login-pages/advanced-customizations/getting-started/configure-acul-screens'>documentation</a> on using Liquid variables within head tags.
   * </p>
   * <pre>{
   *   "head_tags": [
   *     {
   *       "tag": "script",
   *       "attributes": {
   *         "defer": true,
   *         "src": "URL_TO_ASSET",
   *         "async": true,
   *         "integrity": [
   *           "ASSET_SHA"
   *         ]
   *       }
   *     },
   *     {
   *       "tag": "link",
   *       "attributes": {
   *         "href": "URL_TO_ASSET",
   *         "rel": "stylesheet"
   *       }
   *     }
   *   ]
   * }
   * </pre>
   *
   * Update render settings for a screen
   *
   * @throws {RequiredError}
   */
  async updateRendering(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["prompt", "screen"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/prompts/{prompt}/screen/{screen}/rendering`.replace("{prompt}", encodeURIComponent(String(requestParameters.prompt))).replace("{screen}", encodeURIComponent(String(requestParameters.screen))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Set custom text for a specific prompt. Existing texts will be overwritten.
   * Set custom text for a specific prompt
   *
   * @throws {RequiredError}
   */
  async updateCustomTextByLanguage(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["prompt", "language"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/prompts/{prompt}/custom-text/{language}`.replace("{prompt}", encodeURIComponent(String(requestParameters.prompt))).replace("{language}", encodeURIComponent(String(requestParameters.language))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Set template partials for a prompt
   * Set partials for a prompt
   *
   * @throws {RequiredError}
   */
  async updatePartials(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["prompt"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/prompts/{prompt}/partials`.replace("{prompt}", encodeURIComponent(String(requestParameters.prompt))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/refresh-tokens-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI26 } = runtime_exports;
var RefreshTokensManager = class extends BaseAPI26 {
  static {
    __name(this, "RefreshTokensManager");
  }
  /**
   * Delete a refresh token by its ID.
   * Delete a refresh tokens
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/refresh-tokens/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve refresh token information.
   * Get a refresh token
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/refresh-tokens/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/resource-servers-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI27 } = runtime_exports;
var ResourceServersManager = class extends BaseAPI27 {
  static {
    __name(this, "ResourceServersManager");
  }
  /**
   * Delete an existing API (also known as a resource server).
   * Delete a resource server
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/resource-servers/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "identifiers",
        config: {
          isArray: true,
          isCollectionFormatMulti: true
        }
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/resource-servers`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve an <a href="https://auth0.com/docs/apis">API</a> (also known as resource server).
   * Get a resource server
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/resource-servers/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update an existing API (also known as a resource server).
   * Update a resource server
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/resource-servers/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a new API (also known as a resource server).
   * Create a resource server
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/resource-servers`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/risk-assessments-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI28 } = runtime_exports;
var RiskAssessmentsManager = class extends BaseAPI28 {
  static {
    __name(this, "RiskAssessmentsManager");
  }
  /**
   * Gets the risk assessment settings for the new device assessor
   *
   * @throws {RequiredError}
   */
  async getNewDeviceSettings(initOverrides) {
    const response = await this.request({
      path: `/risk-assessments/settings/new-device`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Gets the tenant settings for risk assessments
   * Get risk assessment settings
   *
   * @throws {RequiredError}
   */
  async getSettings(initOverrides) {
    const response = await this.request({
      path: `/risk-assessments/settings`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates the risk assessment settings for the new device assessor
   *
   * @throws {RequiredError}
   */
  async updateNewDeviceSettings(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/risk-assessments/settings/new-device`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates the tenant settings for risk assessments
   * Updates risk assessment settings
   *
   * @throws {RequiredError}
   */
  async updateSettings(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/risk-assessments/settings`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/roles-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI29 } = runtime_exports;
var RolesManager = class extends BaseAPI29 {
  static {
    __name(this, "RolesManager");
  }
  /**
   * Remove permissions associated with a role.
   *
   * Remove permissions from a role
   *
   * @throws {RequiredError}
   */
  async deletePermissions(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/roles/{id}/permissions`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a role.
   *
   * Delete a role
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/roles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getPermissions(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/roles/{id}/permissions`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getUsers(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/roles/{id}/users`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "name_filter",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/roles`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a role.
   *
   * Get a role
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/roles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a role.
   *
   * Update a role
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/roles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Associate permissions with a role.
   *
   * Associate permissions with a role
   *
   * @throws {RequiredError}
   */
  async addPermissions(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/roles/{id}/permissions`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Assign users to a role.
   * Assign users to a role
   *
   * @throws {RequiredError}
   */
  async assignUsers(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/roles/{id}/users`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Create a new role.
   *
   * Create a role
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/roles`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/rules-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI30 } = runtime_exports;
var RulesManager = class extends BaseAPI30 {
  static {
    __name(this, "RulesManager");
  }
  /**
   * Delete a rule.
   *
   * Delete a rule
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/rules/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "enabled",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/rules`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve <a href="https://auth0.com/docs/rules">rule</a> details. Accepts a list of fields to include or exclude in the result.
   *
   * Get a rule
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/rules/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update an existing rule.
   *
   * Update a rule
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/rules/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a <a href="https://auth0.com/docs/rules#create-a-new-rule-using-the-management-api">new rule</a>.
   *
   * Note: Changing a rule's stage of execution from the default <code>login_success</code> can change the rule's function signature to have user omitted.
   *
   * Create a rule
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/rules`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/rules-configs-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI31 } = runtime_exports;
var RulesConfigsManager = class extends BaseAPI31 {
  static {
    __name(this, "RulesConfigsManager");
  }
  /**
   * Delete a rules config variable identified by its key.
   * Delete rules config for a given key
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["key"]);
    const response = await this.request({
      path: `/rules-configs/{key}`.replace("{key}", encodeURIComponent(String(requestParameters.key))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve rules config variable keys.
   *
   *     Note: For security, config variable values cannot be retrieved outside rule execution.
   * Retrieve config variable keys for rules (get_rules-configs)
   *
   * @throws {RequiredError}
   */
  async getAll(initOverrides) {
    const response = await this.request({
      path: `/rules-configs`,
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Sets a rules config variable.
   * Set rules config for a given key
   *
   * @throws {RequiredError}
   */
  async set(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["key"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/rules-configs/{key}`.replace("{key}", encodeURIComponent(String(requestParameters.key))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/self-service-profiles-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI32 } = runtime_exports;
var SelfServiceProfilesManager = class extends BaseAPI32 {
  static {
    __name(this, "SelfServiceProfilesManager");
  }
  /**
   * Deletes a self-service profile by Id.
   * Delete a self-service profile by Id
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/self-service-profiles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieves text customizations for a given self-service profile, language and Self Service SSO Flow page.
   *
   * Get custom text for a self-service profile
   *
   * @throws {RequiredError}
   */
  async getCustomText(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "language", "page"]);
    const response = await this.request({
      path: `/self-service-profiles/{id}/custom-text/{language}/{page}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{language}", encodeURIComponent(String(requestParameters.language))).replace("{page}", encodeURIComponent(String(requestParameters.page))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/self-service-profiles`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieves a self-service profile by Id.
   * Get a self-service profile by Id
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/self-service-profiles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates a self-service profile.
   * Update a self-service profile
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/self-service-profiles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Revokes an SSO access ticket and invalidates associated sessions. The ticket will no longer be accepted to initiate a Self-Service SSO session. If any users have already started a session through this ticket, their session will be terminated. Clients should expect a `202 Accepted` response upon successful processing, indicating that the request has been acknowledged and that the revocation is underway but may not be fully completed at the time of response. If the specified ticket does not exist, a `202 Accepted` response is also returned, signaling that no further action is required.
   * Clients should treat these `202` responses as an acknowledgment that the request has been accepted and is in progress, even if the ticket was not found.
   *
   * Revoke an SSO access ticket
   *
   * @throws {RequiredError}
   */
  async revokeSsoTicket(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["profileId", "id"]);
    const response = await this.request({
      path: `/self-service-profiles/{profileId}/sso-ticket/{id}/revoke`.replace("{profileId}", encodeURIComponent(String(requestParameters.profileId))).replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST"
    }, initOverrides);
    return TextApiResponse.fromResponse(response);
  }
  /**
   * Creates a self-service profile. Currently only one profile can be created per tenant.
   * Create a self-service profile
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/self-service-profiles`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Creates an SSO access ticket to initiate the Self Service SSO Flow using a self-service profile.
   *
   * Create an SSO access ticket to initiate the Self Service SSO Flow
   *
   * @throws {RequiredError}
   */
  async createSsoTicket(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/self-service-profiles/{id}/sso-ticket`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates text customizations for a given self-service profile, language and Self Service SSO Flow page.
   *
   * Set custom text for a self-service profile
   *
   * @throws {RequiredError}
   */
  async updateCustomText(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "language", "page"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/self-service-profiles/{id}/custom-text/{language}/{page}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{language}", encodeURIComponent(String(requestParameters.language))).replace("{page}", encodeURIComponent(String(requestParameters.page))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/sessions-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI33 } = runtime_exports;
var SessionsManager = class extends BaseAPI33 {
  static {
    __name(this, "SessionsManager");
  }
  /**
   * Delete a session by ID.
   * Delete session
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/sessions/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve session information.
   * Get session
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/sessions/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/stats-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI34 } = runtime_exports;
var StatsManager = class extends BaseAPI34 {
  static {
    __name(this, "StatsManager");
  }
  /**
   * Retrieve the number of active users that logged in during the last 30 days.
   * Get active users count
   *
   * @throws {RequiredError}
   */
  async getActiveUsersCount(initOverrides) {
    const response = await this.request({
      path: `/stats/active-users`,
      method: "GET"
    }, initOverrides);
    return TextApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the number of logins, signups and breached-password detections (subscription required) that occurred each day within a specified date range.
   * Get daily stats
   *
   * @throws {RequiredError}
   */
  async getDaily(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "from",
        config: {}
      },
      {
        key: "to",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/stats/daily`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/tenants-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI35 } = runtime_exports;
var TenantsManager = class extends BaseAPI35 {
  static {
    __name(this, "TenantsManager");
  }
  /**
   * Update settings for a tenant.
   * Update tenant settings
   *
   * @throws {RequiredError}
   */
  async updateSettings(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/tenants/settings`,
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve tenant settings. A list of fields to include or exclude may also be specified.
   * Get tenant settings
   *
   * @throws {RequiredError}
   */
  async getSettings(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/tenants/settings`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/tickets-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI36 } = runtime_exports;
var TicketsManager = class extends BaseAPI36 {
  static {
    __name(this, "TicketsManager");
  }
  /**
   * Create a <a href="https://auth0.com/docs/email/custom#verification-email">ticket to verify a user's email address</a>.
   * Create an email verification ticket
   *
   * @throws {RequiredError}
   */
  async verifyEmail(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/tickets/email-verification`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Create a <a href="https://auth0.com/docs/connections/database/password-change">password change ticket</a> for a user.
   * Create a password change ticket
   *
   * @throws {RequiredError}
   */
  async changePassword(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/tickets/password-change`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/token-exchange-profiles-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI37 } = runtime_exports;
var TokenExchangeProfilesManager = class extends BaseAPI37 {
  static {
    __name(this, "TokenExchangeProfilesManager");
  }
  /**
   * Delete a Token Exchange Profile within your tenant.
   * Delete a token exchange profile
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/token-exchange-profiles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a list of all Token Exchange Profiles available in your tenant.
   *
   * This endpoint supports Checkpoint pagination. To search by checkpoint, use the following parameters:
   * <ul>
   * <li><code>from</code>: Optional id from which to start selection.</li>
   * <li><code>take</code>: The total amount of entries to retrieve when using the from parameter. Defaults to 50.</li>
   * </ul>
   *
   * <b>Note</b>: The first time you call this endpoint using checkpoint pagination, omit the <code>from</code> parameter. If there are more results, a <code>next</code> value is included in the response. You can use this for subsequent API calls. When <code>next</code> is no longer included in the response, no pages are remaining.
   * Get token exchange profiles
   *
   * @throws {RequiredError}
   */
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/token-exchange-profiles`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details about a single Token Exchange Profile specified by ID.
   *
   * Get a token exchange profile
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/token-exchange-profiles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a Token Exchange Profile within your tenant.
   *
   * Update an existing token exchange profile
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/token-exchange-profiles/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Create a new Token Exchange Profile within your tenant.
   *
   * Create a token exchange profile
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/token-exchange-profiles`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/user-blocks-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI38 } = runtime_exports;
var UserBlocksManager = class extends BaseAPI38 {
  static {
    __name(this, "UserBlocksManager");
  }
  /**
   * Unblock a user blocked due to an excessive amount of incorrectly-provided credentials.
   *
   * Unblock by identifier
   *
   * @throws {RequiredError}
   */
  async deleteAll(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["identifier"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "identifier",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/user-blocks`,
      method: "DELETE",
      query: queryParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Unblock a user that was blocked due to an excessive amount of incorrectly provided credentials.
   *
   * Note: This endpoint does not unblock users that were <a href="https://auth0.com/docs/user-profile#block-and-unblock-a-user">blocked by admins</a>.
   *
   * Unblock a user
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/user-blocks/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a list of blocked IP addresses for a given identifier (e.g., username, phone number or email).
   *
   * Get blocks by identifier
   *
   * @throws {RequiredError}
   */
  async getAll(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["identifier"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "identifier",
        config: {}
      },
      {
        key: "consider_brute_force_enablement",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/user-blocks`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve a list of blocked IP addresses for the login identifiers (email, username, phone number, etc) associated with the specified user.
   *
   *
   * Get a user's blocks
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "consider_brute_force_enablement",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/user-blocks/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/users-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI39 } = runtime_exports;
var UsersManager = class extends BaseAPI39 {
  static {
    __name(this, "UsersManager");
  }
  /**
   * Deletes all authentication methods for the given user
   *
   * @throws {RequiredError}
   */
  async deleteAuthenticationMethods(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}/authentication-methods`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Deletes an authentication method by ID
   *
   * @throws {RequiredError}
   */
  async deleteAuthenticationMethod(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "authentication_method_id"]);
    const response = await this.request({
      path: `/users/{id}/authentication-methods/{authentication_method_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{authentication_method_id}", encodeURIComponent(String(requestParameters.authentication_method_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete All Authenticators
   *
   * @throws {RequiredError}
   */
  async deleteAllAuthenticators(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}/authenticators`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Deletes a tokenset for federated connections by id.
   *
   * @throws {RequiredError}
   */
  async deleteTokenset(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "tokenset_id"]);
    const response = await this.request({
      path: `/users/{id}/federated-connections-tokensets/{tokenset_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{tokenset_id}", encodeURIComponent(String(requestParameters.tokenset_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a <a href="https://auth0.com/docs/multifactor-authentication">multifactor</a> configuration for a user. This forces the user to re-configure the multi-factor provider.
   * Delete a User's Multi-factor Provider
   *
   * @throws {RequiredError}
   */
  async deleteMultifactorProvider(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "provider"]);
    const response = await this.request({
      path: `/users/{id}/multifactor/{provider}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{provider}", encodeURIComponent(String(requestParameters.provider))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Remove permissions from a user.
   *
   * Remove Permissions from a User
   *
   * @throws {RequiredError}
   */
  async deletePermissions(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/permissions`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete all refresh tokens for a user.
   * Delete refresh tokens for a user
   *
   * @throws {RequiredError}
   */
  async deleteRefreshTokens(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["user_id"]);
    const response = await this.request({
      path: `/users/{user_id}/refresh-tokens`.replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete all sessions for a user.
   * Delete sessions for user
   *
   * @throws {RequiredError}
   */
  async deleteSessions(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["user_id"]);
    const response = await this.request({
      path: `/users/{user_id}/sessions`.replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Unlink an identity from the target user making it a separate user account again.
   * Unlink a User Identity
   *
   * @throws {RequiredError}
   */
  async unlink(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "provider", "user_id"]);
    const response = await this.request({
      path: `/users/{id}/identities/{provider}/{user_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{provider}", encodeURIComponent(String(requestParameters.provider))).replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "DELETE"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Remove roles from a user.
   * Removes roles from a user
   *
   * @throws {RequiredError}
   */
  async deleteRoles(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/roles`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Delete a user.
   * Delete a User
   *
   * @throws {RequiredError}
   */
  async delete(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "DELETE"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  async getAuthenticationMethods(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{id}/authentication-methods`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Gets an authentication method by ID.
   *
   * @throws {RequiredError}
   */
  async getAuthenticationMethod(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "authentication_method_id"]);
    const response = await this.request({
      path: `/users/{id}/authentication-methods/{authentication_method_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{authentication_method_id}", encodeURIComponent(String(requestParameters.authentication_method_id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve the first confirmed <a href="https://auth0.com/docs/multifactor-authentication/guardian">Guardian</a> enrollment for a user.
   * Get the First Confirmed Multi-factor Authentication Enrollment
   *
   * @throws {RequiredError}
   */
  async getEnrollments(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}/enrollments`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * List active federated connections tokensets for a provided user
   * Get tokensets for a user
   *
   * @throws {RequiredError}
   */
  async getAllTokensets(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}/federated-connections-tokensets`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getLogs(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "sort",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{id}/logs`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getPermissions(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{id}/permissions`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details for a user's refresh tokens.
   * Get refresh tokens for a user
   *
   * @throws {RequiredError}
   */
  async getRefreshTokens(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["user_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{user_id}/refresh-tokens`.replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve details for a user's sessions.
   * Get sessions for user
   *
   * @throws {RequiredError}
   */
  async getSessions(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["user_id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "from",
        config: {}
      },
      {
        key: "take",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{user_id}/sessions`.replace("{user_id}", encodeURIComponent(String(requestParameters.user_id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getUserOrganizations(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{id}/organizations`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getRoles(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "per_page",
        config: {}
      },
      {
        key: "page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{id}/roles`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  async getAll(requestParameters = {}, initOverrides) {
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "page",
        config: {}
      },
      {
        key: "per_page",
        config: {}
      },
      {
        key: "include_totals",
        config: {}
      },
      {
        key: "sort",
        config: {}
      },
      {
        key: "connection",
        config: {}
      },
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "q",
        config: {}
      },
      {
        key: "search_engine",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Retrieve user details. A list of fields to include or exclude may also be specified.
   * Get a User
   *
   * @throws {RequiredError}
   */
  async get(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates an authentication method.
   *
   * @throws {RequiredError}
   */
  async updateAuthenticationMethod(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id", "authentication_method_id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/authentication-methods/{authentication_method_id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))).replace("{authentication_method_id}", encodeURIComponent(String(requestParameters.authentication_method_id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Update a user.
   *
   * These are the attributes that can be updated at the root level:
   *
   * <ul>
   *     <li>app_metadata</li>
   *     <li>blocked</li>
   *     <li>email</li>
   *     <li>email_verified</li>
   *     <li>family_name</li>
   *     <li>given_name</li>
   *     <li>name</li>
   *     <li>nickname</li>
   *     <li>password</li>
   *     <li>phone_number</li>
   *     <li>phone_verified</li>
   *     <li>picture</li>
   *     <li>username</li>
   *     <li>user_metadata</li>
   *     <li>verify_email</li>
   * </ul>
   *
   * Some considerations:
   * <ul>
   *     <li>The properties of the new object will replace the old ones.</li>
   *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
   *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
   *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
   *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
   *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the "Unblock a user" endpoint from the "User Blocks" API to change the user's state.</li>
   * </ul>
   *
   * <h5>Updating a field (non-metadata property)</h5>
   * To mark the email address of a user as verified, the body to send should be:
   * <pre><code>{ "email_verified": true }</code></pre>
   *
   * <h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
   * <pre><code>{ "user_metadata" : { "profileCode": 1479 } }</code></pre>
   *
   * To add the field <code>addresses</code> the body to send should be:
   * <pre><code>{ "user_metadata" : { "addresses": {"work_address": "100 Industrial Way"} }}</code></pre>
   *
   * The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
   *   "user_metadata": {
   *     "profileCode": 1479,
   *     "addresses": { "work_address": "100 Industrial Way" }
   *   }
   * }</code></pre>
   *
   * <h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>"home_address": "742 Evergreen Terrace"</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
   * <pre><code>{
   *   "user_metadata": {
   *     "addresses": {
   *       "work_address": "100 Industrial Way",
   *       "home_address": "742 Evergreen Terrace"
   *     }
   *   }
   * }</code></pre>
   *
   * The modified object ends up with the following <code>user_metadata</code> property:
   * <pre><code>{
   *   "user_metadata": {
   *     "profileCode": 1479,
   *     "addresses": {
   *       "work_address": "100 Industrial Way",
   *       "home_address": "742 Evergreen Terrace"
   *     }
   *   }
   * }</code></pre>
   *
   * Update a User
   *
   * @throws {RequiredError}
   */
  async update(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PATCH",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Creates an authentication method for a given user. Authentication methods created via this endpoint will be auto confirmed and should already have verification completed.
   *
   * @throws {RequiredError}
   */
  async createAuthenticationMethod(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/authentication-methods`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Clear risk assessment assessors for a specific user
   *
   * @throws {RequiredError}
   */
  async clearRiskAssessors(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/risk-assessments/clear`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Link two user accounts together forming a primary and secondary relationship. On successful linking, the endpoint returns the new array of the primary account identities.
   *
   * Note: There are two ways of invoking the endpoint:
   *
   * <ul>
   *   <li>With the authenticated primary account's JWT in the Authorization header, which has the <code>update:current_user_identities</code> scope:
   *     <pre>
   *       POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
   *       Authorization: "Bearer PRIMARY_ACCOUNT_JWT"
   *       {
   *         "link_with": "SECONDARY_ACCOUNT_JWT"
   *       }
   *     </pre>
   *     In this case, only the <code>link_with</code> param is required in the body, which also contains the JWT obtained upon the secondary account's authentication.
   *   </li>
   *   <li>With a token generated by the API V2 containing the <code>update:users</code> scope:
   *     <pre>
   *     POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
   *     Authorization: "Bearer YOUR_API_V2_TOKEN"
   *     {
   *       "provider": "SECONDARY_ACCOUNT_PROVIDER",
   *       "connection_id": "SECONDARY_ACCOUNT_CONNECTION_ID(OPTIONAL)",
   *       "user_id": "SECONDARY_ACCOUNT_USER_ID"
   *     }
   *     </pre>
   *     In this case you need to send <code>provider</code> and <code>user_id</code> in the body. Optionally you can also send the <code>connection_id</code> param which is suitable for identifying a particular database connection for the 'auth0' provider.
   *   </li>
   * </ul>
   * Link a User Account
   *
   * @throws {RequiredError}
   */
  async link(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/identities`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Invalidate all remembered browsers across all <a href="https://auth0.com/docs/multifactor-authentication">authentication factors</a> for a user.
   * Invalidate All Remembered Browsers for Multi-factor Authentication
   *
   * @throws {RequiredError}
   */
  async invalidateRememberBrowser(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}/multifactor/actions/invalidate-remember-browser`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST"
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Assign permissions to a user.
   * Assign Permissions to a User
   *
   * @throws {RequiredError}
   */
  async assignPermissions(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/permissions`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Remove the current <a href="https://auth0.com/docs/multifactor-authentication/guardian">multi-factor authentication</a> recovery code and generate a new one.
   * Generate New Multi-factor Authentication Recovery Code
   *
   * @throws {RequiredError}
   */
  async regenerateRecoveryCode(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const response = await this.request({
      path: `/users/{id}/recovery-code-regeneration`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST"
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Associate roles with a user.
   * Assign roles to a user
   *
   * @throws {RequiredError}
   */
  async assignRoles(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/roles`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
   *
   * Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.
   * Create a User
   *
   * @throws {RequiredError}
   */
  async create(bodyParameters, initOverrides) {
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users`,
      method: "POST",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Updates all authentication methods by replacing them with the given ones.
   *
   * @throws {RequiredError}
   */
  async updateAuthenticationMethods(requestParameters, bodyParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["id"]);
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/users/{id}/authentication-methods`.replace("{id}", encodeURIComponent(String(requestParameters.id))),
      method: "PUT",
      headers: headerParameters,
      body: bodyParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/managers/users-by-email-manager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var { BaseAPI: BaseAPI40 } = runtime_exports;
var UsersByEmailManager = class extends BaseAPI40 {
  static {
    __name(this, "UsersByEmailManager");
  }
  /**
   * If Auth0 is the identify provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it. For example, if you register a user as <b>JohnSmith@example.com</b>, Auth0 saves the user's email as <b>johnsmith@example.com</b>.
   *
   * In cases where Auth0 is not the idP, the `email` is stored based on the rules of idP, so make sure the search is made using the correct capitalization.
   *
   * When using this endpoint, make sure that you are searching for users via email addresses using the correct case.
   *
   * Search Users by Email
   *
   * @throws {RequiredError}
   */
  async getByEmail(requestParameters, initOverrides) {
    validateRequiredRequestParams(requestParameters, ["email"]);
    const queryParameters = applyQueryParams(requestParameters, [
      {
        key: "fields",
        config: {}
      },
      {
        key: "include_fields",
        config: {}
      },
      {
        key: "email",
        config: {}
      }
    ]);
    const response = await this.request({
      path: `/users-by-email`,
      method: "GET",
      query: queryParameters
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/management/__generated/index.js
var ManagementClientBase = class {
  static {
    __name(this, "ManagementClientBase");
  }
  constructor(configuration) {
    this.configuration = configuration;
    this.actions = new ActionsManager(this.configuration);
    this.anomaly = new AnomalyManager(this.configuration);
    this.attackProtection = new AttackProtectionManager(this.configuration);
    this.blacklists = new BlacklistsManager(this.configuration);
    this.branding = new BrandingManager(this.configuration);
    this.clientGrants = new ClientGrantsManager(this.configuration);
    this.clients = new ClientsManager(this.configuration);
    this.connections = new ConnectionsManager(this.configuration);
    this.customDomains = new CustomDomainsManager(this.configuration);
    this.deviceCredentials = new DeviceCredentialsManager(this.configuration);
    this.emailTemplates = new EmailTemplatesManager(this.configuration);
    this.emails = new EmailsManager(this.configuration);
    this.flows = new FlowsManager(this.configuration);
    this.forms = new FormsManager(this.configuration);
    this.grants = new GrantsManager(this.configuration);
    this.guardian = new GuardianManager(this.configuration);
    this.hooks = new HooksManager(this.configuration);
    this.jobs = new JobsManager(this.configuration);
    this.keys = new KeysManager(this.configuration);
    this.logStreams = new LogStreamsManager(this.configuration);
    this.logs = new LogsManager(this.configuration);
    this.networkAcls = new NetworkAclsManager(this.configuration);
    this.organizations = new OrganizationsManager(this.configuration);
    this.prompts = new PromptsManager(this.configuration);
    this.refreshTokens = new RefreshTokensManager(this.configuration);
    this.resourceServers = new ResourceServersManager(this.configuration);
    this.riskAssessments = new RiskAssessmentsManager(this.configuration);
    this.roles = new RolesManager(this.configuration);
    this.rules = new RulesManager(this.configuration);
    this.rulesConfigs = new RulesConfigsManager(this.configuration);
    this.selfServiceProfiles = new SelfServiceProfilesManager(this.configuration);
    this.sessions = new SessionsManager(this.configuration);
    this.stats = new StatsManager(this.configuration);
    this.tenants = new TenantsManager(this.configuration);
    this.tickets = new TicketsManager(this.configuration);
    this.tokenExchangeProfiles = new TokenExchangeProfilesManager(this.configuration);
    this.userBlocks = new UserBlocksManager(this.configuration);
    this.users = new UsersManager(this.configuration);
    this.usersByEmail = new UsersByEmailManager(this.configuration);
  }
};

// node_modules/auth0/dist/esm/management/token-provider-middleware.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/management/token-provider.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/auth/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/auth/backchannel.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/auth/base-auth-api.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/auth/client-authentication.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/base64url.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/lib/buffer_utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/webcrypto.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var webcrypto_default = crypto;
var isCryptoKey2 = /* @__PURE__ */ __name((key) => key instanceof CryptoKey, "isCryptoKey");

// node_modules/auth0/node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder2 = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
__name(concat, "concat");

// node_modules/auth0/node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase642 = /* @__PURE__ */ __name((input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder2.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
}, "encodeBase64");
var encode = /* @__PURE__ */ __name((input) => {
  return encodeBase642(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}, "encode");
var decodeBase642 = /* @__PURE__ */ __name((encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}, "decodeBase64");
var decode3 = /* @__PURE__ */ __name((input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase642(encoded);
  } catch (_a2) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}, "decode");

// node_modules/auth0/node_modules/jose/dist/browser/util/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JOSEError = class extends Error {
  static {
    __name(this, "JOSEError");
  }
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message2) {
    var _a2;
    super(message2);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a2 = Error.captureStackTrace) === null || _a2 === void 0 ? void 0 : _a2.call(Error, this, this.constructor);
  }
};
var JWTClaimValidationFailed = class extends JOSEError {
  static {
    __name(this, "JWTClaimValidationFailed");
  }
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message2, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JWTExpired = class extends JOSEError {
  static {
    __name(this, "JWTExpired");
  }
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message2, claim = "unspecified", reason = "unspecified") {
    super(message2);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
};
var JOSEAlgNotAllowed = class extends JOSEError {
  static {
    __name(this, "JOSEAlgNotAllowed");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
var JOSENotSupported = class extends JOSEError {
  static {
    __name(this, "JOSENotSupported");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
var JWSInvalid = class extends JOSEError {
  static {
    __name(this, "JWSInvalid");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
var JWTInvalid = class extends JOSEError {
  static {
    __name(this, "JWTInvalid");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
};
var JWKSInvalid = class extends JOSEError {
  static {
    __name(this, "JWKSInvalid");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
  static get code() {
    return "ERR_JWKS_INVALID";
  }
};
var JWKSNoMatchingKey = class extends JOSEError {
  static {
    __name(this, "JWKSNoMatchingKey");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
    this.message = "no applicable key found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_NO_MATCHING_KEY";
  }
};
var JWKSMultipleMatchingKeys = class extends JOSEError {
  static {
    __name(this, "JWKSMultipleMatchingKeys");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    this.message = "multiple matching keys found in the JSON Web Key Set";
  }
  static get code() {
    return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
var JWKSTimeout = class extends JOSEError {
  static {
    __name(this, "JWKSTimeout");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_TIMEOUT";
    this.message = "request timed out";
  }
  static get code() {
    return "ERR_JWKS_TIMEOUT";
  }
};
var JWSSignatureVerificationFailed = class extends JOSEError {
  static {
    __name(this, "JWSSignatureVerificationFailed");
  }
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};

// node_modules/auth0/node_modules/jose/dist/browser/lib/crypto_key.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
__name(unusable, "unusable");
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
__name(isAlgorithm, "isAlgorithm");
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
__name(getHashLength, "getHashLength");
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
__name(getNamedCurve, "getNamedCurve");
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
__name(checkUsage, "checkUsage");
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
__name(checkSigCryptoKey, "checkSigCryptoKey");

// node_modules/auth0/node_modules/jose/dist/browser/lib/invalid_key_input.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
__name(message, "message");
var invalid_key_input_default = /* @__PURE__ */ __name((actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
}, "default");
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
__name(withAlg, "withAlg");

// node_modules/auth0/node_modules/jose/dist/browser/runtime/is_key_like.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var is_key_like_default = /* @__PURE__ */ __name((key) => {
  return isCryptoKey2(key);
}, "default");
var types = ["CryptoKey"];

// node_modules/auth0/node_modules/jose/dist/browser/lib/is_disjoint.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isDisjoint = /* @__PURE__ */ __name((...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}, "isDisjoint");
var is_disjoint_default = isDisjoint;

// node_modules/auth0/node_modules/jose/dist/browser/lib/is_object.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
__name(isObjectLike, "isObjectLike");
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
__name(isObject, "isObject");

// node_modules/auth0/node_modules/jose/dist/browser/runtime/check_key_length.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var check_key_length_default = /* @__PURE__ */ __name((alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}, "default");

// node_modules/auth0/node_modules/jose/dist/browser/key/import.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/asn1.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var findOid = /* @__PURE__ */ __name((keyData, oid, from = 0) => {
  if (from === 0) {
    oid.unshift(oid.length);
    oid.unshift(6);
  }
  let i = keyData.indexOf(oid[0], from);
  if (i === -1)
    return false;
  const sub = keyData.subarray(i, i + oid.length);
  if (sub.length !== oid.length)
    return false;
  return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
}, "findOid");
var getNamedCurve2 = /* @__PURE__ */ __name((keyData) => {
  switch (true) {
    case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
      return "P-256";
    case findOid(keyData, [43, 129, 4, 0, 34]):
      return "P-384";
    case findOid(keyData, [43, 129, 4, 0, 35]):
      return "P-521";
    case findOid(keyData, [43, 101, 110]):
      return "X25519";
    case findOid(keyData, [43, 101, 111]):
      return "X448";
    case findOid(keyData, [43, 101, 112]):
      return "Ed25519";
    case findOid(keyData, [43, 101, 113]):
      return "Ed448";
    default:
      throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
  }
}, "getNamedCurve");
var genericImport = /* @__PURE__ */ __name(async (replace, keyFormat, pem, alg, options) => {
  var _a2;
  let algorithm;
  let keyUsages;
  const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c2) => c2.charCodeAt(0)));
  const isPublic = keyFormat === "spki";
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
      };
      keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      const namedCurve = getNamedCurve2(keyData);
      algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
      keyUsages = isPublic ? [] : ["deriveBits"];
      break;
    }
    case "EdDSA":
      algorithm = { name: getNamedCurve2(keyData) };
      keyUsages = isPublic ? ["verify"] : ["sign"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
  }
  return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a2 = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a2 !== void 0 ? _a2 : false, keyUsages);
}, "genericImport");
var fromPKCS8 = /* @__PURE__ */ __name((pem, alg, options) => {
  return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
}, "fromPKCS8");

// node_modules/auth0/node_modules/jose/dist/browser/runtime/jwk_to_key.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
__name(subtleMapping, "subtleMapping");
var parse2 = /* @__PURE__ */ __name(async (jwk) => {
  var _a2, _b;
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    (_a2 = jwk.ext) !== null && _a2 !== void 0 ? _a2 : false,
    (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
  ];
  if (algorithm.name === "PBKDF2") {
    return webcrypto_default.subtle.importKey("raw", decode3(jwk.k), ...rest);
  }
  const keyData = { ...jwk };
  delete keyData.alg;
  delete keyData.use;
  return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
}, "parse");
var jwk_to_key_default = parse2;

// node_modules/auth0/node_modules/jose/dist/browser/key/import.js
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
__name(importPKCS8, "importPKCS8");
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a2;
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a2 = jwk.ext) !== null && _a2 !== void 0 ? _a2 : false });
      }
      return decode3(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
__name(importJWK, "importJWK");

// node_modules/auth0/node_modules/jose/dist/browser/lib/check_key_type.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var symmetricTypeCheck = /* @__PURE__ */ __name((alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
}, "symmetricTypeCheck");
var asymmetricTypeCheck = /* @__PURE__ */ __name((alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
}, "asymmetricTypeCheck");
var checkKeyType = /* @__PURE__ */ __name((alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
}, "checkKeyType");
var check_key_type_default = checkKeyType;

// node_modules/auth0/node_modules/jose/dist/browser/lib/validate_crit.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
__name(validateCrit, "validateCrit");
var validate_crit_default = validateCrit;

// node_modules/auth0/node_modules/jose/dist/browser/lib/validate_algorithms.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var validateAlgorithms = /* @__PURE__ */ __name((option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
}, "validateAlgorithms");
var validate_algorithms_default = validateAlgorithms;

// node_modules/auth0/node_modules/jose/dist/browser/jws/compact/verify.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/jws/flattened/verify.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/verify.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/subtle_dsa.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function subtleDsa(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
__name(subtleDsa, "subtleDsa");

// node_modules/auth0/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey2(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
__name(getCryptoKey, "getCryptoKey");

// node_modules/auth0/node_modules/jose/dist/browser/runtime/verify.js
var verify3 = /* @__PURE__ */ __name(async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a2) {
    return false;
  }
}, "verify");
var verify_default = verify3;

// node_modules/auth0/node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a2;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode3(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder2.encode((_a2 = jws.protected) !== null && _a2 !== void 0 ? _a2 : ""), encoder2.encode("."), typeof jws.payload === "string" ? encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode3(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode3(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
__name(flattenedVerify, "flattenedVerify");

// node_modules/auth0/node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
__name(compactVerify, "compactVerify");

// node_modules/auth0/node_modules/jose/dist/browser/jwt/verify.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/lib/jwt_claims_set.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/lib/epoch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var epoch_default = /* @__PURE__ */ __name((date) => Math.floor(date.getTime() / 1e3), "default");

// node_modules/auth0/node_modules/jose/dist/browser/lib/secs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = /* @__PURE__ */ __name((str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
}, "default");

// node_modules/auth0/node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = /* @__PURE__ */ __name((value) => value.toLowerCase().replace(/^application\//, ""), "normalizeTyp");
var checkAudiencePresence = /* @__PURE__ */ __name((audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
}, "checkAudiencePresence");
var jwt_claims_set_default = /* @__PURE__ */ __name((protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a2) {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== void 0)
    requiredClaims.push("iat");
  if (audience !== void 0)
    requiredClaims.push("aud");
  if (subject !== void 0)
    requiredClaims.push("sub");
  if (issuer !== void 0)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
}, "default");

// node_modules/auth0/node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt2, key, options) {
  var _a2;
  const verified = await compactVerify(jwt2, key, options);
  if (((_a2 = verified.protectedHeader.crit) === null || _a2 === void 0 ? void 0 : _a2.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
__name(jwtVerify, "jwtVerify");

// node_modules/auth0/node_modules/jose/dist/browser/jws/compact/sign.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/jws/flattened/sign.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/sign.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var sign3 = /* @__PURE__ */ __name(async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
}, "sign");
var sign_default = sign3;

// node_modules/auth0/node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign = class {
  static {
    __name(this, "FlattenedSign");
  }
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder2.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder2.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder2.encode("");
    }
    const data = concat(protectedHeader, encoder2.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};

// node_modules/auth0/node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign = class {
  static {
    __name(this, "CompactSign");
  }
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};

// node_modules/auth0/node_modules/jose/dist/browser/jwt/sign.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/jwt/produce.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ProduceJWT = class {
  static {
    __name(this, "ProduceJWT");
  }
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
};

// node_modules/auth0/node_modules/jose/dist/browser/jwt/sign.js
var SignJWT = class extends ProduceJWT {
  static {
    __name(this, "SignJWT");
  }
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a2;
    const sig = new CompactSign(encoder2.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a2 = this._protectedHeader) === null || _a2 === void 0 ? void 0 : _a2.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
};

// node_modules/auth0/node_modules/jose/dist/browser/jwks/local.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
__name(getKtyFromAlg, "getKtyFromAlg");
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
__name(isJWKSLike, "isJWKSLike");
function isJWKLike(key) {
  return isObject(key);
}
__name(isJWKLike, "isJWKLike");
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
__name(clone, "clone");
var LocalJWKSet = class {
  static {
    __name(this, "LocalJWKSet");
  }
  constructor(jwks) {
    this._cached = /* @__PURE__ */ new WeakMap();
    if (!isJWKSLike(jwks)) {
      throw new JWKSInvalid("JSON Web Key Set malformed");
    }
    this._jwks = clone(jwks);
  }
  async getKey(protectedHeader, token) {
    const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
    const kty = getKtyFromAlg(alg);
    const candidates = this._jwks.keys.filter((jwk2) => {
      let candidate = kty === jwk2.kty;
      if (candidate && typeof kid === "string") {
        candidate = kid === jwk2.kid;
      }
      if (candidate && typeof jwk2.alg === "string") {
        candidate = alg === jwk2.alg;
      }
      if (candidate && typeof jwk2.use === "string") {
        candidate = jwk2.use === "sig";
      }
      if (candidate && Array.isArray(jwk2.key_ops)) {
        candidate = jwk2.key_ops.includes("verify");
      }
      if (candidate && alg === "EdDSA") {
        candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
      }
      if (candidate) {
        switch (alg) {
          case "ES256":
            candidate = jwk2.crv === "P-256";
            break;
          case "ES256K":
            candidate = jwk2.crv === "secp256k1";
            break;
          case "ES384":
            candidate = jwk2.crv === "P-384";
            break;
          case "ES512":
            candidate = jwk2.crv === "P-521";
            break;
        }
      }
      return candidate;
    });
    const { 0: jwk, length } = candidates;
    if (length === 0) {
      throw new JWKSNoMatchingKey();
    } else if (length !== 1) {
      const error3 = new JWKSMultipleMatchingKeys();
      const { _cached } = this;
      error3[Symbol.asyncIterator] = async function* () {
        for (const jwk2 of candidates) {
          try {
            yield await importWithAlgCache(_cached, jwk2, alg);
          } catch (_a2) {
            continue;
          }
        }
      };
      throw error3;
    }
    return importWithAlgCache(this._cached, jwk, alg);
  }
};
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
__name(importWithAlgCache, "importWithAlgCache");

// node_modules/auth0/node_modules/jose/dist/browser/jwks/remote.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/runtime/fetch_jwks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var fetchJwks = /* @__PURE__ */ __name(async (url, timeout, options) => {
  let controller;
  let id;
  let timedOut = false;
  if (typeof AbortController === "function") {
    controller = new AbortController();
    id = setTimeout(() => {
      timedOut = true;
      controller.abort();
    }, timeout);
  }
  const response = await fetch(url.href, {
    signal: controller ? controller.signal : void 0,
    redirect: "manual",
    headers: options.headers
  }).catch((err) => {
    if (timedOut)
      throw new JWKSTimeout();
    throw err;
  });
  if (id !== void 0)
    clearTimeout(id);
  if (response.status !== 200) {
    throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
  }
  try {
    return await response.json();
  } catch (_a2) {
    throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
}, "fetchJwks");
var fetch_jwks_default = fetchJwks;

// node_modules/auth0/node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && true || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
__name(isCloudflareWorkers, "isCloudflareWorkers");
var RemoteJWKSet = class extends LocalJWKSet {
  static {
    __name(this, "RemoteJWKSet");
  }
  constructor(url, options) {
    super({ keys: [] });
    this._jwks = void 0;
    if (!(url instanceof URL)) {
      throw new TypeError("url must be an instance of URL");
    }
    this._url = new URL(url.href);
    this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
    this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
    this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
    this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
  }
  coolingDown() {
    return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
  }
  fresh() {
    return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
  }
  async getKey(protectedHeader, token) {
    if (!this._jwks || !this.fresh()) {
      await this.reload();
    }
    try {
      return await super.getKey(protectedHeader, token);
    } catch (err) {
      if (err instanceof JWKSNoMatchingKey) {
        if (this.coolingDown() === false) {
          await this.reload();
          return super.getKey(protectedHeader, token);
        }
      }
      throw err;
    }
  }
  async reload() {
    if (this._pendingFetch && isCloudflareWorkers()) {
      this._pendingFetch = void 0;
    }
    this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
      if (!isJWKSLike(json)) {
        throw new JWKSInvalid("JSON Web Key Set malformed");
      }
      this._jwks = { keys: json.keys };
      this._jwksTimestamp = Date.now();
      this._pendingFetch = void 0;
    }).catch((err) => {
      this._pendingFetch = void 0;
      throw err;
    }));
    await this._pendingFetch;
  }
};
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
__name(createRemoteJWKSet, "createRemoteJWKSet");

// node_modules/auth0/node_modules/jose/dist/browser/util/decode_protected_header.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/node_modules/jose/dist/browser/util/base64url.js
var base64url_exports = {};
__export(base64url_exports, {
  decode: () => decode4,
  encode: () => encode2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var encode2 = encode;
var decode4 = decode3;

// node_modules/auth0/node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder.decode(decode4(protectedB64u)));
    if (!isObject(result)) {
      throw new Error();
    }
    return result;
  } catch (_a2) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
__name(decodeProtectedHeader, "decodeProtectedHeader");

// node_modules/auth0/node_modules/jose/dist/browser/util/decode_jwt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function decodeJwt(jwt2) {
  if (typeof jwt2 !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt2.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode4(payload);
  } catch (_a2) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
__name(decodeJwt, "decodeJwt");

// node_modules/auth0/dist/esm/auth/client-authentication.js
init_esm_browser();
var addClientAuthentication = /* @__PURE__ */ __name(async ({ payload, domain: domain2, clientId, clientAssertionSigningKey, clientAssertionSigningAlg, clientSecret, useMTLS }) => {
  const cid = payload.client_id || clientId;
  if (clientAssertionSigningKey && !payload.client_assertion) {
    const alg = clientAssertionSigningAlg || "RS256";
    const privateKey = await importPKCS8(clientAssertionSigningKey, alg);
    payload.client_assertion = await new SignJWT({}).setProtectedHeader({ alg }).setIssuedAt().setSubject(cid).setJti(v4_default()).setIssuer(cid).setAudience(`https://${domain2}/`).setExpirationTime("2mins").sign(privateKey);
    payload.client_assertion_type = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
  } else if (clientSecret && !payload.client_secret) {
    payload.client_secret = clientSecret;
  }
  if ((!payload.client_secret || payload.client_secret.trim().length === 0) && (!payload.client_assertion || payload.client_assertion.trim().length === 0) && !useMTLS) {
    throw new Error("The client_secret or client_assertion field is required, or it should be mTLS request.");
  }
  return payload;
}, "addClientAuthentication");

// node_modules/auth0/dist/esm/lib/middleware/telemetry-middleware.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/version.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version3 = "4.30.0";

// node_modules/auth0/dist/esm/utils.js
function detectRuntime() {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process.versions) === null || _a2 === void 0 ? void 0 : _a2.node)) {
    return "node";
  }
  if (typeof navigator !== "undefined" && true) {
    return "cloudflare-workers";
  }
  if (typeof Deno !== "undefined") {
    return "deno";
  }
  return "unknown";
}
__name(detectRuntime, "detectRuntime");
var generateClientInfo = /* @__PURE__ */ __name(() => {
  var _a2, _b;
  const runtime = detectRuntime();
  return {
    name: "node-auth0",
    version: version3,
    env: {
      [runtime]: (_b = (_a2 = process.version) === null || _a2 === void 0 ? void 0 : _a2.replace("v", "")) !== null && _b !== void 0 ? _b : "unknown"
    }
  };
}, "generateClientInfo");
var mtlsPrefix = "mtls";
var resolveValueToPromise = /* @__PURE__ */ __name(async (value) => {
  if (typeof value === "function") {
    const result = value();
    return result instanceof Promise ? result : Promise.resolve(result);
  }
  return Promise.resolve(value);
}, "resolveValueToPromise");

// node_modules/auth0/dist/esm/lib/middleware/telemetry-middleware.js
var TelemetryMiddleware = class {
  static {
    __name(this, "TelemetryMiddleware");
  }
  constructor(options) {
    this.clientInfo = options.clientInfo || generateClientInfo();
  }
  async pre(context2) {
    if ("string" === typeof this.clientInfo.name && this.clientInfo.name.length > 0) {
      context2.init.headers = {
        ...context2.init.headers,
        "Auth0-Client": base64url_exports.encode(JSON.stringify(this.clientInfo))
      };
    }
    return {
      url: context2.url,
      init: context2.init
    };
  }
};

// node_modules/auth0/dist/esm/auth/base-auth-api.js
var AuthApiError = class extends Error {
  static {
    __name(this, "AuthApiError");
  }
  constructor(error3, error_description, statusCode, body, headers) {
    super(error_description || error3);
    this.error = error3;
    this.error_description = error_description;
    this.statusCode = statusCode;
    this.body = body;
    this.headers = headers;
    this.name = "AuthApiError";
  }
};
function parseErrorBody(body) {
  const rawData = JSON.parse(body);
  let data;
  if (rawData.error) {
    data = rawData;
  } else {
    data = {
      error: rawData.code,
      error_description: rawData.description
    };
  }
  return data;
}
__name(parseErrorBody, "parseErrorBody");
async function parseError(response) {
  const body = await response.text();
  try {
    const data = parseErrorBody(body);
    return new AuthApiError(data.error, data.error_description, response.status, body, response.headers);
  } catch (_) {
    return new ResponseError(response.status, body, response.headers, "Response returned an error code");
  }
}
__name(parseError, "parseError");
var BaseAuthAPI = class extends BaseAPI {
  static {
    __name(this, "BaseAuthAPI");
  }
  constructor(options) {
    super({
      ...options,
      baseUrl: `https://${options.domain}`,
      middleware: options.telemetry !== false ? [new TelemetryMiddleware(options)] : [],
      parseError,
      retry: { enabled: false, ...options.retry }
    });
    this.domain = options.domain;
    this.clientId = options.clientId;
    this.clientSecret = options.clientSecret;
    this.clientAssertionSigningKey = options.clientAssertionSigningKey;
    this.clientAssertionSigningAlg = options.clientAssertionSigningAlg;
    this.useMTLS = options.useMTLS;
  }
  /**
   * @private
   */
  async addClientAuthentication(payload) {
    return addClientAuthentication({
      payload,
      domain: this.domain,
      clientId: this.clientId,
      clientSecret: this.clientSecret,
      clientAssertionSigningKey: this.clientAssertionSigningKey,
      clientAssertionSigningAlg: this.clientAssertionSigningAlg,
      useMTLS: this.useMTLS
    });
  }
};
async function grant(grantType, bodyParameters, { idTokenValidateOptions, initOverrides } = {}, clientId, idTokenValidator, request) {
  const response = await request({
    path: "/oauth/token",
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: new URLSearchParams({
      client_id: clientId,
      ...bodyParameters,
      grant_type: grantType
    })
  }, initOverrides);
  const res = await JSONApiResponse.fromResponse(response);
  if (res.data.id_token) {
    await idTokenValidator.validate(res.data.id_token, idTokenValidateOptions);
  }
  return res;
}
__name(grant, "grant");

// node_modules/auth0/dist/esm/auth/backchannel.js
var getLoginHint = /* @__PURE__ */ __name((userId, domain2) => {
  const trimmedDomain = domain2.endsWith("/") ? domain2.slice(0, -1) : domain2;
  const loginHint = {
    format: "iss_sub",
    iss: `https://${trimmedDomain}/`,
    sub: `${userId}`
  };
  return JSON.stringify(loginHint);
}, "getLoginHint");
var CIBA_GRANT_TYPE = "urn:openid:params:grant-type:ciba";
var CIBA_AUTHORIZE_URL = "/bc-authorize";
var CIBA_TOKEN_URL = "/oauth/token";
var Backchannel = class extends BaseAuthAPI {
  static {
    __name(this, "Backchannel");
  }
  /**
   * Initiates a CIBA authorization request.
   *
   * @param {AuthorizeOptions} options - The options for the request.
   * @returns {Promise<AuthorizeResponse>} - The authorization response.
   *
   * @throws {Error} - If the request fails.
   */
  async authorize({ userId, ...options }) {
    const body = {
      ...options,
      login_hint: getLoginHint(userId, this.domain),
      client_id: this.clientId
    };
    const requestedExpiry = options.requested_expiry || options.request_expiry;
    if (requestedExpiry) {
      body.requested_expiry = requestedExpiry;
    }
    await this.addClientAuthentication(body);
    const response = await this.request.bind(this)({
      path: CIBA_AUTHORIZE_URL,
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams(body)
    }, {});
    const r = await JSONApiResponse.fromResponse(response);
    return r.data;
  }
  /**
   * Handles the backchannel grant flow for authentication. Client can poll this method at regular intervals to check if the backchannel auth request has been approved.
   *
   * @param {string} auth_req_id - The authorization request ID. This value is returned from the call to /bc-authorize. Once you have exchanged an auth_req_id for an ID and access token, it is no longer usable.
   * @returns {Promise<TokenResponse>} - A promise that resolves to the token response.
   *
   * @throws {Error} - Throws an error if the request fails.
   *
   * If the authorizing user has not yet approved or rejected the request, you will receive a response like this:
   * ```json
   * {
   *   "error": "authorization_pending",
   *   "error_description": "The end-user authorization is pending"
   * }
   * ```
   *
   * If the authorizing user rejects the request, you will receive a response like this:
   * ```json
   * {
   *   "error": "access_denied",
   *   "error_description": "The end-user denied the authorization request or it has been expired"
   * }
   * ```
   *
   * If you are polling too quickly (faster than the interval value returned from /bc-authorize), you will receive a response like this:
   * ```json
   * {
   *   "error": "slow_down",
   *   "error_description": "You are polling faster than allowed. Try again in 10 seconds."
   * }
   * ```
   */
  async backchannelGrant({ auth_req_id }) {
    const body = {
      client_id: this.clientId,
      auth_req_id,
      grant_type: CIBA_GRANT_TYPE
    };
    await this.addClientAuthentication(body);
    const response = await this.request.bind(this)({
      path: CIBA_TOKEN_URL,
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams(body)
    }, {});
    const r = await JSONApiResponse.fromResponse(response);
    return r.data;
  }
};

// node_modules/auth0/dist/esm/auth/database.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Database = class extends BaseAuthAPI {
  static {
    __name(this, "Database");
  }
  /**
   * Given a user's credentials, and a connection, this endpoint will create a new user using active authentication.
   *
   * This endpoint only works for database connections.
   *
   * See: https://auth0.com/docs/api/authentication#signup
   *
   * @example
   * ```js
   * var data = {
   *   email: '{EMAIL}',
   *   password: '{PASSWORD}',
   *   connection: 'Username-Password-Authentication'
   * };
   *
   * await auth0.database.signUp(data);
   * ```
   */
  async signUp(bodyParameters, initOverrides) {
    validateRequiredRequestParams(bodyParameters, ["email", "password", "connection"]);
    const response = await this.request({
      path: "/dbconnections/signup",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: { client_id: this.clientId, ...bodyParameters }
    }, initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * Given a user's email address and a connection, Auth0 will send a change password email.
   *
   * This endpoint only works for database connections.
   *
   * See: https://auth0.com/docs/api/authentication#change-password
   *
   * @example
   * ```js
   * var data = {
   *   email: '{EMAIL}',
   *   connection: 'Username-Password-Authentication'
   * };
   *
   * await auth0.database.changePassword(data);
   * ```
   */
  async changePassword(bodyParameters, initOverrides) {
    validateRequiredRequestParams(bodyParameters, ["email", "connection"]);
    const response = await this.request({
      path: "/dbconnections/change_password",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: { client_id: this.clientId, ...bodyParameters }
    }, initOverrides);
    return TextApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/auth/oauth.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/auth0/dist/esm/auth/id-token-validator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DEFAULT_CLOCK_TOLERANCE = 60;
var IdTokenValidatorError = class extends Error {
  static {
    __name(this, "IdTokenValidatorError");
  }
};
var IDTokenValidator = class {
  static {
    __name(this, "IDTokenValidator");
  }
  constructor({ domain: domain2, clientId, clientSecret, agent, headers, timeoutDuration, idTokenSigningAlg = "RS256", clockTolerance = DEFAULT_CLOCK_TOLERANCE }) {
    this.jwks = createRemoteJWKSet(new URL(`https://${domain2}/.well-known/jwks.json`), {
      timeoutDuration,
      agent,
      headers
    });
    this.alg = idTokenSigningAlg;
    this.audience = clientId;
    this.secret = new TextEncoder().encode(clientSecret);
    this.issuer = `https://${domain2}/`;
    this.clockTolerance = clockTolerance;
  }
  async validate(idToken, { nonce, maxAge, organization } = {}) {
    const secret = this.alg === "HS256" ? this.secret : this.jwks;
    const header = decodeProtectedHeader(idToken);
    const payload = decodeJwt(idToken);
    if (header.alg !== "RS256" && header.alg !== "HS256") {
      throw new Error(`Signature algorithm of "${header.alg}" is not supported. Expected the ID token to be signed with "RS256" or "HS256".`);
    }
    if (!payload.iss || typeof payload.iss !== "string") {
      throw new IdTokenValidatorError("Issuer (iss) claim must be a string present in the ID token");
    }
    if (payload.iss !== this.issuer) {
      throw new IdTokenValidatorError(`Issuer (iss) claim mismatch in the ID token; expected "${this.issuer}", found "${payload.iss}"`);
    }
    if (!payload.sub || typeof payload.sub !== "string") {
      throw new IdTokenValidatorError("Subject (sub) claim must be a string present in the ID token");
    }
    if (!payload.aud || !(typeof payload.aud === "string" || Array.isArray(payload.aud))) {
      throw new IdTokenValidatorError("Audience (aud) claim must be a string or array of strings present in the ID token");
    }
    if (Array.isArray(payload.aud) && !payload.aud.includes(this.audience)) {
      throw new IdTokenValidatorError(`Audience (aud) claim mismatch in the ID token; expected "${this.audience}" but was not one of "${payload.aud.join(", ")}"`);
    } else if (typeof payload.aud === "string" && payload.aud !== this.audience) {
      throw new IdTokenValidatorError(`Audience (aud) claim mismatch in the ID token; expected "${this.audience}" but found "${payload.aud}"`);
    }
    if (organization) {
      if (organization.indexOf("org_") === 0) {
        if (!payload.org_id || typeof payload.org_id !== "string") {
          throw new Error("Organization Id (org_id) claim must be a string present in the ID token");
        }
      } else {
        if (!payload.org_name || typeof payload.org_name !== "string") {
          throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
        }
      }
    }
    const now = Math.floor(Date.now() / 1e3);
    if (!payload.exp || typeof payload.exp !== "number") {
      throw new IdTokenValidatorError("Expiration Time (exp) claim must be a number present in the ID token");
    }
    const expTime = payload.exp + this.clockTolerance;
    if (now > expTime) {
      throw new IdTokenValidatorError(`Expiration Time (exp) claim error in the ID token; current time (${now}) is after expiration time (${expTime})`);
    }
    if (!payload.iat || typeof payload.iat !== "number") {
      throw new IdTokenValidatorError("Issued At (iat) claim must be a number present in the ID token");
    }
    if (nonce || payload.nonce) {
      if (!payload.nonce || typeof payload.nonce !== "string") {
        throw new IdTokenValidatorError("Nonce (nonce) claim must be a string present in the ID token");
      }
      if (payload.nonce !== nonce) {
        throw new IdTokenValidatorError(`Nonce (nonce) claim mismatch in the ID token; expected "${nonce}", found "${payload.nonce}"`);
      }
    }
    if (Array.isArray(payload.aud) && payload.aud.length > 1) {
      if (!payload.azp || typeof payload.azp !== "string") {
        throw new IdTokenValidatorError("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
      }
      if (payload.azp !== this.audience) {
        throw new IdTokenValidatorError(`Authorized Party (azp) claim mismatch in the ID token; expected "${this.audience}", found "${payload.azp}"`);
      }
    }
    if (maxAge) {
      if (!payload.auth_time || typeof payload.auth_time !== "number") {
        throw new IdTokenValidatorError("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
      }
      const authValidUntil = payload.auth_time + maxAge + this.clockTolerance;
      if (now > authValidUntil) {
        throw new IdTokenValidatorError(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Currrent time (${now}) is after last auth at ${authValidUntil}`);
      }
    }
    await jwtVerify(idToken, secret, {
      issuer: this.issuer,
      audience: this.audience,
      clockTolerance: this.clockTolerance,
      maxTokenAge: maxAge,
      algorithms: ["HS256", "RS256"]
    });
  }
};

// node_modules/auth0/dist/esm/auth/oauth.js
var SUBJECT_TOKEN_TYPES;
(function(SUBJECT_TOKEN_TYPES2) {
  SUBJECT_TOKEN_TYPES2["REFRESH_TOKEN"] = "urn:ietf:params:oauth:token-type:refresh_token";
  SUBJECT_TOKEN_TYPES2["ACCESS_TOKEN"] = "urn:ietf:params:oauth:token-type:access_token";
})(SUBJECT_TOKEN_TYPES || (SUBJECT_TOKEN_TYPES = {}));
var TOKEN_FOR_CONNECTION_GRANT_TYPE = "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token";
var TOKEN_FOR_CONNECTION_REQUESTED_TOKEN_TYPE = "http://auth0.com/oauth/token-type/federated-connection-access-token";
var TOKEN_URL = "/oauth/token";
var OAuth = class extends BaseAuthAPI {
  static {
    __name(this, "OAuth");
  }
  constructor(options) {
    super({
      ...options,
      domain: options.useMTLS ? `${mtlsPrefix}.${options.domain}` : options.domain
    });
    this.idTokenValidator = new IDTokenValidator(options);
  }
  /**
   * This is the flow that regular web apps use to access an API.
   *
   * Use this endpoint to exchange an Authorization Code for a Token.
   *
   * See: https://auth0.com/docs/api/authentication#authorization-code-flow44
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.authorizationCodeGrant({ code: 'mycode' });
   * ```
   */
  async authorizationCodeGrant(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["code"]);
    return grant("authorization_code", await this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
  /**
   * PKCE was originally designed to protect the authorization code flow in mobile apps,
   * but its ability to prevent authorization code injection makes it useful for every type of OAuth client,
   * even web apps that use client authentication.
   *
   * See: https://auth0.com/docs/api/authentication#authorization-code-flow-with-pkce45
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.authorizationCodeGrantWithPKCE({
   *   code: 'mycode',
   *   code_verifier: 'mycodeverifier'
   * });
   * ```
   */
  async authorizationCodeGrantWithPKCE(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["code", "code_verifier"]);
    return grant("authorization_code", await this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
  /**
   * This is the OAuth 2.0 grant that server processes use to access an API.
   *
   * Use this endpoint to directly request an Access Token by using the Client's credentials
   * (a Client ID and a Client Secret or a Client Assertion).
   *
   * See: https://auth0.com/docs/api/authentication#client-credentials-flow
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.clientCredentialsGrant({ audience: 'myaudience' });
   * ```
   */
  async clientCredentialsGrant(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["audience"]);
    return grant("client_credentials", await this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
  /**
   * This is the OAuth 2.0 extension that allows to initiate an OAuth flow from the backchannel instead of by building a URL.
   *
   *
   * See: https://www.rfc-editor.org/rfc/rfc9126.html
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.pushedAuthorization({ response_type: 'id_token', redirect_uri: 'http://localhost' });
   * ```
   */
  async pushedAuthorization(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["client_id", "response_type", "redirect_uri"]);
    const bodyParametersWithClientAuthentication = await this.addClientAuthentication(bodyParameters);
    const response = await this.request({
      path: "/oauth/par",
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({
        client_id: this.clientId,
        ...bodyParametersWithClientAuthentication
      })
    }, options.initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
  /**
   * This information is typically received from a highly trusted public client like a SPA*.
   * (<strong>*Note:</string> For single-page applications and native/mobile apps, we recommend using web flows instead.)
   *
   * See: https://auth0.com/docs/api/authentication#resource-owner-password
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId'
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.passwordGrant({
   *     username: 'myusername@example.com',
   *     password: 'mypassword'
   *   },
   *   { initOverrides: { headers: { 'auth0-forwarded-for': 'END.USER.IP.123' } } }
   * );
   * ```
   *
   * Set the'auth0-forwarded-for' header to the end-user IP as a string value if you want
   * brute-force protection to work in server-side scenarios.
   *
   * See https://auth0.com/docs/get-started/authentication-and-authorization-flow/avoid-common-issues-with-resource-owner-password-flow-and-attack-protection
   *
   */
  async passwordGrant(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["username", "password"]);
    return grant(bodyParameters.realm ? "http://auth0.com/oauth/grant-type/password-realm" : "password", await this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
  /**
   * Use this endpoint to refresh an Access Token using the Refresh Token you got during authorization.
   *
   * See: https://auth0.com/docs/api/authentication#refresh-token
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId'
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.refreshTokenGrant({ refresh_token: 'myrefreshtoken' })
   * ```
   */
  async refreshTokenGrant(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["refresh_token"]);
    return grant("refresh_token", await this.addClientAuthentication(bodyParameters), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
  /**
   * Use this endpoint to invalidate a Refresh Token if it has been compromised.
   *
   * The behaviour of this endpoint depends on the state of the <a href="https://auth0.com/docs/secure/tokens/refresh-tokens/revoke-refresh-tokens#refresh-tokens-and-grants">Refresh Token Revocation Deletes Grant</a> toggle.
   * If this toggle is enabled, then each revocation request invalidates not only the specific token, but all other tokens based on the same authorization grant.
   * This means that all Refresh Tokens that have been issued for the same user, application, and audience will be revoked.
   * If this toggle is disabled, then only the refresh token is revoked, while the grant is left intact.
   *
   * See: https://auth0.com/docs/api/authentication#revoke-refresh-token
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId'
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.oauth.revokeRefreshToken({ token: 'myrefreshtoken' })
   * ```
   */
  async revokeRefreshToken(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["token"]);
    const response = await this.request({
      path: "/oauth/revoke",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: await this.addClientAuthentication({ client_id: this.clientId, ...bodyParameters })
    }, options.initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Exchanges a subject token for an access token for the connection.
   *
   * The request body includes:
   * - client_id (and client_secret/client_assertion via addClientAuthentication)
   * - grant_type set to `urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token`
   * - subject_token: the token to exchange
   * - subject_token_type: the type of token being exchanged. Defaults to refresh tokens (`urn:ietf:params:oauth:token-type:refresh_token`).
   * - requested_token_type (`http://auth0.com/oauth/token-type/federated-connection-access-token`) indicating that a federated connection access token is desired
   * - connection name and an optional `login_hint` if provided
   *
   * @param bodyParameters - The options to retrieve a token for a connection.
   * @returns A promise with the token response data.
   * @throws An error if the exchange fails.
   */
  async tokenForConnection(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["connection", "subject_token"]);
    const body = {
      subject_token_type: SUBJECT_TOKEN_TYPES.REFRESH_TOKEN,
      ...bodyParameters,
      grant_type: TOKEN_FOR_CONNECTION_GRANT_TYPE,
      requested_token_type: TOKEN_FOR_CONNECTION_REQUESTED_TOKEN_TYPE
    };
    await this.addClientAuthentication(body);
    const response = await this.request({
      path: TOKEN_URL,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams(body)
    }, options.initOverrides);
    return JSONApiResponse.fromResponse(response);
  }
};

// node_modules/auth0/dist/esm/auth/passwordless.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Passwordless = class extends BaseAuthAPI {
  static {
    __name(this, "Passwordless");
  }
  constructor(configuration) {
    super(configuration);
    this.idTokenValidator = new IDTokenValidator(configuration);
  }
  /**
   * Start passwordless flow sending an email.
   *
   * Given the user `email` address, it will send an email with:
   *
   * <ul>
   *   <li>A link (default, `send:"link"`). You can then authenticate with this
   *     user opening the link and he will be automatically logged in to the
   *     application. Optionally, you can append/override parameters to the link
   *     (like `scope`, `redirect_uri`, `protocol`, `response_type`, etc.) using
   *     `authParams` object.
   *   </li>
   *   <li>
   *     A verification code (`send:"code"`). You can then authenticate with
   *     this user using the `/oauth/token` endpoint specifying `email` as
   *     `username` and `code` as `password`.
   *   </li>
   * </ul>
   *
   * See: https://auth0.com/docs/api/authentication#get-code-or-link
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.sendEmail({
   *   email: '{EMAIL}',
   *   send: 'link',
   *   authParams: {} // Optional auth params.
   * });
   * ```
   */
  async sendEmail(bodyParameters, initOverrides) {
    validateRequiredRequestParams(bodyParameters, ["email"]);
    const response = await this.request({
      path: "/passwordless/start",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: await this.addClientAuthentication({
        client_id: this.clientId,
        connection: "email",
        ...bodyParameters
      })
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Start passwordless flow sending an SMS.
   *
   * Given the user `phone_number`, it will send a SMS message with a
   * verification code. You can then authenticate with this user using the
   * `/oauth/token` endpoint specifying `phone_number` as `username` and `code` as
   * `password`:
   *
   * See: https://auth0.com/docs/api/authentication#get-code-or-link
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.sendSMS({
   *   phone_number: '{PHONE}'
   * });
   * ```
   */
  async sendSMS(bodyParameters, initOverrides) {
    validateRequiredRequestParams(bodyParameters, ["phone_number"]);
    const response = await this.request({
      path: "/passwordless/start",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: await this.addClientAuthentication({
        client_id: this.clientId,
        connection: "sms",
        ...bodyParameters
      })
    }, initOverrides);
    return VoidApiResponse.fromResponse(response);
  }
  /**
   * Once you have a verification code, use this endpoint to login the user with their email and verification code.
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.loginWithEmail({
   *   email: 'foo@example.com',
   *   code: 'ABC123'
   * });
   * ```
   */
  async loginWithEmail(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["email", "code"]);
    const { email: username, code: otp, ...otherParams } = bodyParameters;
    return grant("http://auth0.com/oauth/grant-type/passwordless/otp", await this.addClientAuthentication({
      username,
      otp,
      realm: "email",
      ...otherParams
    }), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
  /**
   * Once you have a verification code, use this endpoint to login the user with their phone number and verification code.
   *
   * @example
   * ```js
   * const auth0 = new AuthenticationApi({
   *    domain: 'my-domain.auth0.com',
   *    clientId: 'myClientId',
   *    clientSecret: 'myClientSecret'
   * });
   *
   * await auth0.passwordless.loginWithSMS({
   *   phone_number: '0777777777',
   *   code: 'ABC123'
   * });
   * ```
   */
  async loginWithSMS(bodyParameters, options = {}) {
    validateRequiredRequestParams(bodyParameters, ["phone_number", "code"]);
    const { phone_number: username, code: otp, ...otherParams } = bodyParameters;
    return grant("http://auth0.com/oauth/grant-type/passwordless/otp", await this.addClientAuthentication({
      username,
      otp,
      realm: "sms",
      ...otherParams
    }), options, this.clientId, this.idTokenValidator, this.request.bind(this));
  }
};

// node_modules/auth0/dist/esm/auth/tokenExchange.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TOKEN_EXCHANGE_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
var TOKEN_URL2 = "/oauth/token";
var CustomTokenExchange = class extends BaseAuthAPI {
  static {
    __name(this, "CustomTokenExchange");
  }
  /**
   * Executes token exchange flow with security validations
   *
   * @param options - Exchange configuration parameters
   * @returns Auth0-issued tokens with requested claims
   *
   * @throws {Error} When:
   * - `subject_token_type` uses prohibited namespace
   * - Network failures occur
   * - Auth0 returns error responses (4xx/5xx)
   */
  async exchangeToken(options) {
    const body = {
      ...options,
      grant_type: TOKEN_EXCHANGE_GRANT_TYPE,
      client_id: this.clientId
    };
    await this.addClientAuthentication(body);
    const response = await this.request({
      path: TOKEN_URL2,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams(body)
    }, {});
    const r = await JSONApiResponse.fromResponse(response);
    return r.data;
  }
};

// node_modules/auth0/dist/esm/auth/index.js
var AuthenticationClient = class {
  static {
    __name(this, "AuthenticationClient");
  }
  constructor(options) {
    this.database = new Database(options);
    this.oauth = new OAuth(options);
    this.passwordless = new Passwordless(options);
    this.backchannel = new Backchannel(options);
    this.tokenExchange = new CustomTokenExchange(options);
  }
};

// node_modules/auth0/dist/esm/management/token-provider.js
var LEEWAY = 10 * 1e3;
var TokenProvider = class {
  static {
    __name(this, "TokenProvider");
  }
  constructor(options) {
    this.options = options;
    this.expiresAt = 0;
    this.accessToken = "";
    this.authenticationClient = new AuthenticationClient(options);
  }
  async getAccessToken() {
    if (!this.accessToken || Date.now() > this.expiresAt - LEEWAY) {
      this.pending = this.pending || this.authenticationClient.oauth.clientCredentialsGrant({
        audience: this.options.audience
      });
      const { data: { access_token: accessToken, expires_in: expiresIn } } = await this.pending.finally(() => {
        delete this.pending;
      });
      this.expiresAt = Date.now() + expiresIn * 1e3;
      this.accessToken = accessToken;
    }
    return this.accessToken;
  }
};

// node_modules/auth0/dist/esm/management/token-provider-middleware.js
var TokenProviderMiddleware = class {
  static {
    __name(this, "TokenProviderMiddleware");
  }
  constructor(options) {
    var _a2;
    if ("token" in options) {
      this.tokenProvider = {
        getAccessToken: /* @__PURE__ */ __name(() => resolveValueToPromise(options.token), "getAccessToken")
      };
    } else {
      this.tokenProvider = new TokenProvider({
        ...options,
        audience: (_a2 = options.audience) !== null && _a2 !== void 0 ? _a2 : `https://${options.domain}/api/v2/`,
        ...{ clientSecret: options.clientSecret },
        ...{
          clientAssertionSigningKey: options.clientAssertionSigningKey
        }
      });
    }
  }
  async pre(context2) {
    const token = await this.tokenProvider.getAccessToken();
    context2.init.headers = {
      ...context2.init.headers,
      Authorization: `Bearer ${token}`
    };
    return {
      url: context2.url,
      init: context2.init
    };
  }
};

// node_modules/auth0/dist/esm/management/management-client.js
var ManagementApiError = class extends Error {
  static {
    __name(this, "ManagementApiError");
  }
  constructor(errorCode, error3, statusCode, body, headers, msg) {
    super(msg);
    this.errorCode = errorCode;
    this.error = error3;
    this.statusCode = statusCode;
    this.body = body;
    this.headers = headers;
    this.msg = msg;
    this.name = "ManagementApiError";
  }
};
async function parseError2(response) {
  const body = await response.text();
  let data;
  try {
    data = JSON.parse(body);
    return new ManagementApiError(data.errorCode, data.error, data.statusCode || response.status, body, response.headers, data.message);
  } catch (_) {
    return new ResponseError(response.status, body, response.headers, "Response returned an error code");
  }
}
__name(parseError2, "parseError");
var ManagementClient = class extends ManagementClientBase {
  static {
    __name(this, "ManagementClient");
  }
  constructor(options) {
    super({
      ...options,
      baseUrl: `https://${options.domain}/api/v2`,
      middleware: [
        new TokenProviderMiddleware(options),
        ...options.telemetry !== false ? [new TelemetryMiddleware(options)] : []
      ],
      parseError: parseError2
    });
  }
};

// dist/auth/auth0-service.js
var Auth0Service = class {
  static {
    __name(this, "Auth0Service");
  }
  management;
  constructor(domain2, clientId, clientSecret) {
    this.management = new ManagementClient({
      domain: domain2,
      clientId,
      clientSecret,
      headers: {
        "tenant-id": "sesamy"
      }
    });
  }
  /**
   * Get organizations for a user
   */
  async getUserOrganizations(userId) {
    try {
      const organizations2 = await this.management.users.getUserOrganizations({
        id: userId
      });
      return organizations2.data;
    } catch (error3) {
      console.error("Failed to get user organizations:", error3);
      throw new Error("Failed to fetch user organizations");
    }
  }
  /**
   * Create a new organization
   */
  async createOrganization(name, displayName) {
    try {
      const organization = await this.management.organizations.create({
        name,
        display_name: displayName || name
      });
      return organization.data;
    } catch (error3) {
      console.error("Failed to create organization:", error3);
      if (error3.statusCode === 409) {
        throw new Error("Organization name already exists. Please choose a different name.");
      }
      if (error3.statusCode === 400) {
        throw new Error("Invalid organization data. Please check the organization name and try again.");
      }
      if (error3.statusCode === 403) {
        throw new Error("Insufficient permissions to create organization.");
      }
      const errorMessage = error3.message || error3.body || "Unknown error occurred";
      throw new Error(`Failed to create organization: ${errorMessage}`);
    }
  }
  /**
   * Add user to organization with specified roles
   */
  async addUserToOrganization(orgId, userId, roles) {
    try {
      try {
        await this.management.organizations.addMembers({ id: orgId }, { members: [userId] });
      } catch (memberError) {
        if (memberError.statusCode !== 409) {
          throw memberError;
        }
        console.log(`User ${userId} is already a member of organization ${orgId}`);
      }
      if (roles.length > 0) {
        try {
          await this.management.organizations.addMemberRoles({ id: orgId, user_id: userId }, { roles });
        } catch (roleError) {
          if (roleError.statusCode !== 409) {
            throw roleError;
          }
          console.log(`User ${userId} already has required roles in organization ${orgId}`);
        }
      }
    } catch (error3) {
      console.error("Failed to add user to organization:", error3);
      throw new Error("Failed to add user to organization");
    }
  }
  /**
   * Get organization by ID
   */
  async getOrganization(orgId) {
    try {
      const organization = await this.management.organizations.get({
        id: orgId
      });
      return organization.data;
    } catch (error3) {
      console.error("Failed to get organization:", error3);
      return null;
    }
  }
  /**
   * Find organization by name
   */
  async findOrganizationByName(name) {
    try {
      const organizations2 = await this.management.organizations.getAll();
      if (organizations2.data && organizations2.data.length > 0) {
        const foundOrg = organizations2.data.find((org) => org.name === name || org.display_name === name);
        return foundOrg || null;
      }
      return null;
    } catch (error3) {
      console.error("Failed to find organization by name:", error3);
      return null;
    }
  }
};

// dist/app.js
function createApp(database, bucket, r2AccessKeyId, r2SecretAccessKey, r2Endpoint, audioProcessingWorkflow, importShowWorkflow, auth0Domain, auth0ClientId, auth0ClientSecret) {
  const app = new OpenAPIHono();
  const eventPublisher = new EventPublisher();
  const showRepository = new ShowRepository(database);
  const showService = new ShowService(showRepository, eventPublisher);
  const episodeRepository = new EpisodeRepository(database);
  const taskService = new TaskService(database, audioProcessingWorkflow);
  const episodeService = new EpisodeService(episodeRepository, eventPublisher, taskService);
  const audioService = new AudioService(database, bucket, eventPublisher, r2AccessKeyId, r2SecretAccessKey, r2Endpoint, audioProcessingWorkflow);
  const imageService = bucket && r2AccessKeyId && r2SecretAccessKey ? new ImageService(bucket, r2AccessKeyId, r2SecretAccessKey, r2Endpoint, database) : void 0;
  const campaignRepository = new CampaignRepository(database);
  const campaignService = new CampaignService(campaignRepository, eventPublisher);
  const creativeUploadService = bucket && r2AccessKeyId && r2SecretAccessKey && r2Endpoint ? new CreativeUploadService(database, bucket, eventPublisher, r2AccessKeyId, r2SecretAccessKey, r2Endpoint) : void 0;
  const auth0Service = auth0Domain && auth0ClientId && auth0ClientSecret ? new Auth0Service(auth0Domain, auth0ClientId, auth0ClientSecret) : void 0;
  const organizationService = new OrganizationService(database ? (init_client(), __toCommonJS(client_exports)).getDatabase(database) : void 0, auth0Service);
  app.use("*", cors());
  app.use("*", logger());
  app.onError(errorHandler2);
  app.get("/", (c2) => {
    return c2.json({
      name: "podcast-service",
      version: "1.0.0"
    });
  });
  app.doc("/openapi.json", {
    openapi: "3.0.0",
    info: {
      title: "Podcast Service API",
      version: "1.0.0",
      description: "Service Standard v1 compliant Podcast Service"
    },
    security: [
      {
        Bearer: []
      }
    ],
    tags: [
      { name: "health", description: "Health check endpoints" },
      { name: "feeds", description: "RSS feed endpoints (no auth required)" },
      { name: "shows", description: "Podcast shows management" },
      { name: "episodes", description: "Episode management" },
      { name: "audio", description: "Audio file management" },
      { name: "tasks", description: "Background task management" },
      { name: "campaigns", description: "Advertising campaigns management" },
      { name: "creatives", description: "Campaign creatives management" },
      { name: "tts", description: "Text-to-speech conversion" },
      { name: "testing", description: "Testing endpoints" }
    ]
  });
  app.get("/swagger", middleware({ url: "/openapi.json" }));
  app.route("/storage", routes_default);
  registerHealthRoutes(app, database);
  registerFeedRoutes(app, showService, episodeRepository, audioService);
  app.use("/organizations", jwtMiddleware);
  app.use("/organizations/*", jwtMiddleware);
  registerOrganizationRoutes(app, organizationService);
  app.use("/shows/*", (c2, next) => {
    if (c2.req.path.endsWith("/feed")) {
      return next();
    }
    return authMiddleware(c2, next);
  });
  app.use("/episodes/*", authMiddleware);
  app.use("/audio/*", authMiddleware);
  app.use("/tasks/*", authMiddleware);
  app.use("/workflows/*", authMiddleware);
  app.use("/campaigns/*", authMiddleware);
  app.use("/tts/*", authMiddleware);
  app.use("/transcription/*", (c2, next) => {
    if (c2.req.path === "/transcription/test") {
      return next();
    }
    return authMiddleware(c2, next);
  });
  app.use("/test/*", (c2, next) => {
    if (c2.req.path === "/test/tts") {
      return next();
    }
    return authMiddleware(c2, next);
  });
  registerShowRoutes(app, showService, audioService, imageService, database, importShowWorkflow);
  registerEpisodeRoutes(app, episodeService, audioService, imageService, bucket);
  registerAudioRoutes(app, audioService);
  app.route("/", createTaskRoutes(database));
  app.route("/", createWorkflowRoutes());
  app.route("/", createCampaignRoutes(campaignService, audioService, creativeUploadService));
  return app;
}
__name(createApp, "createApp");

// dist/tasks/processor.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_service2();
var TaskProcessor = class {
  static {
    __name(this, "TaskProcessor");
  }
  taskService;
  isProcessing = false;
  constructor(database) {
    this.taskService = new TaskService(database);
  }
  async processTasks(batchSize = 5) {
    if (this.isProcessing) {
      console.log("Task processing already in progress, skipping...");
      return { processed: 0, successful: 0, failed: 0 };
    }
    this.isProcessing = true;
    let processed = 0;
    let successful = 0;
    let failed = 0;
    try {
      console.log(`Starting task processing (batch size: ${batchSize})`);
      const pendingTasks = await this.taskService.getTasks("pending", batchSize);
      const failedTasks = await this.taskService.getTasks("failed", Math.max(0, batchSize - pendingTasks.length));
      const tasksToProcess = [...pendingTasks, ...failedTasks];
      processed = tasksToProcess.length;
      if (processed === 0) {
        console.log("No tasks to process");
        return { processed: 0, successful: 0, failed: 0 };
      }
      for (const task of failedTasks) {
        try {
          await this.taskService.retryTask(task.id);
          successful++;
          console.log(`Retried failed task ${task.id}`);
        } catch (error3) {
          console.error(`Failed to retry task ${task.id}:`, error3);
          failed++;
        }
      }
      successful += pendingTasks.length;
      console.log(`Task processing completed: ${processed} processed, ${successful} successful, ${failed} failed`);
    } catch (error3) {
      console.error("Error during task processing:", error3);
      failed = processed;
      successful = 0;
    } finally {
      this.isProcessing = false;
    }
    return { processed, successful, failed };
  }
  /**
   * Scheduled task processor that can be called by Cloudflare Cron triggers
   */
  async handleScheduledTask(event) {
    console.log("Scheduled task processor triggered:", event.scheduledTime);
    try {
      const result = await this.processTasks(5);
      console.log("Scheduled task processing result:", result);
    } catch (error3) {
      console.error("Scheduled task processing failed:", error3);
      throw error3;
    }
  }
  /**
   * Process a specific task by ID for immediate processing
   */
  async processSpecificTask(taskId) {
    console.log(`Processing specific task: ${taskId}`);
    try {
      const task = await this.taskService.getTask(taskId);
      if (!task) {
        console.warn(`Task ${taskId} not found`);
        return;
      }
      if (task.status === "failed") {
        console.log(`Retrying failed task ${taskId}`);
        await this.taskService.retryTask(taskId);
        console.log(`Successfully retried task ${taskId}`);
      } else if (task.status === "pending") {
        console.log(`Task ${taskId} is pending - it should have been processed when created`);
        await this.taskService.retryTask(taskId);
        console.log(`Successfully triggered workflow for pending task ${taskId}`);
      } else {
        console.warn(`Task ${taskId} is in status '${task.status}' - no action needed`);
      }
    } catch (error3) {
      console.error(`Error processing specific task ${taskId}:`, error3);
      throw error3;
    }
  }
  /**
   * Manual trigger for task processing
   */
  async triggerProcessing(batchSize) {
    return await this.processTasks(batchSize);
  }
};

// dist/encoding/container.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/containers/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/containers/dist/lib/container.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/containers/dist/lib/helpers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function generateId(length = 9) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);
  let result = "";
  for (let i = 0; i < length; i++) {
    result += alphabet[bytes[i] % alphabet.length];
  }
  return result;
}
__name(generateId, "generateId");
function parseTimeExpression(timeExpression) {
  if (typeof timeExpression === "number") {
    return timeExpression;
  }
  if (typeof timeExpression === "string") {
    const match = timeExpression.match(/^(\d+)([smh])$/);
    if (!match) {
      throw new Error(`invalid time expression ${timeExpression}`);
    }
    const value = parseInt(match[1]);
    const unit = match[2];
    switch (unit) {
      case "s":
        return value;
      case "m":
        return value * 60;
      case "h":
        return value * 60 * 60;
      default:
        throw new Error(`unknown time unit ${unit}`);
    }
  }
  throw new Error(`invalid type for a time expression: ${typeof timeExpression}`);
}
__name(parseTimeExpression, "parseTimeExpression");

// node_modules/@cloudflare/containers/dist/lib/container.js
import { DurableObject } from "cloudflare:workers";
var NO_CONTAINER_INSTANCE_ERROR = "there is no container instance that can be provided to this durable object";
var RUNTIME_SIGNALLED_ERROR = "runtime signalled the container to exit:";
var UNEXPECTED_EXIT_ERROR = "container exited with unexpected exit code:";
var NOT_LISTENING_ERROR = "the container is not listening";
var CONTAINER_STATE_KEY = "__CF_CONTAINER_STATE";
var MAX_ALARM_RETRIES = 3;
var PING_TIMEOUT_MS = 5e3;
var DEFAULT_SLEEP_AFTER = "10m";
var INSTANCE_POLL_INTERVAL_MS = 300;
var TIMEOUT_TO_GET_CONTAINER_SECONDS = 8;
var TIMEOUT_TO_GET_PORTS = 20;
var TRIES_TO_GET_CONTAINER = Math.ceil(TIMEOUT_TO_GET_CONTAINER_SECONDS * 1e3 / INSTANCE_POLL_INTERVAL_MS);
var TRIES_TO_GET_PORTS = Math.ceil(TIMEOUT_TO_GET_PORTS * 1e3 / INSTANCE_POLL_INTERVAL_MS);
var FALLBACK_PORT_TO_CHECK = 33;
var TEMPORARY_HARDCODED_ATTEMPT_MAX = 6;
var signalToNumbers = {
  SIGINT: 2,
  SIGTERM: 15,
  SIGKILL: 9
};
function isErrorOfType(e, matchingString) {
  const errorString = e instanceof Error ? e.message : String(e);
  return errorString.toLowerCase().includes(matchingString);
}
__name(isErrorOfType, "isErrorOfType");
var isNoInstanceError = /* @__PURE__ */ __name((error3) => isErrorOfType(error3, NO_CONTAINER_INSTANCE_ERROR), "isNoInstanceError");
var isRuntimeSignalledError = /* @__PURE__ */ __name((error3) => isErrorOfType(error3, RUNTIME_SIGNALLED_ERROR), "isRuntimeSignalledError");
var isNotListeningError = /* @__PURE__ */ __name((error3) => isErrorOfType(error3, NOT_LISTENING_ERROR), "isNotListeningError");
var isContainerExitNonZeroError = /* @__PURE__ */ __name((error3) => isErrorOfType(error3, UNEXPECTED_EXIT_ERROR), "isContainerExitNonZeroError");
function getExitCodeFromError(error3) {
  if (!(error3 instanceof Error)) {
    return null;
  }
  if (isRuntimeSignalledError(error3)) {
    return +error3.message.toLowerCase().slice(error3.message.toLowerCase().indexOf(RUNTIME_SIGNALLED_ERROR) + RUNTIME_SIGNALLED_ERROR.length + 1);
  }
  if (isContainerExitNonZeroError(error3)) {
    return +error3.message.toLowerCase().slice(error3.message.toLowerCase().indexOf(UNEXPECTED_EXIT_ERROR) + UNEXPECTED_EXIT_ERROR.length + 1);
  }
  return null;
}
__name(getExitCodeFromError, "getExitCodeFromError");
function addTimeoutSignal(existingSignal, timeoutMs) {
  const controller = new AbortController();
  if (existingSignal?.aborted) {
    controller.abort();
    return controller.signal;
  }
  existingSignal?.addEventListener("abort", () => controller.abort());
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  controller.signal.addEventListener("abort", () => clearTimeout(timeoutId));
  return controller.signal;
}
__name(addTimeoutSignal, "addTimeoutSignal");
var ContainerState = class {
  static {
    __name(this, "ContainerState");
  }
  storage;
  status;
  constructor(storage2) {
    this.storage = storage2;
  }
  async setRunning() {
    await this.setStatusAndupdate("running");
  }
  async setHealthy() {
    await this.setStatusAndupdate("healthy");
  }
  async setStopping() {
    await this.setStatusAndupdate("stopping");
  }
  async setStopped() {
    await this.setStatusAndupdate("stopped");
  }
  async setStoppedWithCode(exitCode2) {
    this.status = { status: "stopped_with_code", lastChange: Date.now(), exitCode: exitCode2 };
    await this.update();
  }
  async getState() {
    if (!this.status) {
      const state = await this.storage.get(CONTAINER_STATE_KEY);
      if (!state) {
        this.status = {
          status: "stopped",
          lastChange: Date.now()
        };
        await this.update();
      } else {
        this.status = state;
      }
    }
    return this.status;
  }
  async setStatusAndupdate(status) {
    this.status = { status, lastChange: Date.now() };
    await this.update();
  }
  async update() {
    if (!this.status)
      throw new Error("status should be init");
    await this.storage.put(CONTAINER_STATE_KEY, this.status);
  }
};
var Container = class extends DurableObject {
  static {
    __name(this, "Container");
  }
  // =========================
  //     Public Attributes
  // =========================
  // Default port for the container (undefined means no default port)
  defaultPort;
  // Required ports that should be checked for availability during container startup
  // Override this in your subclass to specify ports that must be ready
  requiredPorts;
  // Timeout after which the container will sleep if no activity
  // The signal sent to the container by default is a SIGTERM.
  // The container won't get a SIGKILL if this threshold is triggered.
  sleepAfter = DEFAULT_SLEEP_AFTER;
  // Container configuration properties
  // Set these properties directly in your container instance
  envVars = {};
  entrypoint;
  enableInternet = true;
  // =========================
  //     PUBLIC INTERFACE
  // =========================
  constructor(ctx, env2, options) {
    super(ctx, env2);
    if (ctx.container === void 0) {
      throw new Error("Containers have not been enabled for this Durable Object class. Have you correctly setup your Wrangler config? More info: https://developers.cloudflare.com/containers/get-started/#configuration");
    }
    this.state = new ContainerState(this.ctx.storage);
    this.ctx.blockConcurrencyWhile(async () => {
      this.renewActivityTimeout();
      await this.scheduleNextAlarm();
    });
    this.container = ctx.container;
    if (options) {
      if (options.defaultPort !== void 0)
        this.defaultPort = options.defaultPort;
      if (options.sleepAfter !== void 0)
        this.sleepAfter = options.sleepAfter;
    }
    this.sql`
      CREATE TABLE IF NOT EXISTS container_schedules (
        id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),
        callback TEXT NOT NULL,
        payload TEXT,
        type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed')),
        time INTEGER NOT NULL,
        delayInSeconds INTEGER,
        created_at INTEGER DEFAULT (unixepoch())
      )
    `;
    if (this.container.running) {
      this.monitor = this.container.monitor();
      this.setupMonitorCallbacks();
    }
  }
  /**
   * Gets the current state of the container
   * @returns Promise<State>
   */
  async getState() {
    return { ...await this.state.getState() };
  }
  // ==========================
  //     CONTAINER STARTING
  // ==========================
  /**
   * Start the container if it's not running and set up monitoring
   *
   * This method handles the core container startup process without waiting for ports to be ready.
   * It will automatically retry if the container fails to start, up to maxTries attempts.
   *
   * It's useful when you need to:
   * - Start a container without blocking until a port is available
   * - Initialize a container that doesn't expose ports
   * - Perform custom port availability checks separately
   *
   * The method applies the container configuration from your instance properties by default, but allows
   * overriding these values for this specific startup:
   * - Environment variables (defaults to this.envVars)
   * - Custom entrypoint commands (defaults to this.entrypoint)
   * - Internet access settings (defaults to this.enableInternet)
   *
   * It also sets up monitoring to track container lifecycle events and automatically
   * calls the onStop handler when the container terminates.
   *
   * @example
   * // Basic usage in a custom Container implementation
   * async customInitialize() {
   *   // Start the container without waiting for a port
   *   await this.start();
   *
   *   // Perform additional initialization steps
   *   // that don't require port access
   * }
   *
   * @example
   * // Start with custom configuration
   * await this.start({
   *   envVars: { DEBUG: 'true', NODE_ENV: 'development' },
   *   entrypoint: ['npm', 'run', 'dev'],
   *   enableInternet: false
   * });
   *
   * @param options - Optional configuration to override instance defaults
   * @param waitOptions - Optional wait configuration with abort signal for cancellation
   * @returns A promise that resolves when the container start command has been issued
   * @throws Error if no container context is available or if all start attempts fail
   */
  async start(options, waitOptions) {
    const portToCheck = this.defaultPort ?? (this.requiredPorts ? this.requiredPorts[0] : FALLBACK_PORT_TO_CHECK);
    await this.startContainerIfNotRunning({
      abort: waitOptions?.signal,
      waitInterval: INSTANCE_POLL_INTERVAL_MS,
      retries: TRIES_TO_GET_CONTAINER,
      portToCheck
    }, options);
    this.setupMonitorCallbacks();
    await this.ctx.blockConcurrencyWhile(async () => {
      await this.onStart();
    });
  }
  async startAndWaitForPorts(portsOrArgs, cancellationOptions, startOptions) {
    let ports;
    let resolvedCancellationOptions = {};
    let resolvedStartOptions = {};
    if (typeof portsOrArgs === "object" && portsOrArgs !== null && !Array.isArray(portsOrArgs)) {
      ports = portsOrArgs.ports;
      resolvedCancellationOptions = portsOrArgs.cancellationOptions;
      resolvedStartOptions = portsOrArgs.startOptions;
    } else {
      ports = portsOrArgs;
      resolvedCancellationOptions = cancellationOptions;
      resolvedStartOptions = startOptions;
    }
    const portsToCheck = await this.getPortsToCheck(ports);
    const state = await this.state.getState();
    if (state.status === "healthy" && this.container.running) {
      if (this.container.running && !this.monitor) {
        this.monitor = this.container.monitor();
        this.setupMonitorCallbacks();
      }
      return;
    }
    await this.syncPendingStoppedEvents();
    resolvedCancellationOptions ??= {};
    let containerGetRetries = resolvedCancellationOptions.instanceGetTimeoutMS ? Math.ceil(resolvedCancellationOptions.instanceGetTimeoutMS / INSTANCE_POLL_INTERVAL_MS) : TRIES_TO_GET_CONTAINER;
    const waitOptions = {
      abort: resolvedCancellationOptions.abort,
      retries: containerGetRetries,
      waitInterval: resolvedCancellationOptions.waitInterval ?? INSTANCE_POLL_INTERVAL_MS,
      portToCheck: portsToCheck[0]
    };
    const abortedSignal = new Promise((res) => {
      waitOptions.abort?.addEventListener("abort", () => {
        res(true);
      });
    });
    const triesUsed = await this.startContainerIfNotRunning(waitOptions, resolvedStartOptions);
    let totalPortReadyTries = resolvedCancellationOptions.portReadyTimeoutMS ? Math.ceil(resolvedCancellationOptions.portReadyTimeoutMS / INSTANCE_POLL_INTERVAL_MS) : TRIES_TO_GET_PORTS;
    const triesLeft = totalPortReadyTries - triesUsed;
    for (const port of portsToCheck) {
      const tcpPort = this.container.getTcpPort(port);
      let portReady = false;
      for (let i = 0; i < triesLeft && !portReady; i++) {
        try {
          const combinedSignal = addTimeoutSignal(waitOptions.abort, PING_TIMEOUT_MS);
          await tcpPort.fetch("http://ping", { signal: combinedSignal });
          portReady = true;
          console.log(`Port ${port} is ready`);
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          console.debug(`Error checking ${port}: ${errorMessage}`);
          if (!this.container.running) {
            try {
              await this.onError(new Error(`Container crashed while checking for ports, did you setup the entrypoint correctly?`));
            } catch {
            }
            throw e;
          }
          if (i === triesLeft - 1) {
            try {
              await this.onError(`Failed to verify port ${port} is available after ${waitOptions.retries} attempts, last error: ${errorMessage}`);
            } catch {
            }
            throw e;
          }
          await Promise.any([
            new Promise((resolve) => setTimeout(resolve, waitOptions.waitInterval)),
            abortedSignal
          ]);
          if (waitOptions.abort?.aborted) {
            throw new Error("Container request timed out.");
          }
        }
      }
    }
    this.setupMonitorCallbacks();
    await this.ctx.blockConcurrencyWhile(async () => {
      await this.state.setHealthy();
      await this.onStart();
    });
  }
  // =======================
  //     LIFECYCLE HOOKS
  // =======================
  /**
   * Shuts down the container.
   * @param signal - The signal to send to the container (default: 15 for SIGTERM)
   */
  async stop(signal = "SIGTERM") {
    this.container.signal(typeof signal === "string" ? signalToNumbers[signal] : signal);
  }
  /**
   * Destroys the container. It will trigger onError instead of onStop.
   */
  async destroy() {
    await this.container.destroy();
  }
  /**
   * Lifecycle method called when container starts successfully
   * Override this method in subclasses to handle container start events
   */
  onStart() {
  }
  /**
   * Lifecycle method called when container shuts down
   * Override this method in subclasses to handle Container stopped events
   * @param params - Object containing exitCode and reason for the stop
   */
  onStop(_) {
  }
  /**
   * Lifecycle method called when the container is running, and the activity timeout
   * expiration has been reached.
   *
   * If you want to shutdown the container, you should call this.stop() here
   *
   * By default, this method calls `this.stop()`
   */
  async onActivityExpired() {
    if (!this.container.running) {
      return;
    }
    await this.stop();
  }
  /**
   * Error handler for container errors
   * Override this method in subclasses to handle container errors
   * @param error - The error that occurred
   * @returns Can return any value or throw the error
   */
  onError(error3) {
    console.error("Container error:", error3);
    throw error3;
  }
  /**
   * Renew the container's activity timeout
   *
   * Call this method whenever there is activity on the container
   */
  renewActivityTimeout() {
    const timeoutInMs = parseTimeExpression(this.sleepAfter) * 1e3;
    this.sleepAfterMs = Date.now() + timeoutInMs;
  }
  // ==================
  //     SCHEDULING
  // ==================
  /**
   * Schedule a task to be executed in the future
   * @template T Type of the payload data
   * @param when When to execute the task (Date object or number of seconds delay)
   * @param callback Name of the method to call
   * @param payload Data to pass to the callback
   * @returns Schedule object representing the scheduled task
   */
  async schedule(when, callback, payload) {
    const id = generateId(9);
    if (typeof callback !== "string") {
      throw new Error("Callback must be a string (method name)");
    }
    if (typeof this[callback] !== "function") {
      throw new Error(`this.${callback} is not a function`);
    }
    if (when instanceof Date) {
      const timestamp = Math.floor(when.getTime() / 1e3);
      this.sql`
        INSERT OR REPLACE INTO container_schedules (id, callback, payload, type, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(payload)}, 'scheduled', ${timestamp})
      `;
      await this.scheduleNextAlarm();
      return {
        taskId: id,
        callback,
        payload,
        time: timestamp,
        type: "scheduled"
      };
    }
    if (typeof when === "number") {
      const time4 = Math.floor(Date.now() / 1e3 + when);
      this.sql`
        INSERT OR REPLACE INTO container_schedules (id, callback, payload, type, delayInSeconds, time)
        VALUES (${id}, ${callback}, ${JSON.stringify(payload)}, 'delayed', ${when}, ${time4})
      `;
      await this.scheduleNextAlarm();
      return {
        taskId: id,
        callback,
        payload,
        delayInSeconds: when,
        time: time4,
        type: "delayed"
      };
    }
    throw new Error("Invalid schedule type. 'when' must be a Date or number of seconds");
  }
  // ============
  //     HTTP
  // ============
  /**
   * Send a request to the container (HTTP or WebSocket) using standard fetch API signature
   * Based on containers-starter-go implementation
   *
   * This method handles HTTP requests to the container. WebSocket requests done outside the DO*
   * won't work until https://github.com/cloudflare/workerd/issues/2319 is addressed. Until then, please use `switchPort` + `fetch()`.
   *
   * Method supports multiple signatures to match standard fetch API:
   * - containerFetch(request: Request, port?: number)
   * - containerFetch(url: string | URL, init?: RequestInit, port?: number)
   *
   * @param requestOrUrl The request object or URL string/object to send to the container
   * @param portOrInit Port number or fetch RequestInit options
   * @param portParam Optional port number when using URL+init signature
   * @returns A Response from the container, or WebSocket connection
   */
  async containerFetch(requestOrUrl, portOrInit, portParam) {
    let { request, port } = this.requestAndPortFromContainerFetchArgs(requestOrUrl, portOrInit, portParam);
    const state = await this.state.getState();
    if (!this.container.running || state.status !== "healthy") {
      try {
        await this.startAndWaitForPorts(port, { abort: request.signal });
      } catch (e) {
        if (isNoInstanceError(e)) {
          return new Response("There is no Container instance available at this time.\nThis is likely because you have reached your max concurrent instance count (set in wrangler config) or are you currently provisioning the Container.\nIf you are deploying your Container for the first time, check your dashboard to see provisioning status, this may take a few minutes.", { status: 503 });
        } else {
          return new Response(`Failed to start container: ${e instanceof Error ? e.message : String(e)}`, { status: 500 });
        }
      }
    }
    const tcpPort = this.container.getTcpPort(port);
    const containerUrl = request.url.replace("https:", "http:");
    try {
      this.renewActivityTimeout();
      const res = await tcpPort.fetch(containerUrl, request);
      return res;
    } catch (e) {
      if (!(e instanceof Error)) {
        throw e;
      }
      if (e.message.includes("Network connection lost.")) {
        return new Response("Container suddenly disconnected, try again", { status: 500 });
      }
      console.error(`Error proxying request to container ${this.ctx.id}:`, e);
      return new Response(`Error proxying request to container: ${e instanceof Error ? e.message : String(e)}`, { status: 500 });
    }
  }
  /**
   * Handle fetch requests to the Container
   * Default implementation forwards all HTTP and WebSocket requests to the container
   * Override this in your subclass to specify a port or implement custom request handling
   *
   * @param request The request to handle
   */
  async fetch(request) {
    if (this.defaultPort === void 0 && !request.headers.has("cf-container-target-port")) {
      throw new Error("No port configured for this container. Set the `defaultPort` in your Container subclass, or specify a port with `container.fetch(switchPort(request, port))`.");
    }
    let portValue = this.defaultPort;
    if (request.headers.has("cf-container-target-port")) {
      const portFromHeaders = parseInt(request.headers.get("cf-container-target-port") ?? "");
      if (isNaN(portFromHeaders)) {
        throw new Error("port value from switchPort is not a number");
      } else {
        portValue = portFromHeaders;
      }
    }
    return await this.containerFetch(request, portValue);
  }
  // ===============================
  // ===============================
  //     PRIVATE METHODS & ATTRS
  // ===============================
  // ===============================
  // ==========================
  //     PRIVATE ATTRIBUTES
  // ==========================
  container;
  // onStopCalled will be true when we are in the middle of an onStop call
  onStopCalled = false;
  state;
  monitor;
  monitorSetup = false;
  sleepAfterMs = 0;
  // ==========================
  //     GENERAL HELPERS
  // ==========================
  /**
   * Execute SQL queries against the Container's database
   */
  sql(strings, ...values) {
    let query = "";
    query = strings.reduce((acc, str, i) => acc + str + (i < values.length ? "?" : ""), "");
    return [...this.ctx.storage.sql.exec(query, ...values)];
  }
  requestAndPortFromContainerFetchArgs(requestOrUrl, portOrInit, portParam) {
    let request;
    let port;
    if (requestOrUrl instanceof Request) {
      request = requestOrUrl;
      port = typeof portOrInit === "number" ? portOrInit : void 0;
    } else {
      const url = typeof requestOrUrl === "string" ? requestOrUrl : requestOrUrl.toString();
      const init = typeof portOrInit === "number" ? {} : portOrInit || {};
      port = typeof portOrInit === "number" ? portOrInit : typeof portParam === "number" ? portParam : void 0;
      request = new Request(url, init);
    }
    if (port === void 0 && this.defaultPort === void 0) {
      throw new Error("No port specified for container fetch. Set defaultPort or specify a port parameter.");
    }
    port = port ?? this.defaultPort;
    return { request, port };
  }
  async getPortsToCheck(overridePorts) {
    let portsToCheck = [];
    if (overridePorts !== void 0) {
      portsToCheck = Array.isArray(overridePorts) ? overridePorts : [overridePorts];
    } else if (this.requiredPorts && this.requiredPorts.length > 0) {
      portsToCheck = [...this.requiredPorts];
    } else {
      portsToCheck = [this.defaultPort ?? FALLBACK_PORT_TO_CHECK];
    }
    return portsToCheck;
  }
  // ===========================================
  //     CONTAINER INTERACTION & MONITORING
  // ===========================================
  // Tries to start a container if it's not running
  // Reutns the number of tries used
  async startContainerIfNotRunning(waitOptions, options) {
    if (this.container.running) {
      if (!this.monitor) {
        this.monitor = this.container.monitor();
      }
      return 0;
    }
    const abortedSignal = new Promise((res) => {
      waitOptions.abort?.addEventListener("abort", () => {
        res(true);
      });
    });
    await this.state.setRunning();
    for (let tries = 0; tries < waitOptions.retries; tries++) {
      const envVars = options?.envVars ?? this.envVars;
      const entrypoint = options?.entrypoint ?? this.entrypoint;
      const enableInternet = options?.enableInternet ?? this.enableInternet;
      const startConfig = {
        enableInternet
      };
      if (envVars && Object.keys(envVars).length > 0)
        startConfig.env = envVars;
      if (entrypoint)
        startConfig.entrypoint = entrypoint;
      this.renewActivityTimeout();
      const handleError = /* @__PURE__ */ __name(async () => {
        const err = await this.monitor?.catch((err2) => err2);
        if (typeof err === "number") {
          const toThrow = new Error(`Error starting container, early exit code 0 before we could check for healthiness, did it crash early?`);
          try {
            await this.onError(toThrow);
          } catch {
          }
          throw toThrow;
        } else if (!isNoInstanceError(err)) {
          try {
            await this.onError(err);
          } catch {
          }
          throw err;
        }
      }, "handleError");
      if (!this.container.running) {
        if (tries > 0) {
          await handleError();
        }
        await this.scheduleNextAlarm();
        this.container.start(startConfig);
        this.monitor = this.container.monitor();
      } else {
        await this.scheduleNextAlarm();
      }
      this.renewActivityTimeout();
      const port = this.container.getTcpPort(waitOptions.portToCheck);
      try {
        const combinedSignal = addTimeoutSignal(waitOptions.abort, PING_TIMEOUT_MS);
        await port.fetch("http://containerstarthealthcheck", { signal: combinedSignal });
        return tries;
      } catch (error3) {
        if (isNotListeningError(error3) && this.container.running) {
          return tries;
        }
        if (!this.container.running && isNotListeningError(error3)) {
          await handleError();
        }
        console.debug("Error checking if container is ready:", error3 instanceof Error ? error3.message : String(error3));
        await Promise.any([
          new Promise((res) => setTimeout(res, waitOptions.waitInterval)),
          abortedSignal
        ]);
        if (waitOptions.abort?.aborted) {
          throw new Error("Aborted waiting for container to start as we received a cancellation signal");
        }
        if (TEMPORARY_HARDCODED_ATTEMPT_MAX === tries) {
          if (error3 instanceof Error && error3.message.includes("Network connection lost")) {
            this.ctx.abort();
          }
          throw new Error(NO_CONTAINER_INSTANCE_ERROR);
        }
        continue;
      }
    }
    throw new Error(`Container did not start after ${waitOptions.retries * waitOptions.waitInterval}ms`);
  }
  setupMonitorCallbacks() {
    if (this.monitorSetup) {
      return;
    }
    this.monitorSetup = true;
    this.monitor?.then(async () => {
      await this.ctx.blockConcurrencyWhile(async () => {
        await this.state.setStoppedWithCode(0);
      });
    }).catch(async (error3) => {
      if (isNoInstanceError(error3)) {
        return;
      }
      const exitCode2 = getExitCodeFromError(error3);
      if (exitCode2 !== null) {
        await this.state.setStoppedWithCode(exitCode2);
        this.monitorSetup = false;
        this.monitor = void 0;
        return;
      }
      try {
        await this.onError(error3);
      } catch {
      }
    }).finally(() => {
      this.monitorSetup = false;
      if (this.timeout) {
        if (this.resolve)
          this.resolve();
        clearTimeout(this.timeout);
      }
    });
  }
  deleteSchedules(name) {
    this.sql`DELETE FROM container_schedules WHERE callback = ${name}`;
  }
  // ============================
  //     ALARMS AND SCHEDULES
  // ============================
  /**
   * Method called when an alarm fires
   * Executes any scheduled tasks that are due
   */
  async alarm(alarmProps) {
    if (alarmProps.isRetry && alarmProps.retryCount > MAX_ALARM_RETRIES) {
      const scheduleCount = Number(this.sql`SELECT COUNT(*) as count FROM container_schedules`[0]?.count) || 0;
      const hasScheduledTasks = scheduleCount > 0;
      if (hasScheduledTasks || this.container.running) {
        await this.scheduleNextAlarm();
      }
      return;
    }
    const prevAlarm = Date.now();
    await this.ctx.storage.setAlarm(prevAlarm);
    await this.ctx.storage.sync();
    const result = this.sql`
         SELECT * FROM container_schedules;
       `;
    let minTime = Date.now() + 3 * 60 * 1e3;
    const now = Date.now() / 1e3;
    for (const row of result) {
      if (row.time > now) {
        continue;
      }
      const callback = this[row.callback];
      if (!callback || typeof callback !== "function") {
        console.error(`Callback ${row.callback} not found or is not a function`);
        continue;
      }
      const schedule = this.getSchedule(row.id);
      try {
        const payload = row.payload ? JSON.parse(row.payload) : void 0;
        await callback.call(this, payload, await schedule);
      } catch (e) {
        console.error(`Error executing scheduled callback "${row.callback}":`, e);
      }
      this.sql`DELETE FROM container_schedules WHERE id = ${row.id}`;
    }
    const resultForMinTime = this.sql`
         SELECT * FROM container_schedules;
       `;
    const minTimeFromSchedules = Math.min(...resultForMinTime.map((r) => r.time * 1e3));
    if (!this.container.running) {
      await this.syncPendingStoppedEvents();
      if (resultForMinTime.length == 0) {
        await this.ctx.storage.deleteAlarm();
      } else {
        await this.ctx.storage.setAlarm(minTimeFromSchedules);
      }
      return;
    }
    if (this.isActivityExpired()) {
      await this.onActivityExpired();
      this.renewActivityTimeout();
      return;
    }
    minTime = Math.min(minTimeFromSchedules, minTime, this.sleepAfterMs);
    const timeout = Math.max(0, minTime - Date.now());
    await new Promise((resolve) => {
      this.resolve = resolve;
      if (!this.container.running) {
        resolve();
        return;
      }
      this.timeout = setTimeout(() => {
        resolve();
      }, timeout);
    });
    await this.ctx.storage.setAlarm(Date.now());
  }
  timeout;
  resolve;
  // synchronises container state with the container source of truth to process events
  async syncPendingStoppedEvents() {
    const state = await this.state.getState();
    if (!this.container.running && state.status === "healthy") {
      await this.callOnStop({ exitCode: 0, reason: "exit" });
      return;
    }
    if (!this.container.running && state.status === "stopped_with_code") {
      await this.callOnStop({ exitCode: state.exitCode ?? 0, reason: "exit" });
      return;
    }
  }
  async callOnStop(onStopParams) {
    if (this.onStopCalled) {
      return;
    }
    this.onStopCalled = true;
    const promise = this.onStop(onStopParams);
    if (promise instanceof Promise) {
      await promise.finally(() => {
        this.onStopCalled = false;
      });
    } else {
      this.onStopCalled = false;
    }
    await this.state.setStopped();
  }
  /**
   * Schedule the next alarm based on upcoming tasks
   */
  async scheduleNextAlarm(ms = 1e3) {
    const nextTime = ms + Date.now();
    if (this.timeout) {
      if (this.resolve)
        this.resolve();
      clearTimeout(this.timeout);
    }
    await this.ctx.storage.setAlarm(nextTime);
    await this.ctx.storage.sync();
  }
  async listSchedules(name) {
    const result = this.sql`
      SELECT * FROM container_schedules WHERE callback = ${name} LIMIT 1
    `;
    if (!result || result.length === 0) {
      return [];
    }
    return result.map(this.toSchedule);
  }
  toSchedule(schedule) {
    let payload;
    try {
      payload = JSON.parse(schedule.payload);
    } catch (e) {
      console.error(`Error parsing payload for schedule ${schedule.id}:`, e);
      payload = void 0;
    }
    if (schedule.type === "delayed") {
      return {
        taskId: schedule.id,
        callback: schedule.callback,
        payload,
        type: "delayed",
        time: schedule.time,
        delayInSeconds: schedule.delayInSeconds
      };
    }
    return {
      taskId: schedule.id,
      callback: schedule.callback,
      payload,
      type: "scheduled",
      time: schedule.time
    };
  }
  /**
   * Get a scheduled task by ID
   * @template T Type of the payload data
   * @param id ID of the scheduled task
   * @returns The Schedule object or undefined if not found
   */
  async getSchedule(id) {
    const result = this.sql`
      SELECT * FROM container_schedules WHERE id = ${id} LIMIT 1
    `;
    if (!result || result.length === 0) {
      return void 0;
    }
    const schedule = result[0];
    return this.toSchedule(schedule);
  }
  isActivityExpired() {
    return this.sleepAfterMs <= Date.now();
  }
};

// node_modules/@cloudflare/containers/dist/lib/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/encoding/container.js
var EncodingContainer = class extends Container {
  static {
    __name(this, "EncodingContainer");
  }
  // Port the container listens on (default: 8080)
  defaultPort = 8080;
  // Time before container sleeps due to inactivity (15 minutes - increased for long-running tasks)
  sleepAfter = "15m";
  // Environment variables passed to the container
  envVars = {
    NODE_ENV: "production",
    // Add timeout settings for better container management
    CONTAINER_TIMEOUT: "15m"
  };
  // Optional lifecycle hooks
  onStart() {
    console.log("Encoding container successfully started");
  }
  onStop() {
    console.log("Encoding container successfully shut down");
  }
  onError(error3) {
    console.log("Encoding container error:", error3);
  }
  // Add better health checking
  onHealthCheck() {
    console.log("Encoding container health check");
    return { status: "healthy", timestamp: (/* @__PURE__ */ new Date()).toISOString() };
  }
};

// dist/workflows/audio-processing/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { WorkflowEntrypoint } from "cloudflare:workers";

// dist/workflows/audio-processing/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
var AudioProcessingParamsSchema = external_exports.object({
  episodeId: external_exports.string().min(1, "Episode ID is required"),
  audioR2Key: external_exports.string().min(1, "Audio R2 key is required"),
  chunkDuration: external_exports.number().positive().optional().default(60),
  overlapDuration: external_exports.number().positive().optional().default(2),
  encodingFormats: external_exports.array(external_exports.string()).optional().default(["mp3_128"]),
  taskId: external_exports.string().optional(),
  workflowId: external_exports.string().optional(),
  transcriptionLanguage: external_exports.string().optional().default("en"),
  transcriptionModel: external_exports.string().optional().default("@cf/deepgram/nova-3"),
  useNova3Features: external_exports.boolean().optional().default(true)
});
var WorkflowStateSchema = external_exports.object({
  workflowId: external_exports.string().uuid(),
  episodeId: external_exports.string(),
  audioR2Key: external_exports.string(),
  chunkDuration: external_exports.number().positive(),
  overlapDuration: external_exports.number().positive(),
  encodingFormats: external_exports.array(external_exports.string()),
  startedAt: external_exports.string().datetime(),
  taskId: external_exports.string().optional(),
  transcriptionLanguage: external_exports.string(),
  transcriptionModel: external_exports.string(),
  useNova3Features: external_exports.boolean(),
  previewDownloadUrl: external_exports.string().url()
});
var EncodedAudioSchema = external_exports.object({
  encodedR2Key: external_exports.string(),
  encodedAudioUrl: external_exports.string().url(),
  duration: external_exports.number().positive(),
  signedUrls: external_exports.array(external_exports.string().url()).optional()
});
var AudioMetadataSchema = external_exports.object({
  duration: external_exports.number().positive(),
  expectedChunks: external_exports.number().positive(),
  chunkUploadUrls: external_exports.array(external_exports.object({
    index: external_exports.number().int().nonnegative(),
    r2Key: external_exports.string(),
    uploadUrl: external_exports.string().url()
  })),
  encodedAudioUrl: external_exports.string().url(),
  encodedR2Key: external_exports.string(),
  signedUrls: external_exports.array(external_exports.string().url()).optional()
});
var ChunkingResultSchema = external_exports.object({
  chunks: external_exports.array(external_exports.string().url()),
  signedUrls: external_exports.array(external_exports.string().url()).optional()
});
var EncodingResultSchema = external_exports.object({
  format: external_exports.string(),
  bitrate: external_exports.number().positive(),
  r2Key: external_exports.string(),
  size: external_exports.number().positive(),
  duration: external_exports.number().positive().optional(),
  signedUrls: external_exports.array(external_exports.string().url()).optional()
});
var AudioChunkSchema = external_exports.object({
  index: external_exports.number().int().nonnegative(),
  startTime: external_exports.number().nonnegative(),
  endTime: external_exports.number().positive(),
  duration: external_exports.number().positive(),
  chunkId: external_exports.string().optional(),
  r2Key: external_exports.string(),
  metadata: external_exports.object({
    format: external_exports.string(),
    bitrate: external_exports.number().positive(),
    size: external_exports.number().positive(),
    channels: external_exports.number().positive(),
    sampleRate: external_exports.number().positive()
  }).optional()
});
var WordSchema = external_exports.object({
  word: external_exports.string(),
  start: external_exports.number().nonnegative(),
  end: external_exports.number().nonnegative()
});
var Nova3SpeakerSchema = external_exports.object({
  speaker: external_exports.string(),
  start: external_exports.number(),
  end: external_exports.number(),
  confidence: external_exports.number().optional()
});
var ChapterSchema = external_exports.object({
  title: external_exports.string(),
  startTime: external_exports.number().nonnegative(),
  endTime: external_exports.number().nonnegative(),
  summary: external_exports.string().optional()
});
var TranscribedChunkSchema = external_exports.object({
  words: external_exports.array(WordSchema),
  startTime: external_exports.number().nonnegative(),
  endTime: external_exports.number().positive(),
  chunkIndex: external_exports.number().int().nonnegative(),
  raw: external_exports.any(),
  metadata: external_exports.object({
    language: external_exports.string().optional(),
    sentiments: external_exports.array(external_exports.object({
      text: external_exports.string(),
      sentiment: external_exports.enum(["positive", "negative", "neutral"]),
      confidence: external_exports.number(),
      start: external_exports.number(),
      end: external_exports.number()
    })).optional(),
    summary: external_exports.string().optional(),
    speakers: external_exports.array(Nova3SpeakerSchema).optional(),
    keywords: external_exports.array(external_exports.object({
      keyword: external_exports.string(),
      confidence: external_exports.number(),
      start: external_exports.number(),
      end: external_exports.number()
    })).optional(),
    paragraphs: external_exports.array(external_exports.object({
      text: external_exports.string(),
      start: external_exports.number(),
      end: external_exports.number(),
      speaker: external_exports.string().optional()
    })).optional(),
    chapters: external_exports.array(ChapterSchema).optional(),
    ttsAudioUrl: external_exports.string().url().optional()
    // Add TTS audio URL field
  }).optional()
});
var EnhancedTranscriptResultSchema = external_exports.object({
  enhancedTranscriptUrl: external_exports.string().url(),
  keywords: external_exports.array(external_exports.string()),
  chapters: external_exports.array(ChapterSchema),
  paragraphs: external_exports.number().positive(),
  summary: external_exports.string().optional()
});
var ComprehensiveTranscriptSchema = external_exports.object({
  text: external_exports.string(),
  html: external_exports.string(),
  markdown: external_exports.string(),
  originalWords: external_exports.array(WordSchema),
  totalWords: external_exports.number(),
  totalParagraphs: external_exports.number()
});
var Nova3ResponseSchema = external_exports.object({
  result: external_exports.object({
    results: external_exports.object({
      channels: external_exports.array(external_exports.object({
        alternatives: external_exports.array(external_exports.object({
          confidence: external_exports.number(),
          paragraphs: external_exports.object({
            paragraphs: external_exports.array(external_exports.object({
              end: external_exports.number(),
              num_words: external_exports.number(),
              sentences: external_exports.array(external_exports.object({
                end: external_exports.number(),
                start: external_exports.number(),
                text: external_exports.string()
              })),
              speaker: external_exports.number(),
              start: external_exports.number()
            })),
            transcript: external_exports.string()
          }),
          transcript: external_exports.string(),
          words: external_exports.array(external_exports.object({
            confidence: external_exports.number(),
            end: external_exports.number(),
            punctuated_word: external_exports.string(),
            speaker: external_exports.number(),
            speaker_confidence: external_exports.number(),
            start: external_exports.number(),
            word: external_exports.string()
          }))
        })),
        detected_language: external_exports.string(),
        language_confidence: external_exports.number()
      }))
    }),
    usage: external_exports.object({
      prompt_tokens: external_exports.number(),
      completion_tokens: external_exports.number(),
      total_tokens: external_exports.number()
    })
  }),
  success: external_exports.boolean(),
  errors: external_exports.array(external_exports.unknown()),
  messages: external_exports.array(external_exports.unknown())
});
var Nova3TranscriptionSchema = external_exports.object({
  text: external_exports.string(),
  language: external_exports.string().optional(),
  summary: external_exports.string().optional(),
  sentiments: external_exports.array(external_exports.object({
    text: external_exports.string(),
    sentiment: external_exports.enum(["positive", "negative", "neutral"]),
    confidence: external_exports.number(),
    start: external_exports.number(),
    end: external_exports.number()
  })).optional(),
  speakers: external_exports.array(Nova3SpeakerSchema).optional(),
  keywords: external_exports.array(external_exports.object({
    keyword: external_exports.string(),
    confidence: external_exports.number(),
    start: external_exports.number(),
    end: external_exports.number()
  })).optional(),
  paragraphs: external_exports.array(external_exports.object({
    text: external_exports.string(),
    start: external_exports.number(),
    end: external_exports.number(),
    speaker: external_exports.string().optional()
  })).optional(),
  words: external_exports.array(WordSchema).optional()
});
var StepOutputSchema = external_exports.object({
  success: external_exports.boolean(),
  data: external_exports.any().optional(),
  signedUrls: external_exports.array(external_exports.string().url()).optional(),
  error: external_exports.string().optional()
});

// dist/workflows/audio-processing/initialize-workflow.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
init_zod();
var InitializeInputSchema = AudioProcessingParamsSchema;
var InitializeOutputSchema = WorkflowStateSchema.extend({
  signedUrls: external_exports.array(external_exports.string().url()).optional()
});
var InitializeWorkflowStep = class {
  static {
    __name(this, "InitializeWorkflowStep");
  }
  env;
  constructor(env2) {
    this.env = env2;
  }
  validateInput(input) {
    return InitializeInputSchema.parse(input);
  }
  validateOutput(output) {
    return InitializeOutputSchema.parse(output);
  }
  async execute(input) {
    const validInput = this.validateInput(input);
    const { episodeId, audioR2Key, chunkDuration = 60, overlapDuration = 2, encodingFormats = ["mp3_128"], taskId, transcriptionLanguage = this.env.DEFAULT_TRANSCRIPTION_LANGUAGE || "en", transcriptionModel = this.env.DEFAULT_TRANSCRIPTION_MODEL || "@cf/deepgram/nova-3", useNova3Features = this.env.USE_NOVA3_FEATURES === "true" || false } = validInput;
    if (!episodeId || !audioR2Key) {
      throw new Error(`Episode ID and audio R2 key are required [Settings: episodeId=${episodeId}, audioR2Key=${audioR2Key ? "provided" : "missing"}, transcriptionLanguage=${transcriptionLanguage}, transcriptionModel=${transcriptionModel}]`);
    }
    const isNova3 = transcriptionModel === "@cf/deepgram/nova-3" || useNova3Features;
    const finalChunkDuration = isNova3 ? 60 : chunkDuration;
    const finalOverlapDuration = isNova3 ? 2 : overlapDuration;
    const finalTranscriptionModel = isNova3 ? "@cf/deepgram/nova-3" : transcriptionModel;
    const workflowId = v4_default();
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const actualR2Key = audioR2Key.startsWith("r2://") ? audioR2Key.substring(5) : audioR2Key;
    const previewDownloadUrl = await generateSignedDownloadUrl(this.env, actualR2Key, 3600);
    const result = {
      workflowId,
      episodeId,
      audioR2Key,
      chunkDuration: finalChunkDuration,
      overlapDuration: finalOverlapDuration,
      encodingFormats,
      startedAt: timestamp,
      taskId,
      transcriptionLanguage,
      transcriptionModel: finalTranscriptionModel,
      useNova3Features: isNova3,
      previewDownloadUrl: previewDownloadUrl.url,
      signedUrls: [previewDownloadUrl.url]
    };
    return this.validateOutput(result);
  }
};

// dist/workflows/audio-processing/tts-encode.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
async function encodeAudioForTTS(env2, workflowState) {
  const validatedState = WorkflowStateSchema.parse(workflowState);
  const containerId = env2.ENCODING_CONTAINER.idFromName("encoding-service");
  const container = env2.ENCODING_CONTAINER.get(containerId);
  const actualR2Key = validatedState.audioR2Key.startsWith("r2://") ? validatedState.audioR2Key.substring(5) : validatedState.audioR2Key;
  const r2Generator = new R2PreSignedUrlGenerator(env2.R2_ACCESS_KEY_ID, env2.R2_SECRET_ACCESS_KEY, env2.R2_ENDPOINT);
  const audioDownloadUrl = await r2Generator.generatePresignedUrl(
    "podcast-service-assets",
    actualR2Key,
    3600
    // 1 hour
  );
  const encodedFileId = v4_default();
  const encodedR2Key = `processing/${validatedState.episodeId}/${encodedFileId}_24k_mono.ogg`;
  const encodedUploadResult = await generateSignedUploadUrl(
    env2,
    encodedR2Key,
    "audio/ogg",
    // Content-Type for Opus files (stored in OGG container)
    3600
    // 1 hour expiration
  );
  const encodeResponse = await container.fetch("http://localhost:8080/encode", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      audioUrl: audioDownloadUrl,
      uploadUrl: encodedUploadResult.url,
      outputFormat: "opus",
      bitrate: 24,
      channels: 1,
      // Mono
      sampleRate: 16e3
      // 16 kHz for optimal transcription
    })
  });
  if (!encodeResponse.ok) {
    const errorText = await encodeResponse.text();
    let errorData;
    try {
      errorData = JSON.parse(errorText);
    } catch {
      errorData = { error: errorText };
    }
    throw new Error(`Processing encoding failed: ${errorData.error || errorText}`);
  }
  const encodeResult = await encodeResponse.json();
  const encodedDownloadUrl = await r2Generator.generatePresignedUrl(
    "podcast-service-assets",
    encodedR2Key,
    3600
    // 1 hour
  );
  const result = {
    encodedR2Key,
    encodedAudioUrl: encodedDownloadUrl,
    // Pre-signed for next step
    duration: encodeResult.metadata?.duration || 0,
    signedUrls: [audioDownloadUrl, encodedUploadResult.url, encodedDownloadUrl]
  };
  return EncodedAudioSchema.parse(result);
}
__name(encodeAudioForTTS, "encodeAudioForTTS");

// dist/workflows/audio-processing/progress-reporter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_service2();
init_repository();
var WorkflowProgressReporter = class {
  static {
    __name(this, "WorkflowProgressReporter");
  }
  env;
  taskId;
  workflowId;
  taskService;
  taskRepository;
  constructor(env2, taskId, workflowId) {
    this.env = env2;
    this.taskId = taskId;
    this.workflowId = workflowId;
    this.taskService = new TaskService(env2.DB);
    this.taskRepository = new TaskRepository(env2.DB);
  }
  /**
   * Report progress for a specific step
   */
  async reportStepProgress(step, progress, message2, data) {
    if (!this.taskId) {
      console.warn("No task ID provided, skipping progress update");
      return;
    }
    try {
      const taskIdNum = parseInt(this.taskId);
      if (isNaN(taskIdNum)) {
        console.error(`Invalid task ID: ${this.taskId}`);
        return;
      }
      const stepMessage = message2 || `${step}: ${progress}%`;
      await this.taskService.updateTaskStep(taskIdNum, stepMessage, progress);
      if (data) {
        const resultData = {
          step,
          progress,
          message: stepMessage,
          data,
          workflowId: this.workflowId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        await this.taskRepository.updateStatus(taskIdNum, "processing", {
          result: JSON.stringify(resultData)
        });
      }
      console.log(`Progress reported for step ${step}: ${progress}% (task ${this.taskId})`);
    } catch (error3) {
      console.error("Error reporting workflow progress:", error3);
    }
  }
  /**
   * Report step completion
   */
  async reportStepComplete(step, message2, data) {
    await this.reportStepProgress(step, 100, message2, data);
  }
  /**
   * Report step completion with result data stored in task
   */
  async reportStepCompleteWithResult(step, message2, resultData) {
    await this.reportStepProgress(step, 100, message2, resultData);
  }
  /**
   * Report step failure
   */
  async reportStepError(step, error3, data) {
    await this.reportStepProgress(step, 0, `Error: ${error3}`, data);
  }
  /**
   * Report encoding progress (for containers that can report incremental progress)
   */
  async reportEncodingProgress(format, progress, data) {
    await this.reportStepProgress("audio-encoding", progress, `Encoding ${format}: ${progress}%`, { format, ...data });
  }
  /**
   * Report workflow status change
   */
  async reportWorkflowStatus(status, message2, data) {
    if (!this.taskId) {
      console.warn("No task ID provided, skipping status update");
      return;
    }
    try {
      const taskIdNum = parseInt(this.taskId);
      if (isNaN(taskIdNum)) {
        console.error(`Invalid task ID: ${this.taskId}`);
        return;
      }
      const updateData = {};
      if (message2) {
        updateData.step = message2;
      }
      if (data) {
        const resultData = {
          status,
          message: message2,
          data,
          workflowId: this.workflowId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        updateData.result = JSON.stringify(resultData);
      }
      await this.taskRepository.updateStatus(taskIdNum, status, updateData);
      console.log(`Status reported: ${status} (task ${this.taskId})`);
    } catch (error3) {
      console.error("Error reporting workflow status:", error3);
    }
  }
};

// dist/workflows/audio-processing/audio-chunking.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm_browser();
async function audioChunking(env2, workflowState, encodedAudio) {
  const totalDuration = encodedAudio.duration;
  const expectedChunks = Math.ceil(totalDuration / workflowState.chunkDuration);
  const chunkUploadUrls = [];
  for (let i = 0; i < expectedChunks; i++) {
    const chunkId = v4_default();
    const chunkR2Key = `chunks/${workflowState.episodeId}/${chunkId}.ogg`;
    const chunkUploadResult = await generateSignedUploadUrl(
      env2,
      chunkR2Key,
      "audio/ogg",
      // Content-Type for Opus files (stored in OGG container)
      3600
      // 1 hour expiration
    );
    chunkUploadUrls.push({
      index: i,
      r2Key: chunkR2Key,
      uploadUrl: chunkUploadResult.url
    });
  }
  const r2Generator = new R2PreSignedUrlGenerator(env2.R2_ACCESS_KEY_ID, env2.R2_SECRET_ACCESS_KEY, env2.R2_ENDPOINT);
  const directAudioUrl = encodedAudio.encodedAudioUrl;
  const containerId = env2.ENCODING_CONTAINER.idFromName("encoding-service");
  const container = env2.ENCODING_CONTAINER.get(containerId);
  const chunkResponse = await container.fetch("http://localhost:8080/chunk", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      audioUrl: directAudioUrl,
      // Use direct R2 presigned URL instead of storage endpoint
      chunkUploadUrls,
      chunkDuration: workflowState.chunkDuration,
      overlapDuration: workflowState.overlapDuration,
      duration: totalDuration
      // Pass the pre-determined duration
    })
  });
  if (!chunkResponse.ok) {
    const errorText = await chunkResponse.text();
    let errorData;
    try {
      errorData = JSON.parse(errorText);
    } catch {
      errorData = { error: errorText };
    }
    throw new Error(`Chunking request failed: ${JSON.stringify(errorData)}`);
  }
  const chunkResult = await chunkResponse.json();
  if (!chunkResult.success || !chunkResult.chunks) {
    throw new Error(`Invalid chunking response: ${JSON.stringify(chunkResult)}`);
  }
  const audioUrls = await Promise.all(chunkResult.chunks.map(async (chunk) => {
    return await r2Generator.generatePresignedUrl(
      "podcast-service-assets",
      chunk.r2Key,
      3600
      // 1 hour expiration
    );
  }));
  return {
    chunks: audioUrls
  };
}
__name(audioChunking, "audioChunking");

// dist/workflows/audio-processing/transcribe-chunks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function fetchAudioData(audioUrl) {
  const response = await fetch(audioUrl);
  if (!response.ok) {
    throw new Error(`Failed to fetch from audio URL: ${response.status} ${response.statusText}`);
  }
  return { response };
}
__name(fetchAudioData, "fetchAudioData");
async function transcribeWithWhisper(env2, workflowState, audioUrl, chunkIndex) {
  const defaultLanguage = env2.DEFAULT_TRANSCRIPTION_LANGUAGE || "en";
  const language = workflowState.transcriptionLanguage || defaultLanguage;
  const { response } = await fetchAudioData(audioUrl);
  const audioArrayBuffer = await response.arrayBuffer();
  const transcriptionOptions = {
    audio: Array.from(new Uint8Array(audioArrayBuffer)),
    language
  };
  const transcriptResponse = await env2.AI.run(workflowState.transcriptionModel, transcriptionOptions);
  return transcriptResponse;
}
__name(transcribeWithWhisper, "transcribeWithWhisper");
async function transcribeWithDeepgram(env2, workflowState, audioUrl, chunkIndex) {
  const chunkStartOffset = chunkIndex * workflowState.chunkDuration;
  const { response } = await fetchAudioData(audioUrl);
  const transcriptionOptions = {
    audio: {
      body: response.body,
      contentType: "audio/ogg"
    }
  };
  if (workflowState.useNova3Features) {
    transcriptionOptions.punctuate = true;
    transcriptionOptions.smart_format = true;
    transcriptionOptions.numerals = true;
    transcriptionOptions.dictation = true;
    transcriptionOptions.diarize = true;
    transcriptionOptions.detectLanguage = true;
  }
  const transcriptResponse = await env2.AI.run(workflowState.transcriptionModel, transcriptionOptions);
  if (!transcriptResponse || Object.keys(transcriptResponse).length === 0) {
    console.warn(`Deepgram returned empty response for chunk ${chunkIndex}`);
    return null;
  }
  return {
    startTime: chunkStartOffset,
    endTime: chunkStartOffset + workflowState.chunkDuration,
    chunkIndex,
    raw: transcriptResponse
  };
}
__name(transcribeWithDeepgram, "transcribeWithDeepgram");
async function transcribeChunks(env2, workflowState, chunkingResult) {
  if (chunkingResult.chunks.length === 0) {
    throw new Error(`No chunks available for transcription. [Settings: language=${workflowState.transcriptionLanguage || env2.DEFAULT_TRANSCRIPTION_LANGUAGE || "en"}, model=${workflowState.transcriptionModel}, nova3=${workflowState.useNova3Features}]`);
  }
  const chunkErrors = [];
  const allTranscriptions = [];
  const transcribeChunk = /* @__PURE__ */ __name(async (audioUrl, index) => {
    if (!audioUrl) {
      const error3 = `No audio URL available for chunk ${index}`;
      console.warn(error3);
      chunkErrors.push({ index, error: error3 });
      return null;
    }
    try {
      const chunkStartOffset = index * workflowState.chunkDuration;
      let transcriptResult;
      switch (workflowState.transcriptionModel) {
        case "@cf/deepgram/nova-3":
          transcriptResult = await transcribeWithDeepgram(env2, workflowState, audioUrl, index);
          break;
        case "@cf/openai/whisper":
          transcriptResult = await transcribeWithWhisper(env2, workflowState, audioUrl, index);
          break;
        default:
          throw new Error(`Unsupported transcription model: ${workflowState.transcriptionModel}. Supported models: deepgram/nova-*, @cf/openai/whisper-*`);
      }
      if (transcriptResult) {
        allTranscriptions.push({
          chunkStartOffset,
          chunkIndex: index,
          transcript: transcriptResult
        });
      }
      return transcriptResult;
    } catch (error3) {
      const errorMsg = `Transcription failed for chunk ${index}: ${error3.message}`;
      chunkErrors.push({ index, error: errorMsg });
      return null;
    }
  }, "transcribeChunk");
  const concurrencyLimit = 3;
  const transcribed = [];
  let skippedChunks = 0;
  for (let i = 0; i < chunkingResult.chunks.length; i += concurrencyLimit) {
    const batch = chunkingResult.chunks.slice(i, i + concurrencyLimit);
    const batchResults = await Promise.all(batch.map((audioUrl, batchIndex) => transcribeChunk(audioUrl, i + batchIndex)));
    const validResults = batchResults.filter((result) => result !== null);
    skippedChunks += batchResults.length - validResults.length;
    transcribed.push(...validResults);
  }
  let chunkTranscriptionsUrl;
  if (allTranscriptions.length > 0) {
    try {
      const transcriptionsJson = JSON.stringify(allTranscriptions, null, 2);
      const r2Key = `transcriptions/${workflowState.episodeId}/${workflowState.workflowId}/chunk-transcriptions.json`;
      await env2.BUCKET.put(r2Key, transcriptionsJson, {
        httpMetadata: {
          contentType: "application/json"
        }
      });
      const signedUrl = await generateSignedDownloadUrl(
        env2,
        r2Key,
        3600 * 24
        // 24 hours expiration
      );
      chunkTranscriptionsUrl = signedUrl.url;
      console.log(`Stored ${allTranscriptions.length} chunk transcriptions to R2: ${r2Key}`);
      console.log(`Signed URL: ${chunkTranscriptionsUrl}`);
    } catch (error3) {
      console.error("Failed to store transcriptions JSON to R2:", error3);
    }
  }
  if (transcribed.length === 0) {
    const errorDetails = chunkErrors.map(({ index, error: error3 }) => `Chunk ${index}: ${error3}`).join("; ");
    const detailedError = `All ${chunkingResult.chunks.length} chunks failed transcription. Cannot proceed without any transcribed content. Model: ${workflowState.transcriptionModel}. Errors: ${errorDetails}`;
    throw new Error(detailedError);
  }
  return {
    chunkTranscriptionsUrl
  };
}
__name(transcribeChunks, "transcribeChunks");

// dist/workflows/audio-processing/cleanup-resources.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function extractR2KeyFromUrl(signedUrl) {
  try {
    const url = new URL(signedUrl);
    const pathname = url.pathname;
    if (pathname.startsWith("/")) {
      return pathname.substring(1);
    }
    return pathname;
  } catch (error3) {
    console.warn(`Failed to extract R2 key from URL: ${signedUrl}`, error3);
    return null;
  }
}
__name(extractR2KeyFromUrl, "extractR2KeyFromUrl");
async function cleanupResources(env2, encodedAudio, chunkingResult) {
  const cleanedFiles = [];
  try {
    await env2.BUCKET.delete(encodedAudio.encodedR2Key);
    cleanedFiles.push(encodedAudio.encodedR2Key);
  } catch (error3) {
    console.warn(`Failed to delete encoded file ${encodedAudio.encodedR2Key}:`, error3);
  }
  const chunkDeletePromises = chunkingResult.chunks.map(async (chunkUrl) => {
    const r2Key = extractR2KeyFromUrl(chunkUrl);
    if (r2Key) {
      try {
        await env2.BUCKET.delete(r2Key);
        cleanedFiles.push(r2Key);
        console.log(`Deleted chunk file: ${r2Key}`);
      } catch (error3) {
        console.warn(`Failed to delete chunk file ${r2Key}:`, error3);
      }
    }
  });
  await Promise.all(chunkDeletePromises);
  return {
    cleanedUp: true,
    cleanedFiles,
    note: `Cleaned up ${cleanedFiles.length} files: temporary encoded file and ${chunkingResult.chunks.length} chunk files from R2`,
    chunkCount: chunkingResult.chunks.length
  };
}
__name(cleanupResources, "cleanupResources");

// dist/workflows/audio-processing/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/workflows/audio-processing/index.js
var AudioProcessingWorkflow = class extends WorkflowEntrypoint {
  static {
    __name(this, "AudioProcessingWorkflow");
  }
  totalSteps = 9;
  async updateWorkflowStatus(taskId, status, message2) {
    if (!taskId)
      return;
    try {
      const taskIdNum = parseInt(taskId);
      if (isNaN(taskIdNum)) {
        console.error(`Invalid task ID: ${taskId}`);
        return;
      }
      const { TaskService: TaskService2 } = await Promise.resolve().then(() => (init_service2(), service_exports2));
      const taskService = new TaskService2(this.env.DB);
      await taskService.updateTaskStatus(taskIdNum, status || "processing", {
        message: message2
      });
    } catch (error3) {
      console.error("Error updating workflow status:", error3);
    }
  }
  async updateStepProgress(stepNumber, description, taskId, data) {
    if (!taskId)
      return;
    const progress = Math.round(stepNumber / this.totalSteps * 100);
    const stepMessage = `${stepNumber}/${this.totalSteps} ${description}`;
    try {
      const taskIdNum = parseInt(taskId);
      if (isNaN(taskIdNum)) {
        console.error(`Invalid task ID: ${taskId}`);
        return;
      }
      const { TaskService: TaskService2 } = await Promise.resolve().then(() => (init_service2(), service_exports2));
      const taskService = new TaskService2(this.env.DB);
      await taskService.updateTaskStep(taskIdNum, stepMessage, progress);
      if (data) {
        await this.updateTaskResult(taskId, {
          step: stepNumber,
          description,
          progress,
          stepMessage,
          data,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    } catch (error3) {
      console.error("Error updating step progress:", error3);
    }
  }
  async updateTaskResult(taskId, result) {
    try {
      const taskIdNum = parseInt(taskId);
      if (isNaN(taskIdNum)) {
        console.error(`Invalid task ID: ${taskId}`);
        return;
      }
      const { TaskRepository: TaskRepository2 } = await Promise.resolve().then(() => (init_repository(), repository_exports));
      const taskRepository = new TaskRepository2(this.env.DB);
      await taskRepository.updateStatus(taskIdNum, "processing", {
        result: JSON.stringify(result)
      });
    } catch (error3) {
      console.error("Error updating task result:", error3);
    }
  }
  async handleWorkflowError(stepName, error3, taskId, workflowId) {
    const errorMessage = error3 instanceof Error ? error3.message : String(error3);
    const fullErrorMessage = `Failed at step ${stepName}: ${errorMessage}`;
    console.error(`Workflow failed at step ${stepName}:`, errorMessage);
    try {
      if (workflowId) {
        const { WorkflowService: WorkflowService2 } = await Promise.resolve().then(() => (init_service(), service_exports));
        const workflowService = new WorkflowService2(this.env.DB);
        await workflowService.failWorkflow(
          workflowId,
          fullErrorMessage,
          void 0
          // actualDuration - could be calculated if needed
        );
      } else if (taskId) {
        await this.updateWorkflowStatus(taskId, "failed", fullErrorMessage);
      }
      if (taskId) {
        await this.updateTaskResult(taskId, {
          status: "failed",
          error: fullErrorMessage,
          step: stepName,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          originalError: errorMessage
        });
      }
    } catch (updateError) {
      console.error("Failed to update workflow failure status:", updateError);
    }
  }
  async run(event, step) {
    let validatedParams;
    try {
      validatedParams = AudioProcessingParamsSchema.parse(event.payload);
    } catch (error3) {
      console.error("Invalid workflow parameters:", error3);
      throw new Error(`Invalid workflow parameters: ${error3 instanceof Error ? error3.message : String(error3)}`);
    }
    const progressReporter = new WorkflowProgressReporter(
      this.env,
      validatedParams.taskId,
      event.payload.workflowId
      // This would be passed by the task service
    );
    let currentStep = "initialization";
    try {
      try {
        await this.updateWorkflowStatus(validatedParams.taskId, "processing", "Workflow started");
        console.log(`Starting audio processing workflow for episode ${validatedParams.episodeId}`);
      } catch (error3) {
        console.error("Failed to set initial workflow status:", error3);
      }
      currentStep = "initialize-workflow";
      let workflowState = await step.do("initialize-workflow", async () => {
        await this.updateStepProgress(1, "Initializing workflow", validatedParams.taskId);
        await progressReporter.reportStepProgress("initialize-workflow", 0, "1/10 Initializing workflow");
        const initStep = new InitializeWorkflowStep(this.env);
        const result = await initStep.execute(validatedParams);
        await progressReporter.reportStepComplete("initialize-workflow", "Workflow initialized successfully");
        const { signedUrls, ...legacyResult } = result;
        return legacyResult;
      });
      currentStep = "encode";
      let encodedAudio = await step.do("encode", {
        retries: {
          limit: 2,
          delay: "5 seconds"
        },
        timeout: "10 minutes"
      }, async () => {
        await this.updateStepProgress(2, "Encoding audio", validatedParams.taskId);
        await progressReporter.reportStepProgress("encode-for-tts", 0, "2/10 Encoding audio for TTS");
        const result = await encodeAudioForTTS(this.env, workflowState);
        await progressReporter.reportStepComplete("encode", "Encode audio for TTS");
        const { signedUrls, ...legacyResult } = result;
        return legacyResult;
      });
      currentStep = "audio-chunking";
      let chunkingResult = await step.do("audio-chunking", {
        retries: {
          limit: 3,
          delay: "10 seconds",
          backoff: "exponential"
        },
        timeout: "12 minutes"
        // Increased timeout to account for storage preparation
      }, async () => {
        await this.updateStepProgress(3, "Preparing storage and creating audio chunks", validatedParams.taskId);
        await progressReporter.reportStepProgress("audio-chunking", 0, "3/9 Preparing storage and creating audio chunks");
        const result = await audioChunking(this.env, workflowState, encodedAudio);
        await progressReporter.reportStepComplete("audio-chunking", `Created ${result.chunks.length} audio chunks`);
        return result;
      });
      currentStep = "transcribe-chunks";
      const transcriptionResult = await step.do("transcribe-chunks", {
        retries: {
          limit: 2,
          delay: "10 seconds",
          backoff: "exponential"
        },
        timeout: "20 minutes"
      }, async () => {
        await this.updateStepProgress(4, "Transcribing audio chunks", validatedParams.taskId);
        await progressReporter.reportStepProgress("transcribe-chunks", 0, "4/9 Transcribing audio chunks");
        const result = await transcribeChunks(this.env, workflowState, chunkingResult);
        await progressReporter.reportStepComplete("transcribe-chunks", `Transcription completed (${chunkingResult.chunks.length} chunks)`, {
          chunkTranscriptionsUrl: result.chunkTranscriptionsUrl
        });
        return result;
      });
      let chunkTranscriptionsUrl = transcriptionResult.chunkTranscriptionsUrl;
      currentStep = "cleanup-resources";
      await step.do("cleanup-resources", {
        retries: {
          limit: 1,
          delay: "2 seconds"
        },
        timeout: "1 minute"
      }, async () => {
        await this.updateStepProgress(8, "Cleaning up temporary files", validatedParams.taskId);
        return await cleanupResources(this.env, encodedAudio, chunkingResult);
      });
    } catch (error3) {
      console.error(`Workflow failed at step: ${currentStep}`, error3);
      await this.handleWorkflowError(currentStep, error3, validatedParams.taskId, validatedParams.workflowId);
      throw error3;
    }
  }
};

// dist/workflows/import-show/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_types2();
import { WorkflowEntrypoint as WorkflowEntrypoint2 } from "cloudflare:workers";

// dist/workflows/import-show/step-classes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_zod();
init_repository3();
init_esm_browser();
var ParseRSSInputSchema = external_exports.object({
  rssUrl: external_exports.string().url(),
  maxEpisodes: external_exports.number().int().positive()
});
var ParseRSSOutputSchema = external_exports.object({
  parsedRSS: external_exports.object({
    title: external_exports.string(),
    description: external_exports.string(),
    imageUrl: external_exports.string().nullable().optional(),
    language: external_exports.string().optional(),
    categories: external_exports.array(external_exports.string()).optional(),
    author: external_exports.string().optional(),
    episodes: external_exports.array(external_exports.any())
  }),
  totalEpisodes: external_exports.number().int().nonnegative()
});
var ValidateAndParseRSSStep = class {
  static {
    __name(this, "ValidateAndParseRSSStep");
  }
  env;
  constructor(env2) {
    this.env = env2;
  }
  validateInput(input) {
    return ParseRSSInputSchema.parse(input);
  }
  validateOutput(output) {
    return ParseRSSOutputSchema.parse(output);
  }
  async execute(input) {
    const validInput = this.validateInput(input);
    try {
      console.log(`Fetching and parsing RSS from: ${validInput.rssUrl}`);
      const parsedRSS = await fetchAndParseRSS(validInput.rssUrl);
      const result = {
        parsedRSS,
        totalEpisodes: Math.min(parsedRSS.episodes.length, validInput.maxEpisodes)
      };
      console.log(`Successfully parsed RSS: ${parsedRSS.title} with ${parsedRSS.episodes.length} episodes`);
      return this.validateOutput(result);
    } catch (error3) {
      if (error3 instanceof RSSParseError || error3 instanceof RSSValidationError) {
        throw new Error(`RSS parsing failed: ${error3.message}`);
      }
      throw new Error(`Unexpected error during RSS parsing: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
  }
};
var CreateShowInputSchema = external_exports.object({
  title: external_exports.string(),
  description: external_exports.string(),
  imageUrl: external_exports.string().nullable().optional(),
  language: external_exports.string().optional(),
  categories: external_exports.array(external_exports.string()).optional(),
  author: external_exports.string().optional()
});
var CreateShowOutputSchema = external_exports.object({
  showId: external_exports.string().uuid(),
  title: external_exports.string(),
  description: external_exports.string(),
  imageUrl: external_exports.string().nullable().optional(),
  language: external_exports.string().nullable().optional(),
  categories: external_exports.array(external_exports.string()).nullable().optional(),
  author: external_exports.string().nullable().optional()
});
var CreateShowStep = class {
  static {
    __name(this, "CreateShowStep");
  }
  env;
  constructor(env2) {
    this.env = env2;
  }
  validateInput(input) {
    return CreateShowInputSchema.parse(input);
  }
  validateOutput(output) {
    return CreateShowOutputSchema.parse(output);
  }
  async execute(input) {
    const validInput = this.validateInput(input);
    try {
      console.log(`Creating show: ${validInput.title}`);
      const showRepository = new ShowRepository(this.env.DB);
      const eventPublisher = new EventPublisher();
      const showId = v4_default();
      const now = (/* @__PURE__ */ new Date()).toISOString();
      let processedImageUrl = validInput.imageUrl;
      if (validInput.imageUrl && this.env.BUCKET) {
        try {
          console.log(`Downloading show image from: ${validInput.imageUrl}`);
          const imageResponse = await fetch(validInput.imageUrl, {
            headers: {
              "User-Agent": "Sesamy Podcast Importer/1.0"
            },
            signal: AbortSignal.timeout(15e3)
            // 15 second timeout
          });
          if (imageResponse.ok) {
            const imageBuffer = await imageResponse.arrayBuffer();
            const imageBlob = new Uint8Array(imageBuffer);
            const imageFileName = `show-${showId}-${Date.now()}.jpg`;
            const imageR2Key = `shows/${showId}/${imageFileName}`;
            await this.env.BUCKET.put(imageR2Key, imageBlob, {
              httpMetadata: {
                contentType: imageResponse.headers.get("content-type") || "image/jpeg"
              }
            });
            processedImageUrl = `r2://${imageR2Key}`;
            console.log(`Show image uploaded to R2: ${imageR2Key}`);
          } else {
            console.warn(`Failed to download show image: ${imageResponse.status}`);
          }
        } catch (error3) {
          console.error("Failed to download/upload show image:", error3);
        }
      }
      const show = await showRepository.create({
        id: showId,
        organizationId: "default-org",
        // TODO: Get from workflow context
        title: validInput.title,
        description: validInput.description,
        imageUrl: processedImageUrl,
        language: validInput.language,
        categories: validInput.categories,
        author: validInput.author
      });
      await eventPublisher.publish("show.created", show, show.id);
      const result = {
        showId: show.id,
        title: show.title,
        description: show.description,
        imageUrl: show.imageUrl,
        language: show.language || null,
        categories: show.categories || null,
        author: show.author || null
      };
      console.log(`Successfully created show with ID: ${show.id}`);
      return this.validateOutput(result);
    } catch (error3) {
      throw new Error(`Failed to create show: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
  }
};
var ProcessEpisodeInputSchema = external_exports.object({
  showId: external_exports.string().uuid(),
  episode: external_exports.object({
    title: external_exports.string(),
    description: external_exports.string(),
    audioUrl: external_exports.string().url(),
    imageUrl: external_exports.string().nullable().optional(),
    publishedAt: external_exports.string().datetime().nullable().optional(),
    duration: external_exports.number().positive().nullable().optional(),
    episodeNumber: external_exports.number().int().nonnegative().nullable().optional(),
    seasonNumber: external_exports.number().int().nonnegative().nullable().optional(),
    episodeType: external_exports.string().nullable().optional(),
    author: external_exports.string().nullable().optional(),
    subtitle: external_exports.string().nullable().optional(),
    explicit: external_exports.boolean().nullable().optional(),
    keywords: external_exports.array(external_exports.string()).nullable().optional()
  }),
  skipExisting: external_exports.boolean().optional().default(false)
});
var ProcessEpisodeOutputSchema = external_exports.object({
  episodeId: external_exports.string().uuid(),
  title: external_exports.string(),
  status: external_exports.enum(["created", "skipped"]),
  audioR2Key: external_exports.string().optional(),
  audioProcessingTaskId: external_exports.string().optional()
});
var ProcessEpisodeStep = class {
  static {
    __name(this, "ProcessEpisodeStep");
  }
  env;
  constructor(env2) {
    this.env = env2;
  }
  validateInput(input) {
    return ProcessEpisodeInputSchema.parse(input);
  }
  validateOutput(output) {
    return ProcessEpisodeOutputSchema.parse(output);
  }
  async execute(input) {
    const validInput = this.validateInput(input);
    try {
      console.log(`Processing episode: ${validInput.episode.title}`);
      const episodeRepository = new EpisodeRepository(this.env.DB);
      const eventPublisher = new EventPublisher();
      const episodeId = v4_default();
      const now = (/* @__PURE__ */ new Date()).toISOString();
      let processedImageUrl = validInput.episode.imageUrl;
      if (validInput.episode.imageUrl && this.env.BUCKET) {
        try {
          console.log(`Downloading episode image from: ${validInput.episode.imageUrl}`);
          const imageResponse = await fetch(validInput.episode.imageUrl, {
            headers: {
              "User-Agent": "Sesamy Podcast Importer/1.0"
            },
            signal: AbortSignal.timeout(15e3)
            // 15 second timeout
          });
          if (imageResponse.ok) {
            const imageBuffer = await imageResponse.arrayBuffer();
            const imageBlob = new Uint8Array(imageBuffer);
            const imageFileName = `episode-${episodeId}-${Date.now()}.jpg`;
            const imageR2Key = `episodes/${validInput.showId}/${imageFileName}`;
            await this.env.BUCKET.put(imageR2Key, imageBlob, {
              httpMetadata: {
                contentType: imageResponse.headers.get("content-type") || "image/jpeg"
              }
            });
            processedImageUrl = `r2://${imageR2Key}`;
            console.log(`Episode image uploaded to R2: ${imageR2Key}`);
          } else {
            console.warn(`Failed to download episode image: ${imageResponse.status}`);
          }
        } catch (error3) {
          console.error("Failed to download/upload episode image:", error3);
        }
      }
      const episode = await episodeRepository.create(validInput.showId, {
        id: episodeId,
        organizationId: "default-org",
        // TODO: Get from workflow context
        title: validInput.episode.title,
        description: validInput.episode.description,
        imageUrl: processedImageUrl,
        audioUrl: null,
        // Will be set after audio processing
        transcriptUrl: null,
        duration: validInput.episode.duration || null,
        episodeNumber: validInput.episode.episodeNumber || null,
        seasonNumber: validInput.episode.seasonNumber || null,
        episodeType: validInput.episode.episodeType || null,
        author: validInput.episode.author || null,
        subtitle: validInput.episode.subtitle || null,
        explicit: validInput.episode.explicit || null,
        keywords: validInput.episode.keywords ? JSON.stringify(validInput.episode.keywords) : null
      });
      await eventPublisher.publish("episode.created", episode, episode.id);
      let audioR2Key;
      let audioProcessingTaskId;
      try {
        console.log(`Downloading audio from: ${validInput.episode.audioUrl}`);
        const audioResponse = await fetch(validInput.episode.audioUrl, {
          headers: {
            "User-Agent": "Sesamy Podcast Importer/1.0"
          },
          signal: AbortSignal.timeout(3e4)
          // 30 second timeout
        });
        if (!audioResponse.ok) {
          throw new Error(`Failed to download audio: ${audioResponse.status} ${audioResponse.statusText}`);
        }
        const audioBuffer = await audioResponse.arrayBuffer();
        const audioBlob = new Uint8Array(audioBuffer);
        const audioFileName = `episode-${episode.id}-${Date.now()}.mp3`;
        audioR2Key = `episodes/${validInput.showId}/${audioFileName}`;
        if (this.env.BUCKET) {
          await this.env.BUCKET.put(audioR2Key, audioBlob, {
            httpMetadata: {
              contentType: audioResponse.headers.get("content-type") || "audio/mpeg"
            }
          });
          await episodeRepository.updateByIdOnly(episode.id, {
            audioUrl: `r2://${audioR2Key}`
          });
          console.log(`Audio uploaded to R2: ${audioR2Key}`);
          if (this.env.AUDIO_PROCESSING_WORKFLOW) {
            try {
              console.log(`Triggering audio processing workflow for episode ${episode.id}`);
              const audioProcessingParams = {
                episodeId: episode.id,
                audioR2Key,
                chunkDuration: 60,
                transcriptionLanguage: "auto"
                // Auto-detect language
              };
              const audioWorkflowInstance = await this.env.AUDIO_PROCESSING_WORKFLOW.create({
                params: audioProcessingParams
              });
              audioProcessingTaskId = audioWorkflowInstance.id;
              console.log(`Audio processing workflow started: ${audioWorkflowInstance.id}`);
            } catch (error3) {
              console.error(`Failed to start audio processing workflow for episode ${episode.id}:`, error3);
            }
          } else {
            console.warn("AUDIO_PROCESSING_WORKFLOW not available, skipping audio processing");
          }
        } else {
          console.warn("BUCKET not available, skipping audio upload");
        }
      } catch (error3) {
        console.error(`Failed to download/process audio for episode ${episode.id}:`, error3);
      }
      const result = {
        episodeId: episode.id,
        title: episode.title,
        status: "created",
        audioR2Key,
        audioProcessingTaskId
      };
      console.log(`Successfully created episode with ID: ${episode.id}`);
      return this.validateOutput(result);
    } catch (error3) {
      throw new Error(`Failed to process episode: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
    }
  }
};

// dist/workflows/import-show/index.js
var ImportShowWorkflow = class extends WorkflowEntrypoint2 {
  static {
    __name(this, "ImportShowWorkflow");
  }
  async updateWorkflowStatus(taskId, status, message2) {
    if (!taskId)
      return;
    try {
      const taskIdNum = parseInt(taskId);
      if (isNaN(taskIdNum)) {
        console.error(`Invalid task ID: ${taskId}`);
        return;
      }
      const { TaskService: TaskService2 } = await Promise.resolve().then(() => (init_service2(), service_exports2));
      const taskService = new TaskService2(this.env.DB);
      if (status && message2) {
        await taskService.updateTaskStep(taskIdNum, message2);
        const { TaskRepository: TaskRepository2 } = await Promise.resolve().then(() => (init_repository(), repository_exports));
        const taskRepository = new TaskRepository2(this.env.DB);
        await taskRepository.updateStatus(taskIdNum, status, {
          step: message2
        });
      } else if (status) {
        const { TaskRepository: TaskRepository2 } = await Promise.resolve().then(() => (init_repository(), repository_exports));
        const taskRepository = new TaskRepository2(this.env.DB);
        await taskRepository.updateStatus(taskIdNum, status);
      } else if (message2) {
        await taskService.updateTaskStep(taskIdNum, message2);
      }
    } catch (error3) {
      console.warn("Failed to update task status:", error3);
    }
  }
  async run(event, step) {
    const params = ImportShowParamsSchema.parse(event.payload);
    console.log("Starting import-show workflow with params:", {
      rssUrl: params.rssUrl,
      taskId: params.taskId,
      maxEpisodes: params.maxEpisodes
    });
    await this.updateWorkflowStatus(params.taskId, "running", "Starting RSS import");
    try {
      const parseStep = new ValidateAndParseRSSStep(this.env);
      const parseResult = await step.do("parse-rss", async () => {
        return await parseStep.execute({
          rssUrl: params.rssUrl,
          maxEpisodes: params.maxEpisodes
        });
      });
      await this.updateWorkflowStatus(params.taskId, "running", `Parsed RSS: ${parseResult.parsedRSS.title} (${parseResult.totalEpisodes} episodes)`);
      const createShowStep = new CreateShowStep(this.env);
      const showResult = await step.do("create-show", async () => {
        return await createShowStep.execute({
          title: parseResult.parsedRSS.title,
          description: parseResult.parsedRSS.description,
          imageUrl: parseResult.parsedRSS.imageUrl,
          language: parseResult.parsedRSS.language,
          categories: parseResult.parsedRSS.categories,
          author: parseResult.parsedRSS.author
        });
      });
      await this.updateWorkflowStatus(params.taskId, "running", `Created show: ${showResult.title} (ID: ${showResult.showId})`);
      const episodes2 = parseResult.parsedRSS.episodes.slice(0, params.maxEpisodes);
      const episodeResults = [];
      for (let i = 0; i < episodes2.length; i++) {
        const episode = episodes2[i];
        const processEpisodeStep = new ProcessEpisodeStep(this.env);
        const episodeResult = await step.do(`process-episode-${i}`, async () => {
          return await processEpisodeStep.execute({
            showId: showResult.showId,
            episode: {
              title: episode.title,
              description: episode.description,
              audioUrl: episode.audioUrl,
              imageUrl: episode.imageUrl,
              publishedAt: episode.publishedAt
            },
            skipExisting: params.skipExistingEpisodes
          });
        });
        episodeResults.push(episodeResult);
        await this.updateWorkflowStatus(params.taskId, "running", `Processed episode ${i + 1}/${episodes2.length}: ${episodeResult.title}`);
        if (i < episodes2.length - 1) {
          await step.sleep("delay-between-episodes", 1e3);
        }
      }
      await this.updateWorkflowStatus(params.taskId, "completed", `Successfully imported show "${showResult.title}" with ${episodeResults.length} episodes`);
      return {
        success: true,
        showId: showResult.showId,
        showTitle: showResult.title,
        episodesCreated: episodeResults.length,
        episodes: episodeResults
      };
    } catch (error3) {
      await this.updateWorkflowStatus(params.taskId, "failed", `Workflow failed: ${error3 instanceof Error ? error3.message : "Unknown error"}`);
      throw error3;
    }
  }
};

// dist/worker.js
var worker_default = {
  async fetch(request, env2, ctx) {
    const app = createApp(env2.DB, env2.BUCKET, env2.R2_ACCESS_KEY_ID, env2.R2_SECRET_ACCESS_KEY, env2.R2_ENDPOINT, env2.AUDIO_PROCESSING_WORKFLOW, env2.IMPORT_SHOW_WORKFLOW, env2.AWS_LAMBDA_ENCODING_URL);
    if (env2.JWT_SECRET && !process.env.JWT_SECRET) {
      process.env.JWT_SECRET = env2.JWT_SECRET;
    }
    if (env2.ENCODING_SERVICE_PROVIDER && !process.env.ENCODING_SERVICE_PROVIDER) {
      process.env.ENCODING_SERVICE_PROVIDER = env2.ENCODING_SERVICE_PROVIDER;
    }
    return app.fetch(request, env2, ctx);
  },
  async scheduled(event, env2, ctx) {
    const taskProcessor = new TaskProcessor(env2.DB);
    await taskProcessor.handleScheduledTask(event);
  },
  async queue(batch, env2, ctx) {
    console.log(`Processing ${batch.messages.length} queue messages`);
    for (const message2 of batch.messages) {
      try {
        console.log("Processing message:", message2.id);
        message2.ack();
      } catch (error3) {
        console.error("Error processing queue message:", error3);
        message2.retry();
      }
    }
  }
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// .wrangler/tmp/bundle-wvXYCG/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default
];
var middleware_insertion_facade_default = worker_default;

// node_modules/wrangler/templates/middleware/common.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-wvXYCG/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  AudioProcessingWorkflow,
  EncodingContainer,
  ImportShowWorkflow,
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

aws4fetch/dist/aws4fetch.esm.mjs:
  (**
   * @license MIT <https://opensource.org/licenses/MIT>
   * @copyright Michael Hart 2024
   *)
*/
//# sourceMappingURL=worker.js.map
